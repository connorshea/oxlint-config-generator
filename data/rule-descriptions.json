{
  "eslint": {
    "accessor-pairs": "Enforces getter/setter pairs in objects and classes.\n\nIt's a common mistake in JavaScript to create an object with just a setter\nfor a property but never have a corresponding getter defined for it.\nWithout a getter, you cannot read the property, so it ends up not being used.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: true\n\nEnforce the rule for class members.\n\ntype: boolean\n\ndefault: false\n\nEnforce the rule for TypeScript interfaces and types.\n\ntype: boolean\n\ndefault: false\n\nReport a getter without a setter.\n\ntype: boolean\n\ndefault: true\n\nReport a setter without a getter.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "array-callback-return": "Enforce return statements in callbacks of array methods\n\nArray has several methods for filtering, mapping, and folding.\nIf we forget to write return statement in a callback of those, it’s probably a mistake.\nIf you don’t want to use a return or don’t need the returned results,\nconsider using .forEach instead.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhen set to true, allows callbacks of methods that require a return value to\nimplicitly return undefined with a return statement containing no expression.\n\ntype: boolean\n\ndefault: false\n\nWhen set to true, rule will also report forEach callbacks that return a value.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "arrow-body-style": "This rule can enforce or disallow the use of braces around arrow function body.\nArrow functions can use either:\n\n- a block body () => { ... }\n- or a concise body () => expression with an implicit return.\n\nInconsistent use of block vs. concise bodies makes code harder to read.\nConcise bodies are limited to a single expression, whose value is implicitly returned.\n\nFirst option:\n\n- Type: string\n- Enum: \"always\", \"as-needed\", \"never\"\n- Default: \"as-needed\"\n\nPossible values:\n\n- never enforces no braces around the function body (constrains arrow functions to the role of returning an expression)\n- always enforces braces around the function body\n- as-needed enforces no braces where they can be omitted (default)\n\nSecond option:\n\n- Type: object\n- Properties:\n  - requireReturnForObjectLiteral: boolean (default: false) - requires braces and an explicit return for object literals.\n\nNote: This option only applies when the first option is \"as-needed\".\n\nExample configuration:\n\nExamples of incorrect code for this rule with the never option:\n\nExamples of correct code for this rule with the never option:\n\nExamples of incorrect code for this rule with the always option:\n\nExamples of correct code for this rule with the always option:\n\nExamples of incorrect code for this rule with the as-needed option:\n\nExamples of correct code for this rule with the as-needed option:\n\nExamples of incorrect code for this rule with the { \"requireReturnForObjectLiteral\": true } option:\n\nExamples of correct code for this rule with the { \"requireReturnForObjectLiteral\": true } option:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "block-scoped-var": "Enforces that variables are both declared and used within the same block scope.\nThis rule prevents accidental use of variables outside their intended block, mimicking C-style block scoping in JavaScript.\n\nJavaScript’s var declarations are hoisted to the top of their enclosing function, which can cause variables declared in a block (e.g., inside an if or for) to be accessible outside of it.\nThis can lead to hard-to-find bugs.\nBy enforcing block scoping, this rule helps avoid hoisting issues and aligns more closely with how other languages treat block variables.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "capitalized-comments": "Enforces or disallows capitalization of the first letter of a comment.\n\nInconsistent capitalization of comments can make code harder to read.\nThis rule helps enforce a consistent style across the codebase.\n\nExamples of incorrect code for this rule with the default \"always\" option:\n\nExamples of correct code for this rule with the default \"always\" option:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: object\n\ntype: boolean\n\ntype: boolean\n\ntype: string\n\ntype: boolean\n\ntype: boolean\n\ntype: string\n\ntype: object\n\ntype: boolean\n\ntype: boolean\n\ntype: string\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "class-methods-use-this": "Enforce that class methods utilize this.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: true\n\nEnforce this rule for class fields that are functions.\n\ntype: array\n\ndefault: []\n\nList of method names to exempt from this rule.\n\ntype: object\n\ntype: string\n\ntype: boolean\n\ntype: \"all\" | \"public-fields\"\n\ndefault: null\n\nWhether to ignore classes that implement interfaces.\n\ntype: boolean\n\ndefault: false\n\nWhether to ignore methods that are overridden.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "complexity": "Enforces a maximum cyclomatic complexity in a program, which is the number\nof linearly independent paths in a program.\n\nHaving high code complexity reduces code readability. This rule\naims to make the code easier to follow by reducing the number of branches\nin the program.\n\nExamples of incorrect code for this rule with { \"max\": 2 }\n\nExamples of correct code for this rule with { \"max\": 2 }\n\nThis rule accepts a configuration object with the following properties:\n\ntype: integer\n\ndefault: 20\n\nMaximum amount of cyclomatic complexity\n\ntype: \"classic\" | \"modified\"\n\ndefault: \"classic\"\n\nThe cyclomatic complexity variant to use\n\nClassic means McCabe cyclomatic complexity\n\nModified means classic cyclomatic complexity but a switch statement increases\ncomplexity by 1 irrespective of the number of case statements\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "constructor-super": "Requires super() calls in constructors of derived classes and disallows super() calls\nin constructors of non-derived classes.\n\nThis rule can be disabled for TypeScript code, as the TypeScript compiler\nenforces this check.\n\nIn JavaScript, calling super() in the constructor of a derived class (a class that extends\nanother class) is required. Failing to do so will result in a ReferenceError at runtime.\nConversely, calling super() in a non-derived class is a syntax error.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "curly": "This rule enforces the use of curly braces {} for all control statements\n(if, else, for, while, do, with).\nIt ensures that all blocks are enclosed in curly braces to improve code clarity and maintainability.\n\nOmitting curly braces can reduce code readability and increase the likelihood of errors, especially in deeply nested or indented code.\nIt can also lead to bugs if additional statements are added later without properly enclosing them in braces.\nUsing curly braces consistently makes the code safer and easier to modify.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nExamples of incorrect code for this rule with the \"multi\" option:\n\nExamples of correct code for this rule with the \"multi\" option:\n\nExamples of incorrect code for this rule with the \"multi-line\" option:\n\nExamples of correct code for this rule with the \"multi-line\" option:\n\nExamples of incorrect code for this rule with the \"multi-or-nest\" option:\n\nExamples of correct code for this rule with the \"multi-or-nest\" option:\n\nWhen enabled, consistent: true enforces consistent use of braces within an if-else chain.\nIf one branch of the chain uses braces, then all branches must use braces, even if not strictly required by the first option.\n\nExamples of incorrect code with \"multi\" and consistent: true:\n\nExamples of correct code with \"multi\" and consistent: true:\n\nExamples of incorrect code with \"multi-line\" and consistent: true:\n\nExamples of correct code with \"multi-line\" and consistent: true:\n\nExamples of incorrect code with \"multi-or-nest\" and consistent: true:\n\nExamples of correct code with \"multi-or-nest\" and consistent: true:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhether to enforce consistent use of curly braces in if-else chains.\n\ntype: \"all\" | \"multi\" | \"multi-line\" | \"multi-or-nest\"\n\ndefault: \"all\"\n\nWhich type of curly brace enforcement to use.\n\n- \"all\": require braces in all cases\n- \"multi\": require braces only for multi-statement blocks\n- \"multi-line\": require braces only for multi-line blocks\n- \"multi-or-nest\": require braces for multi-line blocks or when nested\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "default-case-last": "Requires the default clause in switch statements to be the last one.\n\nBy convention and for readability, the default clause should be the last one in a switch.\nWhile it is legal to place it before or between case clauses, doing so is confusing and may\nlead to unexpected \"fall-through\" behavior.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "default-case": "Enforces that all switch statements include a default case,\nunless explicitly marked with a configured comment.\n\nWithout a default case, it is unclear whether the omission was\nintentional or an oversight. Adding a default or a special comment\nmakes the code more explicit and reduces mistakes.\n\nYou may optionally include a // no default after the last case if there is\nno default case. The comment may be in any desired case, such as // No Default.\n\nExample configuration:\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string\n\nA regex pattern used to detect comments that mark the absence\nof a default case as intentional.\n\nDefault value: no default.\n\nExamples of incorrect code for this rule with the { \"commentPattern\": \"^skip\\\\sdefault\" } option:\n\nExamples of correct code for this rule with the { \"commentPattern\": \"^skip\\\\sdefault\" } option:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "default-param-last": "Requires default parameters in functions to be the last ones.\n\nPlacing default parameters last allows function calls to omit optional trailing arguments,\nwhich improves readability and consistency. This rule applies equally to JavaScript and\nTypeScript functions.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nExamples of incorrect TypeScript code for this rule:\n\nExamples of correct TypeScript code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "eqeqeq": "Requires the use of the === and !== operators, disallowing the use of == and !=.\n\nUsing non-strict equality operators leads to unexpected behavior due to type coercion, which can cause hard-to-find bugs.\n\nFirst option:\n\n- Type: string\n- Default: \"always\"\n\nPossible values:\n\n- \"always\" - always require ===/!==\n- \"smart\" - allow safe comparisons (typeof, literals, nullish)\n\nSecond option (only used with \"always\"):\n\n- Type: object\n- Properties:\n  - null: string (default: \"always\") - \"ignore\" allows == null and != null.\n\nPossible values for null:\n\n- \"always\" - always require === null/!== null\n- \"never\" - always require == null/!= null\n- \"ignore\" - allow both == null/!= null and === null/!== null\n\nExample JSON configuration:\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nExamples of incorrect code for this rule with the \"smart\" option:\n\nExamples of correct code for this rule with the \"smart\" option:\n\nExamples of incorrect code for this rule with the { \"null\": \"ignore\" } option:\n\nExamples of correct code for this rule with the { \"null\": \"ignore\" } option:\n\nExamples of incorrect code for this rule with the { \"null\": \"always\" } option:\n\nExamples of correct code for this rule with the { \"null\": \"always\" } option:\n\nExamples of incorrect code for this rule with the { \"null\": \"never\" } option:\n\nExamples of correct code for this rule with the { \"null\": \"never\" } option:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: \"always\" | \"smart\"\n\ntype: \"always\" | \"never\" | \"ignore\"\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "for-direction": "Disallow for loops where the update clause moves the counter in the wrong\ndirection, preventing the loop from reaching its stop condition.\n\nA for loop with a stop condition that can never be reached will run\ninfinitely. While infinite loops can be intentional, they are usually written\nas while loops. More often, an infinite for loop is a bug.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "func-names": "Require or disallow named function expressions.\n\nLeaving the name off a function will cause <anonymous> to appear in\nstack traces of errors thrown in it or any function called within it.\nThis makes it more difficult to find where an error is thrown.\nProviding an explicit name also improves readability and consistency.\n\nFirst option:\n\n- Type: string\n- Default: \"always\"\n- Possible values:\n  - \"always\" - requires all function expressions to have a name.\n  - \"as-needed\" - requires a name only if one is not automatically inferred.\n  - \"never\" - disallows names for function expressions.\n\nSecond option:\n\n- Type: object\n- Properties:\n  - generators: (\"always\" | \"as-needed\" | \"never\") (default: falls back to first option)\n    - \"always\" - require named generator function expressions.\n    - \"as-needed\" - require a name only when not inferred.\n    - \"never\" - disallow names for generator function expressions.\n\nExample configuration:\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nExamples of incorrect code for this rule with the \"as-needed\" option:\n\nExamples of correct code for this rule with the \"as-needed\" option:\n\nExamples of incorrect code for this rule with the \"never\" option:\n\nExamples of correct code for this rule with the \"never\" option:\n\nExamples of incorrect code for this rule with the \"always\", { \"generators\": \"as-needed\" } options:\n\nExamples of correct code for this rule with the \"always\", { \"generators\": \"as-needed\" } options:\n\nExamples of incorrect code for this rule with the \"always\", { \"generators\": \"never\" } options:\n\nExamples of correct code for this rule with the \"always\", { \"generators\": \"never\" } options:\n\nExamples of incorrect code for this rule with the \"as-needed\", { \"generators\": \"never\" } options:\n\nExamples of correct code for this rule with the \"as-needed\", { \"generators\": \"never\" } options:\n\nExamples of incorrect code for this rule with the \"never\", { \"generators\": \"always\" } options:\n\nExamples of correct code for this rule with the \"never\", { \"generators\": \"always\" } options:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "func-style": "Enforce the consistent use of either function declarations or expressions assigned to variables.\n\nThis rule enforces a particular type of function style, either function declarations or expressions assigned to variables.\nYou can specify which you prefer in the configuration.\n\nExamples of incorrect code for this rule with the default \"expression\" option:\n\nExamples of incorrect code for this rule with the \"declaration\" option:\n\nExamples of incorrect code for this rule with the \"declaration\" and {\"overrides\": { \"namedExports\": \"expression\" }} option:\n\nExamples of incorrect code for this rule with the \"expression\" and {\"overrides\": { \"namedExports\": \"declaration\" }} option:\n\nExamples of correct code for this rule with the default \"expression\" option:\n\nExamples of correct code for this rule with the \"declaration\" option:\n\nExamples of additional correct code for this rule with the \"declaration\", { \"allowArrowFunctions\": true } options:\n\nExamples of correct code for this rule with the \"declaration\" and {\"overrides\": { \"namedExports\": \"expression\" }} option:\n\nExamples of correct code for this rule with the \"expression\" and {\"overrides\": { \"namedExports\": \"declaration\" }} option:\n\nExamples of correct code for this rule with the {\"overrides\": { \"namedExports\": \"ignore\" }} option:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhen true, arrow functions are allowed regardless of the style setting.\n\ntype: boolean\n\ndefault: false\n\nWhen true, functions with type annotations are allowed regardless of the style setting.\n\ntype: \"ignore\" | \"expression\" | \"declaration\"\n\ndefault: null\n\nOverride the style specifically for named exports. Can be \"expression\", \"declaration\", or \"ignore\" (default).\n\ntype: \"expression\" | \"declaration\"\n\ndefault: \"expression\"\n\nThe style to enforce. Either \"expression\" (default) or \"declaration\".\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "getter-return": "Requires all getters to have a return statement.\n\nGetters should always return a value. If they don't, it's probably a mistake.\n\nThis rule does not run on TypeScript files, since type checking will\ncatch getters that do not return a value.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhen set to true, allows getters to implicitly return undefined with a return statement containing no expression.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "grouped-accessor-pairs": "Require grouped accessor pairs in object literals and classes\n\nWhile it is allowed to define the pair for a getter or a setter anywhere in an object or class definition,\nit’s considered a best practice to group accessor functions for the same property.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nExamples of incorrect code for this rule with the getBeforeSet option:\n\nExamples of correct code for this rule with the getBeforeSet option:\n\nExamples of incorrect code for this rule with the setBeforeGet option:\n\nExamples of correct code for this rule with the setBeforeGet option:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhen enforceForTSTypes is enabled, this rule also applies to TypeScript interfaces and type aliases:\n\nExamples of incorrect TypeScript code:\n\nExamples of correct TypeScript code:\n\ntype: \"anyOrder\" | \"getBeforeSet\" | \"setBeforeGet\"\n\ndefault: \"anyOrder\"\n\nA string value to control the order of the getter/setter pairs:\n\n- \"anyOrder\": Accessors can be in any order\n- \"getBeforeSet\": Getters must come before setters\n- \"setBeforeGet\": Setters must come before getters\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "guard-for-in": "Require for-in loops to include an if statement.\n\nLooping over objects with a for in loop will include properties that are inherited through\nthe prototype chain. Using a for in loop without filtering the results in the loop can\nlead to unexpected items in your for loop which can then lead to unexpected behaviour.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "id-length": "This rule enforces a minimum and/or maximum identifier length convention by counting the\ngraphemes for a given identifier.\n\nVery short identifier names like e, x, \\t or very long ones like\nhashGeneratorResultOutputContainerObject can make code harder to read and potentially less\nmaintainable. To prevent this, one may enforce a minimum and/or maximum identifier length.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\nAn array of regex patterns for identifiers to exclude from the rule.\nFor example, [\"^x.\"] would exclude all identifiers starting with \"x\".\n\ntype: string[]\n\ndefault: []\n\nAn array of identifier names that are excluded from the rule.\nFor example, [\"x\", \"y\", \"z\"] would allow single-letter identifiers \"x\", \"y\", and \"z\".\n\ntype: integer\n\ndefault: 18446744073709551615\n\nThe maximum number of graphemes allowed in an identifier.\nDefaults to no maximum (effectively unlimited).\n\ntype: integer\n\ndefault: 2\n\nThe minimum number of graphemes required in an identifier.\n\ntype: \"always\" | \"never\"\n\ndefault: \"always\"\n\nWhen set to \"never\", property names are not checked for length.\nWhen set to \"always\" (default), property names are checked just like other identifiers.\n\nTo enable** this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>",
    "init-declarations": "Require or disallow initialization in variable declarations\n\nIn JavaScript, variables can be assigned during declaration, or at any point afterwards using an assignment statement.\nFor example, in the following code, foo is initialized during declaration, while bar is initialized later.\n\nExamples of incorrect code for the default \"always\" option:\n\nExamples of incorrect code for the \"never\" option:\n\nExamples of correct code for the default \"always\" option:\n\nExamples of correct code for the \"never\" option:\n\nExamples of correct code for the \"never\", { \"ignoreForLoopInit\": true } options:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhen set to true, allows uninitialized variables in the init expression of for, for-in, and for-of loops.\nOnly applies when mode is set to \"never\".\n\ntype: \"always\" | \"never\"\n\nWhen set to \"always\" (default), requires that variables be initialized on declaration.\nWhen set to \"never\", disallows initialization during declaration.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "max-classes-per-file": "Enforce a maximum number of classes per file\n\nFiles containing multiple classes can often result in a less navigable and poorly\nstructured codebase. Best practice is to keep each file limited to a single responsibility.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhether to ignore class expressions when counting classes.\n\ntype: integer\n\ndefault: 1\n\nThe maximum number of classes allowed per file.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "max-depth": "Enforce a maximum depth that blocks can be nested. This rule helps to limit the complexity\nof nested blocks, improving readability and maintainability by ensuring that code does not\nbecome too deeply nested.\n\nMany developers consider code difficult to read if blocks are nested beyond a certain depth.\nExcessive nesting can make it harder to follow the flow of the code, increasing cognitive load\nand making maintenance more error-prone. By enforcing a maximum block depth, this rule encourages\ncleaner, more readable code.\n\nExamples of incorrect code for this rule with the default { \"max\": 3 } option:\n\nExamples of correct code for this rule with the default { \"max\": 3 } option:\n\nNote that class static blocks do not count as nested blocks, and that the depth in\nthem is calculated separately from the enclosing context.\n\nExample:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: integer\n\ndefault: 4\n\nThe max enforces a maximum depth that blocks can be nested\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "max-lines-per-function": "Enforce a maximum number of lines of code in a function. This rule ensures\nthat functions do not exceed a specified line count, promoting smaller,\nmore focused functions that are easier to maintain and understand.\n\nSome people consider large functions a code smell. Large functions tend to\ndo a lot of things and can make it hard to follow what’s going on. Many coding\nstyle guides dictate a limit to the number of lines that a function can\ncomprise of. This rule can help enforce that style.\n\nExamples of incorrect code for this rule with a particular max value:\n\nExamples of correct code for this rule with a particular max value:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nThe IIFEs option controls whether IIFEs are included in the line count.\nBy default, IIFEs are not considered, but when set to true, they will\nbe included in the line count for the function.\n\ntype: integer\n\ndefault: 50\n\nMaximum number of lines allowed in a function.\n\ntype: boolean\n\ndefault: false\n\nSkip lines made up purely of whitespace.\n\ntype: boolean\n\ndefault: false\n\nSkip lines containing just comments.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "max-lines": "Enforce a maximum number of lines per file.\n\nSome people consider large files a code smell. Large files tend to do a\nlot of things and can make it hard following what’s going. While there\nis not an objective maximum number of lines considered acceptable in a\nfile, most people would agree it should not be in the thousands.\nRecommendations usually range from 100 to 500 lines.\n\nThis rule accepts a configuration object with the following properties:\n\ntype: integer\n\ndefault: 300\n\nMaximum number of lines allowed per file.\n\ntype: boolean\n\ndefault: false\n\nWhether to ignore blank lines when counting.\n\ntype: boolean\n\ndefault: false\n\nWhether to ignore comments when counting.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "max-nested-callbacks": "Enforce a maximum depth that callbacks can be nested. This rule helps to limit\nthe complexity of callback nesting, ensuring that callbacks do not become too\ndeeply nested, improving code readability and maintainability.\n\nMany JavaScript libraries use the callback pattern to manage asynchronous\noperations. A program of any complexity will most likely need to manage several\nasynchronous operations at various levels of concurrency. A common pitfall is\nnesting callbacks excessively, making code harder to read and understand.\n\nExamples of incorrect code for this rule with the { \"max\": 3 } option:\n\nExamples of correct code for this rule with the { \"max\": 3 } option:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: integer\n\ndefault: 10\n\nThe max enforces a maximum depth that callbacks can be nested.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "max-params": "Enforce a maximum number of parameters in function definitions which by\ndefault is three.\n\nFunctions that take numerous parameters can be difficult to read and\nwrite because it requires the memorization of what each parameter is,\nits type, and the order they should appear in. As a result, many coders\nadhere to a convention that caps the number of parameters a function\ncan take.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nThis option is for counting the this parameter if it is of type void.\n\nFor example { \"countVoidThis\": true } would mean that having a function\ntake a this parameter of type void is counted towards the maximum number of parameters.\n\ntype: integer\n\ndefault: 3\n\nMaximum number of parameters allowed in function definitions.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "max-statements": "Enforce a maximum number of statements in a function. This rule ensures\nthat functions do not exceed a specified statements count, promoting smaller,\nmore focused functions that are easier to maintain and understand.\n\nSome people consider large functions a code smell. Large functions tend to\ndo a lot of things and can make it hard to follow what's going on.\nThis rule can help avoid large functions.\n\nExamples of incorrect code for this rule with the default { \"max\": 10 } option:\n\nExamples of correct code for this rule with the default { \"max\": 10 } option:\n\nNote that this rule does not apply to class static blocks, and that statements in\nclass static blocks do not count as statements in the enclosing function.\n\nExamples of correct code for this rule with { \"max\": 2 } option:\n\nExamples of additional correct code for this rule with the\n{ \"max\": 10 }, { \"ignoreTopLevelFunctions\": true } options:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhether to ignore top-level functions.\n\ntype: integer\n\ndefault: 10\n\nMaximum number of statements allowed per function.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "new-cap": "This rule requires constructor names to begin with a capital letter.\n\nThe new operator in JavaScript creates a new instance of a particular type of object.\nThat type of object is represented by a constructor function.\nSince constructor functions are just regular functions, the only defining characteristic\nis that new is being used as part of the call.\nNative JavaScript functions begin with an uppercase letter to distinguish those functions\nthat are to be used as constructors from functions that are not.\nMany style guides recommend following this pattern\nto more easily determine which functions are to be used as constructors.\n\nWarning:\nThe option newIsCapExceptionPattern and capIsNewExceptionPattern are implemented with\nthe rust regex syntax. Many JavaScript features\nare not supported (Lookahead, Lookbehinds, ...).\n\nExamples of incorrect code for this rule:\n\nExamples of incorrect code for this rule with the default { \"newIsCap\": true } option:\n\nExamples of correct code for this rule with the default { \"newIsCap\": true } option:\n\nExamples of correct code for this rule with the { \"newIsCap\": false } option:\n\nExamples of incorrect code for this rule with the default { \"capIsNew\": true } option:\n\nExamples of correct code for this rule with the default { \"capIsNew\": true } option:\n\nExamples of correct code for this rule with the { \"capIsNew\": false } option:\n\nExamples of additional correct code for this rule with the { \"newIsCapExceptions\": [\"events\"] } option:\n\nExamples of additional correct code for this rule with the { \"newIsCapExceptionPattern\": \"^person\\\\..\" } option:\n\nExamples of additional correct code for this rule with the { \"newIsCapExceptionPattern\": \"\\\\.bar$\" } option:\n\nExamples of additional correct code for this rule with the { \"capIsNewExceptions\": [\"Person\"] } option:\n\nExamples of additional correct code for this rule with the { \"capIsNewExceptionPattern\": \"^person\\\\..\" } option:\n\nExamples of additional correct code for this rule with the { \"capIsNewExceptionPattern\": \"\\\\.Bar$\" } option:\n\nExamples of additional correct code for this rule with the { \"capIsNewExceptionPattern\": \"^Foo\" } option:\n\nExamples of incorrect code for this rule with the default { \"properties\": true } option:\n\nExamples of correct code for this rule with the default { \"properties\": true } option:\n\nExamples of correct code for this rule with the { \"properties\": false } option:\n\nExamples of incorrect code for this rule with the default { \"newIsCap\": true } option:\n\nExamples of correct code for this rule with the default { \"newIsCap\": true } option:\n\nExamples of correct code for this rule with the { \"newIsCap\": false } option:\n\nExamples of incorrect code for this rule with the default { \"capIsNew\": true } option:\n\nExamples of correct code for this rule with the default { \"capIsNew\": true } option:\n\nExamples of correct code for this rule with the { \"capIsNew\": false } option:\n\nExamples of additional correct code for this rule with the { \"newIsCapExceptions\": [\"events\"] } option:\n\nExamples of additional correct code for this rule with the { \"newIsCapExceptionPattern\": \"^person\\\\..\" } option:\n\nExamples of additional correct code for this rule with the { \"newIsCapExceptionPattern\": \"\\\\.bar$\" } option:\n\nExamples of additional correct code for this rule with the { \"capIsNewExceptions\": [\"Person\"] } option:\n\n::: correct\n\nExamples of additional correct code for this rule with the { \"capIsNewExceptionPattern\": \"^person\\\\..\" } option:\n\nExamples of additional correct code for this rule with the { \"capIsNewExceptionPattern\": \"\\\\.Bar$\" } option:\n\nExamples of additional correct code for this rule with the { \"capIsNewExceptionPattern\": \"^Foo\" } option:\n\nExamples of incorrect code for this rule with the default { \"properties\": true } option:\n\nExamples of correct code for this rule with the default { \"properties\": true } option:\n\nExamples of correct code for this rule with the { \"properties\": false } option:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: true\n\ntrue to require that all functions with names starting with an uppercase letter to be called with new.\n\ntype: string\n\nA regex pattern to match exceptions for functions with names starting with an uppercase letter.\n\ntype: string[]\n\ndefault: []\n\nExceptions to ignore for functions with names starting with an uppercase letter.\n\ntype: boolean\n\ndefault: true\n\ntrue to require that all constructor names start with an uppercase letter, e.g. new Person().\n\ntype: string\n\nA regex pattern to match exceptions for constructor names starting with an uppercase letter.\n\ntype: string[]\n\ndefault: [\"Array\", \"Boolean\", \"Date\", \"Error\", \"Function\", \"Number\", \"Object\", \"RegExp\", \"String\", \"Symbol\", \"BigInt\"]\n\nExceptions to ignore for constructor names starting with an uppercase letter.\n\ntype: boolean\n\ndefault: true\n\ntrue to require capitalization for object properties (e.g., new obj.Method()).\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-alert": "Disallow the use of alert, confirm, and prompt\n\nJavaScript’s alert, confirm, and prompt functions are widely considered to be obtrusive as UI elements and should be replaced by a more appropriate custom UI implementation.\nFurthermore, alert is often used while debugging code, which should be removed before deployment to production.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-array-constructor": "Disallows creating arrays with the Array constructor.\n\nUse of the Array constructor to construct a new array is generally\ndiscouraged in favor of array literal notation because of the\nsingle-argument pitfall and because the Array global may be redefined.\nThe exception is when the Array constructor is used to intentionally\ncreate sparse arrays of a specified size by giving the constructor a\nsingle numeric argument.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-async-promise-executor": "Disallow using an async function as a Promise executor.\n\nThe new Promise constructor accepts an executor function as an argument,\nwhich has resolve and reject parameters that can be used to control the state of the\ncreated Promise. For example:\n\nThe executor function can also be an async function. However, this is usually a mistake, for a few reasons:\n\n- If an async executor function throws an error, the error will be lost and won’t cause\n  the newly-constructed Promise to reject.This could make it difficult to debug and handle some errors.\n- If a Promise executor function is using await, this is usually a sign that it is not\n  actually necessary to use the new Promise constructor, or the scope of the new\n  Promise constructor can be reduced.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-await-in-loop": "This rule disallows the use of await within loop bodies. (for, for-in, for-of, while, do-while).\n\nIt potentially indicates that the async operations are not being effectively parallelized.\nInstead, they are being run in series, which can lead to poorer performance.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-bitwise": "Disallow bitwise operators\n\nThe use of bitwise operators in JavaScript is very rare and often & or | is simply a mistyped && or ||,\nwhich will lead to unexpected behavior.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: []\n\nThe allow option permits the given list of bitwise operators to be used\nas exceptions to this rule.\n\nFor example { \"allow\": [\"~\"] } would allow the use of the bitwise operator\n~ without restriction. Such as in the following:\n\ntype: boolean\n\ndefault: false\n\nWhen set to true the int32Hint option allows the use of bitwise OR in |0\npattern for type casting.\n\nFor example with { \"int32Hint\": true } the following is permitted:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-caller": "Disallow the use of arguments.caller or arguments.callee.\n\nThe use of arguments.caller and arguments.callee make several code\noptimizations impossible. They have been deprecated in JavaScript, and\ntheir use is forbidden while in strict mode.\n\nThis rule is aimed at discouraging the use of deprecated and sub-optimal\ncode by disallowing the use of arguments.caller and arguments.callee. As\nsuch, it will warn when arguments.caller and arguments.callee are used.\n\nSee the MDN docs\nfor more information.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-case-declarations": "Disallow lexical declarations in case clauses.\n\nThe reason is that the lexical declaration is visible\nin the entire switch block but it only gets initialized when it is assigned,\nwhich will only happen if the case where it is defined is reached.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-class-assign": "Disallow reassigning class variables.\n\nThis rule can be disabled for TypeScript code, as the TypeScript compiler\nenforces this check.\n\nClassDeclaration creates a variable that can be re-assigned, but the re-assignment is a\nmistake in most cases.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-compare-neg-zero": "Disallow comparing against -0\n\nThe rule should warn against code that tries to compare against -0,\nsince that will not work as intended. That is, code like x === -0 will\npass for both +0 and -0. The author probably intended Object.is(x, -0).\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-cond-assign": "Disallow assignment operators in conditional expressions\n\nIn conditional statements, it is very easy to mistype a comparison\noperator (such as ==) as an assignment operator (such as =).\n\nThere are valid reasons to use assignment operators in conditional\nstatements. However, it can be difficult to tell whether a specific\nassignment was intentional.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts one of the following string values:\n\nAllow assignments in conditional expressions only if they are\nenclosed in parentheses.\n\nDisallow all assignments in conditional expressions.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-console": "Disallow the use of console.\n\nIn JavaScript that is designed to be executed in the browser, it’s considered a best\npractice to avoid using methods on console. Such messages are considered to be for\ndebugging purposes and therefore not suitable to ship to the client. In general, calls\nusing console should be stripped before being pushed to production.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: []\n\nThe allow option permits the given list of console methods to be used as exceptions to\nthis rule.\n\nSay the option was configured as { \"allow\": [\"info\"] } then the rule would behave as\nfollows:\n\nExample of incorrect code for this option:\n\nExample of correct code for this option:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-const-assign": "Disallow reassigning const variables.\n\nWe cannot modify variables that are declared using the const keyword,\nas it will raise a runtime error.\n\nNote that this rule is not necessary for TypeScript\ncode, as TypeScript will already catch this as an error.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-constant-binary-expression": "Disallow expressions where the operation doesn't affect the value\n\nComparisons which will always evaluate to true or false and logical expressions (||, &&, ??) which either always\nshort-circuit or never short-circuit are both likely indications of programmer error.\n\nThese errors are especially common in complex expressions where operator precedence is easy to misjudge.\n\nAdditionally, this rule detects comparisons to newly constructed objects/arrays/functions/etc.\nIn JavaScript, where objects are compared by reference, a newly constructed object can never === any other value.\nThis can be surprising for programmers coming from languages where objects are compared by value.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-constant-condition": "Disallow constant expressions in conditions\n\nA constant expression (for example, a literal) as a test condition might\nbe a typo or development trigger for a specific behavior.\n\nThis rule disallows constant expressions in the test condition of:\n\n- if, for, while, or do...while statement\n- ?: ternary expression\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: \"all\" | \"allExceptWhileTrue\" | \"none\"\n\ndefault: \"allExceptWhileTrue\"\n\nConfiguration option to specify whether to check for constant conditions in loops.\n\n- \"all\" or true disallows constant expressions in loops\n- \"allExceptWhileTrue\" disallows constant expressions in loops except while loops with expression true\n- \"none\" or false allows constant expressions in loops\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-constructor-return": "Disallow returning value from constructor\n\nIn JavaScript, returning a value in the constructor of a class may be a mistake.\nForbidding this pattern prevents mistakes resulting from unfamiliarity with the language or a copy-paste error.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-continue": "Disallow continue statements\n\nThe continue statement terminates execution of the statements in the current iteration of the current or labeled loop, and continues execution of the loop with the next iteration. When used incorrectly it makes code less testable, less readable and less maintainable. Structured control flow statements such as if should be used instead.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-control-regex": "Disallows control characters and some escape sequences that match\ncontrol characters in regular expressions.\n\nControl characters are special, invisible characters in the ASCII range\n0-31. These characters are rarely used in JavaScript strings so a\nregular expression containing elements that explicitly match these\ncharacters is most likely a mistake.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-debugger": "Checks for usage of the debugger statement\n\ndebugger statements do not affect functionality when a debugger isn't attached.\nThey're most commonly an accidental debugging leftover.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-delete-var": "The purpose of the delete operator is to remove a property from an\nobject.\n\nUsing the delete operator on a variable might lead to unexpected\nbehavior.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-div-regex": "Disallow equal signs explicitly at the beginning of regular expressions.\n\nCharacters /= at the beginning of a regular expression literal can be confused with a\ndivision assignment operator.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-dupe-class-members": "Disallow duplicate class members.\n\nThis rule can be disabled for TypeScript code, as the TypeScript compiler\nenforces this check.\n\nIf there are declarations of the same name in class members,\nthe last declaration overwrites other declarations silently. It can cause unexpected behaviors.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-dupe-else-if": "Disallow duplicate conditions in if-else-if chains\n\nif-else-if chains are commonly used when there is a need to execute only one branch (or at most one branch) out of several possible branches, based on certain conditions.\nTwo identical test conditions in the same chain are almost always a mistake in the code. Unless there are side effects in the expressions,\na duplicate will evaluate to the same true or false value as the identical expression earlier in the chain, meaning that its branch can never execute.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-dupe-keys": "Disallow duplicate keys in object literals.\n\nThis rule can be disabled for TypeScript code, as the TypeScript compiler\nenforces this check.\n\nMultiple properties with the same key in object literals can cause\nunexpected behavior in your application.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-duplicate-case": "Disallow duplicate case labels\n\nIf a switch statement has duplicate test expressions in case clauses,\nit is likely that a programmer copied a case clause but forgot to change the test expression.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-duplicate-imports": "Disallow duplicate module imports.\n\nUsing a single import statement per module will make the code clearer because you can see\neverything being imported from that module on one line.\n\nExamples of incorrect code for this rule:\n\nIn the following example the module import on line 1 is repeated on line 3. These can be\ncombined to make the list of imports more succinct.\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhen true, imports with only type specifiers (inline types or type imports) are\nconsidered separate from imports with value specifiers, so they can be imported from the\nsame module on separate import statements.\n\nExamples of correct code when allowSeparateTypeImports is set to true:\n\ntype: boolean\n\ndefault: false\n\nWhen true this rule will also look at exports to see if there is both a re-export of a\nmodule as in export ... from 'module' and also a standard import statement for the same\nmodule. This would count as a rule violation because there are in a sense two statements\nimporting from the same module.\n\nExamples of incorrect code when includeExports is set to true:\n\nExamples of correct code when includeExports is set to true:\n\nIf re-exporting from an imported module, you should add the imports to the\nimport statement, and export that directly, not use export ... from.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-else-return": "Disallow else blocks after return statements in if statements\n\nIf an if block contains a return statement, the else block becomes\nunnecessary. Its contents can be placed outside of the block.\n\nThis rule is aimed at highlighting an unnecessary block of code\nfollowing an if containing a return statement. As such, it will warn\nwhen it encounters an else following a chain of ifs, all of them\ncontaining a return statement.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: true\n\nWhether to allow else if blocks after a return statement.\n\nExamples of incorrect code for this rule with allowElseIf: false:\n\nExamples of correct code for this rule with allowElseIf: false:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-empty-character-class": "Disallow empty character classes in regular expressions\n\nBecause empty character classes in regular expressions do not match anything, they might be typing mistakes.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-empty-function": "Disallows the usages of empty functions\n\nEmpty functions can reduce readability because readers need to guess whether it's\nintentional or not. So writing a clear comment for empty functions is a good practice.\n\n{ type: string[], default: [] }\n\nYou may pass a list of allowed function kinds, which will allow functions of\nthese kinds to be empty.\n\nExample:\n\nallow accepts the following values:\n\n- \"functions\"\n- \"arrowFunctions\"\n- \"generatorFunctions\"\n- \"methods\"\n- \"generatorMethods\"\n- \"getters\"\n- \"setters\"\n- \"constructors\"\n- \"privateConstructors\"\n- \"protectedConstructors\"\n- \"asyncFunctions\"\n- \"asyncMethods\"\n- \"decoratedFunctions\"\n- \"overrideMethods\"\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-empty-pattern": "Disallow empty destructuring patterns.\n\nWhen using destructuring, it’s possible to create a pattern that has no effect.\nThis happens when empty curly braces are used to the right of\nan embedded object destructuring pattern, such as:\n\nIn this code, no new variables are created because a is just a location helper\nwhile the {} is expected to contain the variables to create, such as:\n\nIn many cases, the empty object pattern is a mistake\nwhere the author intended to use a default value instead, such as:\n\nThe difference between these two patterns is subtle,\nespecially because the problematic empty pattern looks just like an object literal.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-empty-static-block": "Disallows the usages of empty static blocks\n\nEmpty block statements, while not technically errors, usually occur due\nto refactoring that wasn’t completed. They can cause confusion when\nreading code.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-empty": "Disallows empty block statements\n\nEmpty block statements, while not technically errors, usually occur due to refactoring that wasn’t completed.\nThey can cause confusion when reading code.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nIf set to true, allows an empty catch block without triggering the linter.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-eq-null": "Disallow null comparisons without type-checking operators.\n\nComparing to null without a type-checking operator (== or !=), can\nhave unintended results as the comparison will evaluate to true when\ncomparing to not just a null, but also an undefined value.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-eval": "Disallows referencing the eval function. This rule is aimed at preventing\npotentially dangerous, unnecessary, and slow code by disallowing the use of\nthe eval() function.\n\nJavaScript’s eval() function is potentially dangerous and is often misused.\nUsing eval() on untrusted code can open a program up to several different\ninjection attacks. The use of eval() in most contexts can be substituted for\na better, safer alternative approach to solving the problem, such as using\nJSON.parse() or Function constructors in safer ways.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: true\n\nThis allowIndirect option allows indirect eval() calls.\n\nIndirect calls to eval(e.g., window['eval']) are less dangerous\nthan direct calls because they cannot dynamically change the scope.\nIndirect eval() calls also typically have less impact on performance\ncompared to direct calls, as they do not invoke JavaScript's scope chain.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-ex-assign": "Disallow reassigning exceptions in catch clauses\n\nIf a catch clause in a try statement accidentally\n(or purposely) assigns another value to the exception parameter,\nit is impossible to refer to the error from that point on.\nSince there is no arguments object to offer alternative access to this data,\nassignment of the parameter is absolutely destructive.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-extend-native": "Prevents extending native global objects such as Object, String, or Array with new\nproperties.\n\nExtending native objects can cause unexpected behavior and conflicts with other code.\n\nFor example:\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: []\n\nA list of objects which are allowed to be exceptions to the rule.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-extra-bind": "Disallow unnecessary calls to .bind()\n\nThis rule is aimed at avoiding the unnecessary use of bind()\nand as such will warn whenever an immediately-invoked function expression (IIFE) is using bind()\nand doesn’t have an appropriate this value.\nThis rule won’t flag usage of bind() that includes function argument binding.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-extra-boolean-cast": "This rule disallows unnecessary boolean casts.\n\nIn contexts such as an if statement's test where the result of the expression will already be coerced to a Boolean,\ncasting to a Boolean via double negation (!!) or a Boolean call is unnecessary.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nwhen set to true, in addition to checking default contexts, checks\nwhether extra boolean casts are present in expressions whose result is\nused in a boolean context. See examples below. Default is false,\nmeaning that this rule by default does not warn about extra booleans\ncast inside inner expressions.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-extra-label": "Disallow unnecessary labels.\n\nIf a loop contains no nested loops or switches, labeling the loop is unnecessary.\n\nYou can achieve the same result by removing the label and using break or continue without a label.\nProbably those labels would confuse developers because they expect labels to jump to further.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-fallthrough": "Disallow fallthrough of case statements\n\nThis rule is aimed at eliminating unintentional fallthrough of one case\nto the other. As such, it flags any fallthrough scenarios that are not\nmarked by a comment.\n\nThe switch statement in JavaScript is one of the more error-prone\nconstructs of the language thanks in part to the ability to “fall\nthrough” from one case to the next. For example:\n\nIn this example, if foo is 1, then execution will flow through both\ncases, as the first falls through to the second. You can prevent this by\nusing break, as in this example:\n\nThat works fine when you don’t want a fallthrough, but what if the\nfallthrough is intentional, there is no way to indicate that in the\nlanguage. It’s considered a best practice to always indicate when a\nfallthrough is intentional using a comment which matches the\n/falls?\\s?through/i regular expression but isn’t a directive:\n\nIn this example, there is no confusion as to the expected behavior. It\nis clear that the first case is meant to fall through to the second\ncase.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nNote that the last case statement in these examples does not cause a\nwarning because there is nothing to fall through into.\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhether to allow empty case clauses to fall through.\n\ntype: string\n\nCustom regex pattern to match fallthrough comments.\n\ntype: boolean\n\ndefault: false`\n\nWhether to report unused fallthrough comments.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-func-assign": "Disallow reassigning function declarations.\n\nThis rule can be disabled for TypeScript code, as the TypeScript compiler\nenforces this check.\n\nOverwriting/reassigning a function written as a FunctionDeclaration is often indicative of\na mistake or issue.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-global-assign": "Disallow modifications to read-only global variables.\n\nIn almost all cases, you don't want to assign a value to these global variables as doing so could result in losing access to important functionality.\n\nExamples of incorrect code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: []\n\nList of global variable names to exclude from this rule.\nGlobals listed here can be assigned to without triggering warnings.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-implicit-coercion": "Disallows shorthand type conversions using operators like !!, +, \"\"+ , etc.\n\nImplicit type coercions using operators can be less clear than using explicit\ntype conversion functions like Boolean(), Number(), and String().\nUsing explicit conversions makes the intent clearer and the code more readable.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\nList of operators to allow. Valid values: \"!!\", \"~\", \"+\", \"-\", \"- -\", \"\"\n\ntype: boolean\n\ndefault: true\n\nWhen true, warns on implicit boolean coercion (e.g., !!foo).\n\ntype: boolean\n\ndefault: false\n\nWhen true, disallows using template literals for string coercion (e.g., ` ${foo} ).\n\ntype: boolean\n\ndefault: true\n\nWhen true, warns on implicit number coercion (e.g., +foo).\n\ntype: boolean\n\ndefault: true\n\nWhen true, warns on implicit string coercion (e.g., \"\" + foo`).\n\nTo enable** this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-import-assign": "Disallow assigning to imported bindings.\n\nThe updates of imported bindings by ES Modules cause runtime errors.\n\nThe TypeScript compiler generally enforces this check already. Although\nit should be noted that there are some cases TypeScript does not catch, such\nas assignments via Object.assign. So this rule is still useful for\nTypeScript code in those cases.\n\nExamples of incorrect code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-inline-comments": "Disallows comments on the same line as code.\n\nComments placed at the end of a line of code can make code harder to read.\nThey can easily be missed when scanning vertically, and they make lines longer.\nMoving comments to their own lines makes them more prominent and reduces line length.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string\n\nA regex pattern to ignore certain inline comments.\n\nComments matching this pattern will not be reported.\n\nExample configuration:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-inner-declarations": "Disallow variable or function declarations in nested blocks\n\nA variable declaration is permitted anywhere a statement can go, even nested deeply inside other blocks.\nThis is often undesirable due to variable hoisting, and moving declarations to the root of the program or function body can increase clarity.\nNote that block bindings (let, const) are not hoisted and therefore they are not affected by this rule.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: \"allow\" | \"disallow\"\n\ndefault: null\n\nControls whether function declarations in nested blocks are allowed in strict mode (ES6+ behavior).\n\nAllow function declarations in nested blocks in strict mode (ES6+ behavior).\n\nDisallow function declarations in nested blocks regardless of strict mode.\n\ntype: \"functions\" | \"both\"\n\ndefault: \"functions\"\n\nDetermines what type of declarations to check.\n\nDisallows function declarations in nested blocks.\n\nDisallows function and var declarations in nested blocks.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-invalid-regexp": "Disallow invalid regular expression strings in RegExp constructors.\n\nAn invalid pattern in a regular expression literal is a SyntaxError when the code is parsed,\nbut an invalid string in RegExp constructors throws a SyntaxError only when the code is executed.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: []\n\nCase-sensitive array of flags that will be allowed.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-irregular-whitespace": "Disallows the use of irregular whitespace characters in the code.\n\nIrregular whitespace characters are invisible to most editors and can\ncause unexpected behavior, making code harder to debug and maintain.\nThey can also cause issues with code formatting and parsing.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-iterator": "Disallow the use of the iterator property\n\nThe iterator property was a SpiderMonkey extension to JavaScript\nthat could be used to create custom iterators that are compatible with\nJavaScript’s for in and for each constructs. However, this property is\nnow obsolete, so it should not be used. Here’s an example of how this\nused to work:\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-label-var": "Disallow labels that share a name with a variable.\n\nThis rule aims to create clearer code by disallowing the bad practice of creating a label\nthat shares a name with a variable that is in scope.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-labels": "Disallow labeled statements.\n\nLabeled statements in JavaScript are used in conjunction with break and continue to control flow around multiple loops. For example:\n\nThe break outer statement ensures that this code will not result in an infinite loop because control is returned to the next statement after the outer label was applied. If this statement was changed to be just break, control would flow back to the outer while statement and an infinite loop would result.\nWhile convenient in some cases, labels tend to be used only rarely and are frowned upon by some as a remedial form of flow control that is more error prone and harder to understand.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nIf set to true, this rule ignores labels which are sticking to loop statements.\nExamples of correct code with this option set to true:\n\ntype: boolean\n\ndefault: false\n\nIf set to true, this rule ignores labels which are sticking to switch statements.\nExamples of correct code with this option set to true:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-lone-blocks": "Disallows unnecessary standalone block statements.\n\nStandalone blocks can be confusing as they do not provide any meaningful purpose when used unnecessarily.\nThey may introduce extra nesting, reducing code readability, and can mislead readers about scope or intent.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-lonely-if": "Disallow if statements as the only statement in else blocks\n\nWhen an if statement is the only statement in an else block, it is often clearer to use\nan else if instead.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-loop-func": "Disallows function declarations and expressions inside loop statements\nwhen they reference variables declared in the outer scope that may change\nacross iterations.\n\nWriting functions within loops tends to result in errors due to the way\nclosures work in JavaScript. Functions capture variables by reference,\nnot by value. When using var, which is function-scoped, all iterations\nshare the same variable binding, leading to unexpected behavior.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-loss-of-precision": "Disallow precision loss of number literal.\n\nIt can lead to unexpected results in certain situations.\nFor example, when performing mathematical operations.\n\nIn JavaScript, Numbers are stored as double-precision floating-point numbers\naccording to the IEEE 754 standard. Because of this, numbers can only\nretain accuracy up to a certain amount of digits. If the programmer\nenters additional digits, those digits will be lost in the conversion\nto the Number type and will result in unexpected/incorrect behavior.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-magic-numbers": "This rule aims to make code more readable and refactoring easier by ensuring that special numbers are declared as constants to make their meaning explicit.\nThe current implementation does not support BigInt numbers inside array indexes.\n\n‘Magic numbers’ are numbers that occur multiple times in code without an explicit meaning. They should preferably be replaced by named constants.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule with option \"ignore\":\n\nExamples of correct code for this rule with option \"ignoreArrayIndexes\":\n\nExamples of correct code for this rule with option \"ignoreDefaultValues\":\n\nExamples of correct code for this rule with option \"ignoreClassFieldInitialValues\":\n\nExamples of incorrect code for this rule with option \"enforceConst\":\n\nExamples of incorrect code for this rule with option \"detectObjects\":\n\nExamples of correct code for this rule with option \"detectObjects\":\n\nExamples of correct code for this rule with option \"ignoreEnums\":\n\nExamples of correct code for this rule with option \"ignoreNumericLiteralTypes\":\n\nExamples of correct code for this rule with option \"ignoreReadonlyClassProperties\":\n\nExamples of correct code for this rule with option \"ignoreTypeIndexes\":\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhen true, numeric literals used in object properties are considered magic numbers.\n\ntype: boolean\n\ndefault: false\n\nWhen true, enforces that number constants must be declared using const instead of let or var.\n\ntype: array\n\ndefault: []\n\nAn array of numbers to ignore if used as magic numbers. Can include floats or BigInt strings.\n\ntype: boolean\n\ndefault: false\n\nWhen true, numeric literals used as array indexes are ignored.\n\ntype: boolean\n\ndefault: false\n\nWhen true, numeric literals used as initial values in class fields are ignored.\n\ntype: boolean\n\ndefault: false\n\nWhen true, numeric literals used as default values in function parameters and destructuring are ignored.\n\ntype: boolean\n\ndefault: false\n\nWhen true, numeric literals in TypeScript enums are ignored.\n\ntype: boolean\n\ndefault: false\n\nWhen true, numeric literals used as TypeScript numeric literal types are ignored.\n\ntype: boolean\n\ndefault: false\n\nWhen true, numeric literals in readonly class properties are ignored.\n\ntype: boolean\n\ndefault: false\n\nWhen true, numeric literals used to index TypeScript types are ignored.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-misleading-character-class": "This rule reports regular expressions which include multiple code point characters in character class syntax. This includes:\n\n- Characters with combining marks (e.g., Á where A is followed by a combining acute accent)\n- Characters with emoji modifiers (e.g., 👶🏻)\n- Pairs of regional indicator symbols (e.g., 🇯🇵)\n- Characters joined by zero-width joiner (ZWJ) (e.g., 👨‍👩‍👦)\n- Surrogate pairs without the Unicode flag (e.g., /^[👍]$/)\n\nUnicode includes characters which are made by multiple code points.\nRegExp character class syntax (/[abc]/) cannot handle characters\nwhich are made by multiple code points as a character;\nthose characters will be dissolved to each code point.\nFor example, ❇️ is made by ❇ (U+2747) and VARIATION SELECTOR-16 (U+FE0F).\nIf this character is in a RegExp character class,\nit will match either ❇ (U+2747) or VARIATION SELECTOR-16 (U+FE0F) rather than ❇️.\n\nThis can lead to regular expressions that do not match what the author intended,\nespecially for emoji, regional indicators, and characters with combining marks.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhen set to true, the rule allows any grouping of code points\ninside a character class as long as they are written using escape sequences.\n\nExamples of incorrect code for this rule with { \"allowEscape\": true }:\n\nExamples of correct code for this rule with { \"allowEscape\": true }:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-multi-assign": "Disallow use of chained assignment expressions.\n\nChaining the assignment of variables can lead to unexpected results and be difficult to read.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhen set to true, the rule allows chains that don't include initializing a variable in a declaration or initializing a class field.\n\nExamples of correct code for this option set to true:\n\nExamples of incorrect code for this option set to true:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-multi-str": "Disallow multiline strings.\n\nSome consider this to be a bad practice as it was an undocumented feature of JavaScript\nthat was only formalized later.\n\nExamples of incorrect code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-negated-condition": "Disallow negated conditions.\n\nNegated conditions are more difficult to understand. Code can be made more readable by inverting the condition.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-nested-ternary": "Disallows nested ternary expressions to improve code readability and maintainability.\n\nNested ternary expressions make code harder to read and understand. They can lead to complex, difficult-to-debug logic.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-new-func": "The rule disallow new operators with the Function object.\n\nUsing new Function or Function can lead to code that is difficult to understand and maintain. It can introduce security risks similar to those associated with eval because it generates a new function from a string of code, which can be a vector for injection attacks. Additionally, it impacts performance negatively as these functions are not optimized by the JavaScript engine.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-new-native-nonconstructor": "Disallow new operators with global non-constructor functions (Symbol, BigInt).\n\nThis rule can be disabled for TypeScript code, as the TypeScript compiler\nenforces this check.\n\nBoth new Symbol and new BigInt throw a type error because they are\nfunctions and not classes. It is easy to make this mistake by assuming\nthe uppercase letters indicate classes.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-new-wrappers": "Disallow new operators with the String, Number, and Boolean objects\n\nThe first problem is that primitive wrapper objects are, in fact,\nobjects. That means typeof will return \"object\" instead of \"string\",\n\"number\", or \"boolean\". The second problem comes with boolean\nobjects. Every object is truthy, that means an instance of Boolean\nalways resolves to true even when its actual value is false.\n\nhttps://eslint.org/docs/latest/rules/no-new-wrappers\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-new": "Disallow new operators outside of assignments or comparisons.\n\nCalling new without assigning or comparing it the reference is thrown away and in many\ncases the constructor can be replaced with a function.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-nonoctal-decimal-escape": "This rule disallows \\8 and \\9 escape sequences in string literals\n\nECMAScript specification treats \\8 and \\9 in string literals as a legacy feature\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-obj-calls": "Disallow calling some global objects as functions.\n\nThis rule can be disabled for TypeScript code, as the TypeScript compiler\nenforces this check.\n\nSome global objects are not intended to be called as functions.\nCalling them as functions will usually result in a TypeError being thrown.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-object-constructor": "Disallow calls to the Object constructor without an argument\n\nUse of the Object constructor to construct a new empty object is generally discouraged in favor of object literal notation because of conciseness and because the Object global may be redefined. The exception is when the Object constructor is used to intentionally wrap a specified value which is passed as an argument.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-param-reassign": "Disallow reassigning function parameters or, optionally, their properties.\n\nReassigning parameters can lead to unexpected behavior, especially when relying on the\noriginal arguments passed into the function. Mutating parameter properties can be similarly\nsurprising and harder to reason about.\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: []\n\nAn array of parameter names whose property modifications should be ignored.\n\ntype: string[]\n\nAn array of regex patterns (as strings) for parameter names whose property modifications should be ignored.\nNote that this uses Rust regex syntax and so may not have all features\navailable to JavaScript regexes.\n\ntype: boolean\n\ndefault: false\n\nWhen true, also check for modifications to properties of parameters.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-plusplus": "Disallow the unary operators ++ and --.\n\nBecause the unary ++ and -- operators are subject to automatic semicolon insertion, differences in whitespace\ncan change the semantics of source code. For example, these two code blocks are not equivalent:\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhether to allow ++ and -- in for loop afterthoughts.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-promise-executor-return": "Disallow returning values from Promise executor functions.\n\nThe new Promise constructor accepts an executor function as an argument,\nwhich has resolve and reject parameters that can be used to control the\nstate of the created Promise.\n\nThe return value of the executor is ignored. Returning a value from an executor\nfunction is a possible error because the returned value cannot be used and it\ndoesn't affect the promise in any way.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nIf true, allows returning void expressions (e.g., return void resolve()).\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-proto": "Disallow the use of the proto property.\n\nThe proto property has been deprecated as of ECMAScript 3.1 and\nshouldn’t be used in new code. Use Object.getPrototypeOf and\nObject.setPrototypeOf instead.\n\nFor more information, see\nthe MDN documentation.\n\nExamples of incorrect code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-prototype-builtins": "Disallow calling some Object.prototype methods directly on objects\n\nIn ECMAScript 5.1, Object.create was added, which enables the creation of objects with a specified [[Prototype]].\nObject.create(null) is a common pattern used to create objects that will be used as a Map.\nThis can lead to errors when it is assumed that objects will have properties from Object.prototype. This rule prevents calling some Object.prototype methods directly from an object.\nAdditionally, objects can have properties that shadow the builtins on Object.prototype, potentially causing unintended behavior or denial-of-service security vulnerabilities.\nFor example, it would be unsafe for a webserver to parse JSON input from a client and call hasOwnProperty directly on the resulting object, because a malicious client could send a JSON value like {\"hasOwnProperty\": 1} and cause the server to crash.\n\nTo avoid subtle bugs like this, it’s better to always call these methods from Object.prototype. For example, foo.hasOwnProperty(\"bar\") should be replaced with Object.prototype.hasOwnProperty.call(foo, \"bar\").\n\nExamples of incorrect code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-redeclare": "This rule disallows redeclaring variables within the same scope, ensuring that each variable\nis declared only once. It helps avoid confusion and unintended behavior in code.\n\nRedeclaring variables in the same scope can lead to unexpected behavior, overwriting existing values,\nand making the code harder to understand and maintain.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: true\n\nWhen set true, it flags redeclaring built-in globals (e.g., let Object = 1;).\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-regex-spaces": "Disallow 2+ consecutive spaces in regular expressions.\n\nIn a regular expression, it is hard to tell how many spaces are\nintended to be matched. It is better to use only one space and\nthen specify how many spaces are expected using a quantifier.\n\nExamples of incorrect code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-restricted-globals": "This rule allows you to specify global variable names that you don't want to use in your application.\n\nDisallowing usage of specific global variables can be useful if you want to allow a set of global\nvariables by enabling an environment, but still want to disallow some of those.\n\nFor instance, early Internet Explorer versions exposed the current DOM event as a global variable\nevent, but using this variable has been considered as a bad practice for a long time. Restricting\nthis will make sure this variable isn't used in browser code.\n\nIf we have options:\n\nThe following patterns are considered problems:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: Record<string, string>\n\ndefault: {}\n\nObjects in the format\n{ \"name\": \"event\", \"message\": \"Use local parameter instead.\" }, which define what globals\nare restricted from use.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-restricted-imports": "This rule allows you to specify imports that you don’t want to use in your application.\nIt applies to static imports only, not dynamic ones.\n\nSome imports might not make sense in a particular environment.\nFor example, Node.js’ fs module would not make sense in an environment that didn’t have a file system.\n\nSome modules provide similar or identical functionality, think lodash and underscore. Your project may have standardized on a module.\nYou want to make sure that the other alternatives are not being used as this would unnecessarily bloat the project\nand provide a higher maintenance cost of two dependencies when one would suffice.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nYou may also specify a custom message for a particular module using the name and message properties inside an object,\nwhere the value of the name is the name of the module and message property contains the custom message.\nThe custom message will be displayed as a help text for the user.\n\nExamples of incorrect code for this rule:\n\nThis is an object option whose value is an array containing the names of the modules you want to restrict.\n\nExamples of incorrect code for paths:\n\nCustom messages for a particular module can also be specified in paths array using objects with name and message.\n\nThis option in paths is an array and can be used to specify the names of certain bindings exported from a module.\nImport names specified inside paths array affect the module specified in the name property of corresponding object,\nso it is required to specify the name property first when you are using importNames or message option.\n\nSpecifying \"default\" string inside the importNames array will restrict the default export from being imported.\n\nExamples of incorrect code for this rule:\n\nThis option is an array. Inverse of importNames, allowImportNames allows the imports that are specified inside this array.\nSo it restricts all imports from a module, except specified allowed ones.\n\nNote: allowImportNames cannot be used in combination with importNames.\n\nExamples of incorrect code for this rule:\n\nWhether to allow type-only imports for a path. Default: false.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis is also an object option whose value is an array.\nThis option allows you to specify multiple modules to restrict using gitignore-style patterns or regular expressions.\n\nWhere paths option takes exact import paths, patterns option can be used to specify the import paths with more flexibility,\nallowing for the restriction of multiple modules within the same directory. For example:\n\nThis configuration restricts import of the import-foo module\nbut wouldn’t restrict the import of import-foo/bar or import-foo/baz. You can use patterns to restrict both:\n\nThis configuration restricts imports not just from import-foo using path,\nbut also import-foo/bar and import-foo/baz using patterns.\n\nYou can also use regular expressions to restrict modules (see the regex option).\n\nExamples of incorrect code for patterns option:\n\nExamples of correct code for patterns option:\n\nThe patterns array can also include objects. The group property is used to specify the gitignore-style patterns\nfor restricting modules and the message property is used to specify a custom message.\n\nEither of the group or regex properties is required when using the patterns option.\n\nExamples of incorrect code for group option:\n\nThe regex property is used to specify the regex patterns for restricting modules.\n\nNote: regex cannot be used in combination with group.\n\nWarning: This rule uses the Rust-Regex, which supports not all features of JS-Regex,\nlike Lookahead and Lookbehinds.\n\nExamples of incorrect code for regex option:\n\nThis is a boolean option and sets the patterns specified in the group property to be case-sensitive when true. Default is false.\n\nWarning: It will not apply case-sensitive checks to regex. regex uses Rust-RegEx which has its own implementation of case-sensitive.\n\nYou can also specify importNames within objects inside the patterns array.\nIn this case, the specified names apply only to the associated group or regex property.\n\nExamples of incorrect code for importNames in patterns:\n\nYou can also specify allowImportNames within objects inside the patterns array.\nIn this case, the specified names apply only to the associated group or regex property.\n\nNote: allowImportNames cannot be used in combination with importNames, importNamePattern or allowImportNamePattern.\n\nThis option allows you to use regex patterns to restrict import names.\n\nExamples of incorrect code for importNamePattern option:\n\nThis is a string option. Inverse of importNamePattern, this option allows imports that matches the specified regex pattern.\nSo it restricts all imports from a module, except specified allowed patterns.\n\nNote: allowImportNamePattern cannot be used in combination with importNames, importNamePattern or allowImportNames.\n\nExamples of incorrect code for allowImportNamePattern option:\n\nExamples of correct code for allowImportNamePattern option:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-return-assign": "Disallows assignment operators in return statements.\n\nAssignment is allowed by js in return expressions, but usually, an expression with only one equal sign is intended to be a comparison.\nHowever, because of the missing equal sign, this turns to assignment, which is valid js code\nBecause of this ambiguity, it’s considered a best practice to not use assignment in return statements.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts one of the following string values:\n\nDisallow all assignments in return statements.\n\nAllow assignments in return statements only if they are enclosed in parentheses.\nThis is the default mode.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-script-url": "Disallow javascript: urls\n\nUsing javascript: URLs is considered by some as a form of eval. Code\npassed in javascript: URLs must be parsed and evaluated by the browser\nin the same way that eval is processed. This can lead to security and\nperformance issues.\n\nExamples of incorrect code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-self-assign": "Disallow assignments where both sides are exactly the same.\n\nSelf assignments have no effect, so probably those are an error due to incomplete\nrefactoring. Those indicate that what you should do is still remaining.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: true\n\nThe props option when set to false, disables the checking of properties.\n\nWith props set to false the following are examples of correct code:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-self-compare": "Disallow comparisons where both sides are exactly the same\n\nComparing a variable against itself is usually an error, either a typo or refactoring error.\nIt is confusing to the reader and may potentially introduce a runtime error.\n\nExamples of incorrect code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-sequences": "Disallows the use of the comma operator.\n\nThe comma operator evaluates each of its operands (from left to right)\nand returns the value of the last operand. However, this frequently\nobscures side effects, and its use is often an accident.\n\n- allowInParentheses (default: true): If set to false, disallows\n  the comma operator even when wrapped in parentheses.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: true\n\nIf this option is set to false, this rule disallows the comma operator\neven when the expression sequence is explicitly wrapped in parentheses.\nDefault is true.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-setter-return": "Setters cannot return values.\n\nThis rule can be disabled for TypeScript code, as the TypeScript compiler\nenforces this check.\n\nWhile returning a value from a setter does not produce an error, the returned value is\nbeing ignored. Therefore, returning a value from a setter is either unnecessary or a\npossible error, since the returned value cannot be used.\n\nExamples of incorrect code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-shadow-restricted-names": "Disallows the redefining of global variables such as undefined, NaN, Infinity,\neval, and arguments.\n\nValue properties of the Global Object NaN, Infinity, undefined as well as the strict\nmode restricted identifiers eval and arguments are considered to be restricted names in\nJavaScript. Defining them to mean something else can have unintended consequences and\nconfuse others reading the code. For example, there’s nothing preventing you from\nwriting:\n\nThen any code used within the same scope would not get the global undefined, but rather the\nlocal version with a very different meaning.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nIf true, also report shadowing of globalThis.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-sparse-arrays": "Disallow sparse arrays.\n\nTake the following example:\n\nWhile the items array in this example has a length of 2, there are actually\nno values in items[0] or items[1]. The fact that the array literal is\nvalid with only commas inside, coupled with the length being set and\nactual item values not being set, make sparse arrays confusing for many\ndevelopers.\n\nThe confusion around sparse arrays is enough that it’s recommended to\navoid using them unless you are certain that they are useful in your\ncode.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\n// trailing comma (after the last element) is not a problem\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-template-curly-in-string": "Disallow template literal placeholder syntax in regular strings. This rule ensures that\nexpressions like ${variable} are only used within template literals, avoiding incorrect\nusage in regular strings.\n\nECMAScript 6 allows programmers to create strings containing variables or expressions using\ntemplate literals. This is done by embedding expressions like ${variable} between backticks.\nIf regular quotes (' or \") are used with template literal syntax, it results in the literal\nstring \"${variable}\" instead of evaluating the expression. This rule helps to avoid this mistake,\nensuring that expressions are correctly evaluated inside template literals.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-ternary": "Disallow ternary operators\n\nThe ternary operator is used to conditionally assign a value to a\nvariable. Some believe that the use of ternary operators leads to\nunclear code.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-this-before-super": "Requires calling super() before using this or super.\n\nThis rule can be disabled for TypeScript code, as the TypeScript compiler\nenforces this check.\n\nIn the constructor of derived classes, if this/super are used before super() calls,\nit raises a ReferenceError.\n\nExamples of incorrect code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-throw-literal": "Disallows throwing literals or non-Error objects as exceptions.\n\nIt is considered good practice to only throw the Error object itself or an object using\nthe Error object as base objects for user-defined exceptions. The fundamental benefit of\nError objects is that they automatically keep track of where they were built and originated.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-unassigned-vars": "Disallow let or var variables that are read but never assigned\n\nThis rule flags let or var declarations that are never assigned a value but are still read or used in the code.\nSince these variables will always be undefined, their usage is likely a programming mistake.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-undef": "Disallow the use of undeclared variables.\n\nThis rule can be disabled for TypeScript code, as the TypeScript compiler\nenforces this check.\n\nIt is most likely a potential ReferenceError caused by a misspelling\nof a variable or parameter name.\n\nExamples of incorrect code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhen set to true, warns on undefined variables used in a typeof expression.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-undefined": "Disallow the use of undefined as an identifier\n\nUsing undefined directly can lead to bugs, since it can be shadowed or overwritten in JavaScript.\nIt's safer and more intentional to use null or rely on implicit undefined (e.g., missing return) to avoid accidental issues.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-unexpected-multiline": "In most cases, semicolons are not required in JavaScript in order for code to be parsed\nand executed as expected. Typically this occurs because semicolons are automatically\ninserted based on a fixed set of rules. This rule exists to detect those cases where a semicolon\nis NOT inserted automatically, and may be parsed differently than expected.\n\nCode that has unexpected newlines may be parsed and executed differently than what the\ndeveloper intended. This can lead to bugs that are difficult to track down.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-unneeded-ternary": "Disallow ternary operators when simpler alternatives exist\n\nIt’s a common mistake in JavaScript to use a conditional expression to select between two\nBoolean values instead of using ! to convert the test to a Boolean.\n\nAnother common mistake is using a single variable as both the conditional test and the\nconsequent. In such cases, the logical OR can be used to provide the same functionality.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: true\n\nWhether to allow the default assignment pattern x ? x : y.\n\nWhen set to false, the rule also flags cases like x ? x : y and suggests using\nthe logical OR form x || y instead. When true (default), such default assignments\nare allowed and not reported.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-unreachable": "Disallow unreachable code after return, throw, continue, and break statements.\n\nThis rule can be disabled for TypeScript code if allowUnreachableCode: false is configured\nin the tsconfig.json, as the TypeScript compiler enforces this check.\n\nUnreachable code after a return, throw, continue, or break statement can never be run.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-unsafe-finally": "Disallow control flow statements in finally blocks.\n\nJavaScript suspends the control flow statements of try and catch\nblocks until the execution of a finally block finishes.\n\nSo, when return, throw, break, or continue is used in finally,\ncontrol flow statements inside try and catch are overwritten.\nThis is possibly unexpected behavior for the developer.\n\nExamples of incorrect code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-unsafe-negation": "Disallows negating the left operand of relational operators to prevent logical errors\ncaused by misunderstanding operator precedence or accidental use of negation.\n\nThis rule can be disabled for TypeScript code, as the TypeScript compiler\nenforces this check.\n\nNegating the left operand of relational operators can result in unexpected behavior due to\noperator precedence, leading to logical errors. For instance, !a in b may be interpreted\nas (!a) in b instead of !(a in b), which is not the intended logic.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nThe enforceForOrderingRelations option determines whether negation is allowed\non the left-hand side of ordering relational operators (<, >, <=, >=).\n\nThe purpose is to avoid expressions such as !a < b (which is equivalent to (a ? 0 : 1) < b)\nwhen what is really intended is !(a < b).\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-unsafe-optional-chaining": "Disallow use of optional chaining in contexts where the undefined value is not allowed\n\nThe optional chaining (?.) expression can short-circuit with a return value of undefined.\nTherefore, treating an evaluated optional chaining expression as a function, object, number, etc.,\ncan cause TypeError or unexpected results. For example:\n\nExamples of incorrect code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nDisallow arithmetic operations on optional chaining expressions.\nIf this is true, this rule warns arithmetic operations on optional chaining expressions, which possibly result in NaN.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-unused-expressions": "This rule disallows unused expressions.\n\nUnused expressions are usually a mistake. They can be a symptom of a bug or a misunderstanding of the code.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhen set to true, allows short circuit evaluations in expressions.\n\ntype: boolean\n\ndefault: false\n\nWhen set to true, allows tagged template literals in expressions.\n\ntype: boolean\n\ndefault: false\n\nWhen set to true, allows ternary operators in expressions.\n\ntype: boolean\n\ndefault: false\n\nWhen set to true, enforces the rule for unused JSX expressions also.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-unused-labels": "Disallow unused labels.\n\nLabels that are declared and not used anywhere in the code are most likely an error due to incomplete refactoring.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-unused-private-class-members": "Disallow unused private class members\n\nPrivate class members that are declared and not used anywhere in the code are most likely an error due to incomplete refactoring. Such class members take up space in the code and can lead to confusion by readers.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-unused-vars": "Disallows variable declarations, imports, or type declarations that are\nnot used in code.\n\nVariables that are declared and not used anywhere in the code are most\nlikely an error due to incomplete refactoring. Such variables take up\nspace in the code and can lead to confusion by readers.\n\nA variable foo is considered to be used if any of the following are\ntrue:\n\n- It is called (foo()) or constructed (new foo())\n- It is read (var bar = foo)\n- It is passed into a function or constructor as an argument (doSomething(foo))\n- It is read inside of a function that is passed to another function\n  (doSomething(function() { foo(); }))\n- It is exported (export const foo = 42)\n- It is used as an operand to TypeScript's typeof operator (const bar:\ntypeof foo = 4)\n\nA variable is not considered to be used if it is only ever declared\n(var foo = 5) or assigned to (foo = 7).\n\nThis rule has full support for TypeScript types, interfaces, enums, and\nnamespaces.\n\nA type or interface Foo is considered to be used if it is used in any\nof the following ways:\n\n- It is used in the definition of another type or interface.\n- It is used as a type annotation or as part of a function signature.\n- It is used in a cast or satisfies expression.\n\nA type or interface is not considered to be used if it is only ever\nused in its own definition, e.g. type Foo = Array<Foo>.\n\nEnums and namespaces are treated the same as variables, classes,\nfunctions, etc.\n\nThis rule ignores .d.ts files and .vue files entirely. Variables,\nclasses, interfaces, and types declared in .d.ts files are generally\nused by other files, which are not checked by Oxlint. Since Oxlint does\nnot support parsing Vue templates, this rule cannot tell if a variable\nis used or unused in a Vue file.\n\nThe original ESLint rule recognizes / exported variableName /\ncomments as a way to indicate that a variable is used in another script\nand should not be considered unused. Since ES modules are now a TC39\nstandard, Oxlint does not support this feature.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nExamples of incorrect code for / exported variableName / operation:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: \"after-used\" | \"all\" | \"none\"\n\ndefault: \"after-used\"\n\nControls how unused arguments are checked.\n\nUnused positional arguments that occur before the last used argument\nwill not be checked, but all named arguments and all positional\narguments after the last used argument will be checked.\n\nAll named arguments must be used\n\nDo not check arguments\n\nSpecifies exceptions to this rule for unused arguments. Arguments whose\nnames match this pattern will be ignored.\n\nBy default, this pattern is ^ unless options are configured with an\nobject. In this case it will default to [None]. Note that this\nbehavior deviates from both ESLint and TypeScript-ESLint, which never\nprovide a default pattern.\n\nExamples of correct code for this option when the pattern is ^:\n\ntype: \"all\" | \"none\"\n\nUsed for catch block validation.\n\nAll named arguments must be used.\n\nDo not check error objects.\n\nSpecifies exceptions to this rule for errors caught within a catch block.\nVariables declared within a catch block whose names match this pattern\nwill be ignored.\n\nExamples of correct code when the pattern is ^ignore:\n\nThis option specifies exceptions within destructuring patterns that will\nnot be checked for usage. Variables declared within array destructuring\nwhose names match this pattern will be ignored.\n\nBy default this pattern is unset.\n\nExamples of correct code for this option, when the pattern is ^:\n\ntype: boolean\n\ndefault: false\n\nThe ignoreClassWithStaticInitBlock option is a boolean. Static\ninitialization blocks allow you to initialize static variables and\nexecute code during the evaluation of a class definition, meaning\nthe static block code is executed without creating a new instance\nof the class. When set to true, this option ignores classes\ncontaining static initialization blocks.\n\nExamples of incorrect code for the { \"ignoreClassWithStaticInitBlock\": true } option\n\nExamples of correct code for the { \"ignoreClassWithStaticInitBlock\": true } option\n\ntype: boolean\n\ndefault: false\n\nUsing a Rest property it is possible to \"omit\" properties from an\nobject, but by default the sibling properties are marked as \"unused\".\nWith this option enabled the rest property's siblings are ignored.\n\nExamples of correct code when this option is set to true:\n\ntype: boolean\n\ndefault: false\n\nWhen set to true, the rule will ignore variables declared with\nusing or await using declarations, even if they are unused.\n\nThis is useful when working with resources that need to be disposed\nvia the explicit resource management proposal, where the primary\npurpose is the disposal side effect rather than using the resource.\n\nExamples of correct code for the { \"ignoreUsingDeclarations\": true } option:\n\ntype: boolean\n\ndefault: false\n\nThe reportUsedIgnorePattern option is a boolean.\nUsing this option will report variables that match any of the valid\nignore pattern options (varsIgnorePattern, argsIgnorePattern,\ncaughtErrorsIgnorePattern, or destructuredArrayIgnorePattern) if\nthey have been used.\n\nExamples of incorrect code for the { \"reportUsedIgnorePattern\": true } option:\n\nExamples of correct code for the { \"reportUsedIgnorePattern\": true } option:\n\ntype: boolean\n\ndefault: false\n\nThe reportVarsOnlyUsedAsTypes option is a boolean.\n\nIf true, the rule will also report variables that are only used as types.\n\nExamples of incorrect code for the { \"reportVarsOnlyUsedAsTypes\": true } option:\n\nExamples of correct code for the { \"reportVarsOnlyUsedAsTypes\": true } option:\n\nNote: even with { \"reportVarsOnlyUsedAsTypes\": false }, cases where the value is\nonly used a type within itself will still be reported:\n\ntype: \"all\" | \"local\"\n\ndefault: \"all\"\n\nControls how usage of a variable in the global scope is checked.\n\nAll variables are checked for usage, including those in the global scope.\n\nChecks only that locally-declared variables are used but will allow\nglobal variables to be unused.\n\nSpecifies exceptions to this rule for unused variables. Variables whose\nnames match this pattern will be ignored.\n\nBy default, this pattern is ^ unless options are configured with an\nobject. In this case it will default to [None]. Note that this\nbehavior deviates from both ESLint and TypeScript-ESLint, which never\nprovide a default pattern.\n\nExamples of correct code for this option when the pattern is ^:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-useless-backreference": "Disallows backreferences in regular expressions that will always be ignored\nbecause the capture group they refer to has not matched and cannot match\nat the time the backreference is evaluated.\n\nUseless backreferences can lead to confusing or misleading regular expressions.\nThey may give the impression that a group’s value is being reused, but due to\nthe structure of the pattern (e.g., order of evaluation, disjunctions, or negative\nlookarounds), the group has not matched anything — so the reference always\nresolves to an empty string. This is almost always a mistake and makes patterns\nharder to understand and maintain.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-useless-call": "Disallow unnecessary calls to .call() and .apply()\n\nFunction.prototype.call() and Function.prototype.apply() are slower than the normal function invocation.\n\nThis rule compares code statically to check whether or not thisArg is changed.\nSo if the code about thisArg is a dynamic expression, this rule cannot judge correctly.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-useless-catch": "Disallow unnecessary catch clauses\n\nA catch clause that only rethrows the original error is redundant,\nand has no effect on the runtime behavior of the program.\nThese redundant clauses can be a source of confusion and code bloat,\nso it’s better to disallow these unnecessary catch clauses.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-useless-computed-key": "Disallow unnecessary computed property keys in objects and classes\n\nIt’s unnecessary to use computed properties with literals such as:\n\nThe code can be rewritten as:\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nExamples of additional correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: true\n\nThe enforceForClassMembers option controls whether the rule applies to\nclass members (methods and properties).\n\nExamples of correct code for this rule with the { \"enforceForClassMembers\": false } option:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-useless-concat": "Disallow unnecessary concatenation of literals or template literals\n\nIt’s unnecessary to concatenate two strings together when they could\nbe combined into a single literal.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\n// when the string concatenation is multiline\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-useless-constructor": "Disallow constructors that can be safely removed without changing how the class works.\n\nES2015 provides a default class constructor if one is not specified. As\nsuch, it is unnecessary to provide an empty constructor or one that\nsimply delegates into its parent class.\n\n::: warning\nCaveat: This lint rule will report on constructors whose sole purpose\nis to change visibility of a parent constructor. This is because the rule\ndoes not have type information to determine if the parent constructor is\npublic, protected, or private.\n:::\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-useless-escape": "Disallow unnecessary escape characters.\n\nEscaping characters unnecessarily has no effect on the behavior of strings or regexes,\nand can make code harder to read and understand by adding unnecessary complexity.\nThis applies to string literals, template literals, and regular expressions.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: []\n\nAn array of characters that are allowed to be escaped unnecessarily in regexes.\nFor example, setting this to [\"#\"] allows \\# in regexes.\n\nEach string in this array must be a single character.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-useless-rename": "Disallow renaming import, export, and destructured assignments to the same name.\n\nIt is unnecessary to rename a variable to the same name.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhen set to true, allows using the same name in destructurings.\n\ntype: boolean\n\ndefault: false\n\nWhen set to true, allows renaming exports to the same name.\n\ntype: boolean\n\ndefault: false\n\nWhen set to true, allows renaming imports to the same name.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-useless-return": "Disallows redundant return statements.\n\nA return; statement with nothing after it is redundant, and has no effect\non the runtime behavior of a function. This can be confusing, so it's better\nto disallow these redundant statements.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-var": "ECMAScript 2015 allows programmers to create variables with block scope\ninstead of function scope using the let and const keywords. Block\nscope is common in many other programming languages and helps\nprogrammers avoid mistakes.\n\nUsing var in an ES2015 environment triggers this error\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-void": "Disallows the use of the void operator.\n\nThe void operator is often used to get undefined, but this is\nunnecessary because undefined can be used directly instead.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nIf set to true, using void as a standalone statement is allowed.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-warning-comments": "Disallows warning comments such as TODO, FIXME, XXX in code.\n\nDevelopers often add comments like TODO or FIXME to mark incomplete work or areas\nthat need attention. While useful during development, these comments can indicate\nunfinished code that shouldn't be shipped to production. This rule helps catch\nsuch comments before they make it into production code.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule has an options object with the following defaults:\n\nAn array of terms to match. The matching is case-insensitive.\n\nWhere to check for the terms:\n\n- \"start\" (default): Terms must appear at the start of the comment (after any decoration)\n- \"anywhere\": Terms can appear anywhere in the comment\n\nAn array of characters to ignore at the start of comments when location is \"start\".\nUseful for ignoring common comment decorations like  in JSDoc-style comments.\n\nTo enable** this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-with": "Disallow with statements.\n\nThe with statement is potentially problematic because it adds members\nof an object to the current scope, making it impossible to tell what a\nvariable inside the block actually refers to.\n\nIt is generally considered a bad practice and is forbidden in strict mode.\n\nThis rule is not necessary in TypeScript code if alwaysStrict is enabled.\n\nExamples of incorrect code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "operator-assignment": "This rule requires or disallows assignment operator shorthand where possible.\nIt encourages the use of shorthand assignment operators like +=, -=, =, /=, etc.\nto make the code more concise and readable.\n\nJavaScript provides shorthand operators that combine variable assignment and simple\nmathematical operations. Failing to use these shorthand operators can lead to unnecessarily\nverbose code and can be seen as a missed opportunity for clarity and simplicity.\n\nExamples of incorrect code for this rule with the default always option:\n\nExamples of correct code for this rule with the default always option:\n\nExamples of incorrect code for this rule with the never option:\n\nExamples of correct code for this rule with the never option:\n\nThis rule accepts one of the following string values:\n\nRequires assignment operator shorthand where possible.\n\nDisallows assignment operator shorthand.\n\nTo enable** this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-destructuring": "Require destructuring from arrays and/or objects\n\nWith JavaScript ES2015, a new syntax was added for creating variables from an array index or object property,\ncalled destructuring. This rule enforces usage of destructuring\ninstead of accessing a property through a member expression.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: object\n\ndefault: {\"array\":true, \"object\":true}\n\nConfiguration for destructuring in assignment expressions, configured for arrays and objects independently.\n\ntype: boolean\n\ndefault: true\n\ntype: boolean\n\ndefault: true\n\ntype: object\n\ndefault: {\"array\":true, \"object\":true}\n\nConfiguration for destructuring in variable declarations, configured for arrays and objects independently.\n\ntype: boolean\n\ndefault: true\n\ntype: boolean\n\ndefault: true\n\ntype: boolean\n\ndefault: false\n\nDetermines whether the object destructuring rule applies to renamed variables.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-exponentiation-operator": "Disallow the use of Math.pow in favor of the \\\\ operator\n\nIntroduced in ES2016, the infix exponentiation operator \\\\ is an alternative for the\nstandard Math.pow function. Infix notation is considered to be more readable and thus more\npreferable than the function notation.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-numeric-literals": "Disallow parseInt() and Number.parseInt() in favor of binary, octal, and hexadecimal\nliterals.\n\nThe parseInt() and Number.parseInt() functions can be used to turn binary, octal, and\nhexadecimal strings into integers. As binary, octal, and hexadecimal literals are supported\nin ES2015, this rule encourages use of those numeric literals instead of parseInt() or\nNumber.parseInt().\n\nExamples of incorrect code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-object-has-own": "Disallow use of Object.prototype.hasOwnProperty.call() and prefer use of Object.hasOwn()\n\nIt is very common to write code like:\n\nThis is a common practice because methods on Object.prototype can sometimes be unavailable or redefined (see the no-prototype-builtins rule).\nIntroduced in ES2022, Object.hasOwn() is a shorter alternative to Object.prototype.hasOwnProperty.call():\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-object-spread": "Disallow using Object.assign with an object literal as the first argument and prefer the use of object spread instead\n\nWhen Object.assign is called using an object literal as the first argument, this rule requires using the object spread syntax instead. This rule also warns on cases where an Object.assign call is made using a single argument that is an object literal, in this case, the Object.assign call is not needed.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-promise-reject-errors": "Require using Error objects as Promise rejection reasons.\n\nIt is considered good practice to only pass instances of the built-in Error object to the\nreject() function for user-defined errors in Promises. Error objects automatically\nstore a stack trace, which can be used to debug an error by determining where it came\nfrom. If a Promise is rejected with a non-Error value, it can be difficult to\ndetermine where the rejection occurred.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhether to allow calls to Promise.reject() with no arguments.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-rest-params": "Disallows the use of the arguments object and instead enforces the use of rest parameters.\n\nThe arguments object does not have methods from Array.prototype, making it inconvenient for array-like operations.\nUsing rest parameters provides a more intuitive and efficient way to handle variadic arguments.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-spread": "Require spread operators instead of .apply()\n\nBefore ES2015, one must use Function.prototype.apply() to call variadic functions.\n\nIn ES2015, one can use spread syntax to call variadic functions.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-template": "Require template literals instead of string concatenation.\n\nIn ES2015 (ES6), we can use template literals instead of string concatenation.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "preserve-caught-error": "Enforces that when re-throwing an error in a catch block, the original error\nis preserved using the 'cause' property.\n\nRe-throwing an error without preserving the original error loses important\ndebugging information and makes it harder to trace the root cause of issues.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhen set to true, requires that catch clauses always have a parameter.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "radix": "Enforce the consistent use of the radix argument when using parseInt().\n\nUsing the parseInt() function without specifying\nthe radix can lead to unexpected results.\n\nSee the\nMDN documentation\nfor more information.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts one of the following string values:\n\nAlways require the radix parameter when using parseInt().\n\nOnly require the radix parameter when necessary.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "require-await": "Disallow async functions which have no await expression.\n\nAsynchronous functions in JavaScript behave differently than other\nfunctions in two important ways:\n\n1. The return value is always a Promise.\n2. You can use the await operator inside of them.\n\nThe primary reason to use asynchronous functions is typically to use the\nawait operator, such as this:\n\nAsynchronous functions that don’t use await might not need to be\nasynchronous functions and could be the unintentional result of\nrefactoring.\n\nNote: this rule ignores async generator functions. This is because\ngenerators yield rather than return a value and async generators might\nyield all the values of another async generator without ever actually\nneeding to use await.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "require-yield": "This rule generates warnings for generator functions that do not have the yield keyword.\n\nProbably a mistake.\n\nExamples of incorrect code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "sort-imports": "This rule checks all import declarations and verifies that all imports are first sorted\nby the used member syntax and then alphabetically by the first member or alias name.\n\nWhen declaring multiple imports, a sorted list of import declarations make it easier for developers to read\nthe code and find necessary imports later.\n\nConsistent import sorting can be useful for readability and maintainability of code.\n\nExamples of incorrect code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhen true, the rule allows import groups separated by blank lines to be treated independently.\n\ntype: boolean\n\ndefault: false\n\nWhen true, the rule ignores case-sensitivity when sorting import names.\n\ntype: boolean\n\ndefault: false\n\nWhen true, the rule ignores the sorting of import declarations (the order of import statements).\n\ntype: boolean\n\ndefault: false\n\nWhen true, the rule ignores the sorting of import members within a single import declaration.\n\ntype: array\n\ndefault: [\"none\", \"all\", \"multiple\", \"single\"]\n\nSpecifies the sort order of different import syntaxes.\nMust include all 4 kinds or else this will fall back to default.\n\ntype: \"none\" | \"all\" | \"multiple\" | \"single\"\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "sort-keys": "When declaring multiple properties, sorting property names alphabetically makes it easier\nto find and/or diff necessary properties at a later time.\n\nUnsorted property keys can make the code harder to read and maintain.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\ntype: \"desc\" | \"asc\"\n\nSorting order for keys. Accepts \"asc\" for ascending or \"desc\" for descending.\n\nThis option is an object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhen true, groups of properties separated by a blank line are sorted independently.\n\ntype: boolean\n\ndefault: true\n\nWhether the sort comparison is case-sensitive (A < a when true).\n\ntype: integer\n\ndefault: 2\n\nMinimum number of properties required in an object before sorting is enforced.\n\ntype: boolean\n\ndefault: false\n\nUse natural sort order so that, for example, \"a2\" comes before \"a10\".\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "sort-vars": "When declaring multiple variables within the same block, sorting variable names make it\neasier to find necessary variable easier at a later time.\n\nUnsorted variable declarations can make the code harder to read and maintain.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhen true, the rule ignores case-sensitivity when sorting variables.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "symbol-description": "Require symbol descriptions.\n\nThe Symbol function may have an optional description.\n\nUsing description promotes easier debugging: when a symbol is logged the description is used:\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "unicode-bom": "Require or disallow Unicode byte order mark (BOM)\n\nThe Unicode Byte Order Mark (BOM) is used to specify whether code units are big endian or\nlittle endian. That is, whether the most significant or least significant bytes come first.\nUTF-8 does not require a BOM because byte ordering does not matter when characters are a\nsingle byte. Since UTF-8 is the dominant encoding of the web, we make \"never\" the default\noption.\n\nExamples of incorrect code for this rule:\n\nThis rule accepts one of the following string values:\n\nAlways require a Unicode BOM (Byte Order Mark) at the beginning of the file.\n\nNever allow a Unicode BOM (Byte Order Mark) at the beginning of the file.\nThis is the default option.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "use-isnan": "Disallows checking against NaN without using isNaN() call.\n\nIn JavaScript, NaN is a special value of the Number type.\nIt’s used to represent any of the “not-a-number” values represented\nby the double-precision 64-bit format as specified by the IEEE Standard\nfor Binary Floating-Point Arithmetic.\n\nBecause NaN is unique in JavaScript by not being equal to anything, including itself,\nthe results of comparisons to NaN are confusing:\n\n- NaN === NaN or NaN == NaN evaluate to false\n- NaN !== NaN or NaN != NaN evaluate to true\n\nTherefore, use Number.isNaN() or global isNaN() functions to test whether a value is NaN.\n\nExamples of incorrect code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhether to disallow NaN as arguments of indexOf and lastIndexOf\n\ntype: boolean\n\ndefault: true\n\nWhether to disallow NaN in switch cases and discriminants\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "valid-typeof": "Enforce comparing typeof expressions against valid strings.\n\nFor a vast majority of use cases, the result of the typeof operator is one of the\nfollowing string literals: \"undefined\", \"object\", \"boolean\", \"number\", \"string\",\n\"function\", \"symbol\", and \"bigint\". It is usually a typing mistake to compare the\nresult of a typeof operator to other string literals.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nThe requireStringLiterals option when set to true, allows the comparison of typeof\nexpressions with only string literals or other typeof expressions, and disallows\ncomparisons to any other value. Default is false.\n\nWith requireStringLiterals set to true, the following are examples of incorrect code:\n\nWith requireStringLiterals set to true, the following are examples of correct code:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "vars-on-top": "Enforces that all var declarations are placed at the top of their containing scope.\n\nIn JavaScript, var declarations are hoisted to the top of their containing scope. Placing var declarations at the top explicitly improves code readability and maintainability by making the scope of variables clear.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "yoda": "Require or disallow \"Yoda\" conditions.\nThis rule aims to enforce consistent style of conditions which compare a variable to a literal value.\n\nYoda conditions are so named because the literal value of the condition comes first while the variable comes second. For example, the following is a Yoda condition:\n\nThis is called a Yoda condition because it reads as, \"if red equals the color\", similar to the way the Star Wars character Yoda speaks. Compare to the other way of arranging the operands:\n\nThis typically reads, \"if the color equals red\", which is arguably a more natural way to describe the comparison.\nProponents of Yoda conditions highlight that it is impossible to mistakenly use = instead of == because you cannot assign to a literal value. Doing so will cause a syntax error and you will be informed of the mistake early on. This practice was therefore very common in early programming where tools were not yet available.\nOpponents of Yoda conditions point out that tooling has made us better programmers because tools will catch the mistaken use of = instead of == (ESLint will catch this for you). Therefore, they argue, the utility of the pattern doesn't outweigh the readability hit the code takes while using Yoda conditions.\n\nThis rule can take a string option:\n\n- If it is the default \"never\", then comparisons must never be Yoda conditions.\n- If it is \"always\", then the literal value must always come first.\n  The default \"never\" option can have exception options in an object literal:\n- If the \"exceptRange\" property is true, the rule allows yoda conditions in range comparisons which are wrapped directly in parentheses, including the parentheses of an if or while condition. The default value is false. A range comparison tests whether a variable is inside or outside the range between two literal values.\n- If the \"onlyEquality\" property is true, the rule reports yoda conditions only for the equality operators == and ===. The default value is false.\n  The onlyEquality option allows a superset of the exceptions which exceptRange allows, thus both options are not useful together.\n\nExamples of incorrect code for the default \"never\" option:\n\nExamples of correct code for the default \"never\" option:\n\nExamples of correct code for the \"never\", { \"exceptRange\": true } options:\n\nExamples of correct code for the \"never\", { \"onlyEquality\": true } options:\n\nExamples of incorrect code for the \"always\" option:\n\nExamples of correct code for the \"always\" option:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>"
  },
  "import": {
    "consistent-type-specifier-style": "This rule either enforces or bans the use of inline type-only markers for named imports.\n\nMixing top-level import type { Foo } from 'foo' with inline { type Bar }\nforces readers to mentally switch contexts when scanning your imports.\nEnforcing one style makes it immediately obvious which imports are types and which are value imports.\n\nExamples of incorrect code for the default prefer-top-level option:\n\nExamples of correct code for the default option:\n\nExamples of incorrect code for the prefer-inline option:\n\nExamples of correct code for the prefer-inline option:\n\nThis rule accepts one of the following string values:\n\nPrefer import type { Foo } from 'foo' for type imports.\n\nPrefer import { type Foo } from 'foo' for type imports.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "default": "If a default import is requested, this rule will report if there is no\ndefault export in the imported module.\n\nUsing a default import when there is no default export can lead to\nconfusion and runtime errors. It can make the code harder to understand\nand maintain, as it may suggest that a module has a default export\nwhen it does not, leading to unexpected behavior.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "export": "Reports funny business with exports, like repeated exports of names or defaults.\n\nHaving multiple exports of the same name can lead to ambiguity and confusion\nin the codebase. It makes it difficult to track which export is being used\nand can result in runtime errors if the wrong export is referenced.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "exports-last": "This rule enforces that all exports are declared at the bottom of the file.\nThis rule will report any export declarations that comes before any non-export statements.\n\nExports scattered throughout the file can lead to poor code readability\nand increase the cost of locating the export quickly\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "extensions": "Some file resolve algorithms allow you to omit the file extension within the import source path.\nFor example the node resolver (which does not yet support ESM/import) can resolve ./foo/bar to the absolute path /User/someone/foo/bar.js because the .js extension is resolved automatically by default in CJS.\nDepending on the resolver you can configure more extensions to get resolved automatically.\nIn order to provide a consistent use of file extensions across your code base, this rule can enforce or disallow the use of certain file extensions.\n\nESM-based file resolve algorithms (e.g., the one that Vite provides) recommend specifying the file extension to improve performance.\n\nExamples of incorrect code for this rule:\n\nThe following patterns are considered problems when configuration set to \"always\":\n\nThe following patterns are considered problems when configuration set to \"never\":\n\nExamples of correct code for this rule:\n\nThe following patterns are not considered problems when configuration set to \"always\":\n\nThe following patterns are not considered problems when configuration set to \"never\":\n\nPer-extension configuration examples:\n\nThis rule accepts three types of configuration:\n\n1. Global rule (string): \"always\", \"never\", or \"ignorePackages\"\n\n2. Per-extension rules (object): { \"js\": \"always\", \"jsx\": \"never\", ... }\n\n3. Combined (array): [\"error\", \"always\", { \"js\": \"never\" }] or [\"error\", { \"js\": \"always\" }]\n\nDefault behavior (no configuration): All imports - of all kinds - pass.\nUnconfigured file extensions are ignored, to avoid false positives.\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhether to check type imports when enforcing extension rules.\n\ntype: boolean\n\ndefault: false\n\nWhether to ignore package imports when enforcing extension rules.\n\n> [!IMPORTANT]\n> When setting this rule to always, you should also set ignorePackages to true.\n> Otherwise, package imports without extensions (such as import React from 'react';)\n> will be disallowed, which is not desirable and is not fixable.\n\nA boolean option (not per-extension) that exempts package imports from the \"always\" rule.\n\nCan be set in the config object: [\"error\", \"always\", { \"ignorePackages\": true }]\n\nLegacy shorthand: [\"error\", \"ignorePackages\"] is equivalent to [\"error\", \"always\", { \"ignorePackages\": true }]\n\n- With \"always\": When true, package imports (e.g., lodash, @babel/core) don't require extensions\n- With \"never\": This option has no effect; extensions are still forbidden on package imports\n\nExample: [\"error\", \"always\", { \"ignorePackages\": true }] allows import foo from \"lodash\" but requires import bar from \"./bar.js\"\n\ntype: array\n\ndefault: []\n\nPath group overrides for bespoke import specifiers.\n\nArray of pattern-action pairs for custom import protocols (monorepo tools, custom resolvers).\nEach override has: { \"pattern\": \"<glob-pattern>\", \"action\": \"enforce\" | \"ignore\" }\n\nPattern matching: Uses glob patterns (, , {a,b}) to match import specifiers.\nNote that the pattern matching is done in Rust with the fast-glob library, and so may differ\nfrom the JavaScript glob library used by the original ESLint rule.\n\nActions:\n\n- \"enforce\": Apply normal extension validation (respect global/per-extension rules)\n- \"ignore\": Skip all extension validation for matching imports\n\nPrecedence: First matching pattern wins.\n\nExamples:\n\nMatches imports from rootverse+debug:src, rootverse+bfe:src/symbols and\nignores whether or not they have an extension.\n\ntype: object\n\ntype: \"enforce\" | \"ignore\"\n\nAction to take for path group overrides.\n\nDetermines how import extensions are validated for matching bespoke import specifiers.\n\nEnforce extension validation for matching imports (require extensions based on config).\n\nIgnore matching imports entirely (skip all extension validation).\n\ntype: string\n\nGlob pattern to match import specifiers. This uses Rust's fast-glob library for matching.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "first": "Forbids any non-import statements before imports except directives.\n\nNotably, imports are hoisted, which means the imported modules will be evaluated\nbefore any of the statements interspersed between them.\nKeeping all imports together at the top of the file may prevent surprises\nresulting from this part of the spec\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts one of the following string values:\n\nForces absolute imports to be listed before relative imports.\n\nExamples of incorrect code for this rule with \"absolute-first\":\n\nExamples of correct code for this rule with \"absolute-first\":\n\nDisables the absolute-first behavior.\nThis is the default behavior.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "group-exports": "Reports when named exports are not grouped together in a single export declaration\nor when multiple assignments to CommonJS module.exports\nor exports object are present in a single file.\n\nAn export declaration or module.exports assignment can appear anywhere in the code.\nBy requiring a single export declaration all your exports will remain at one place,\nmaking it easier to see what exports a module provides.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "max-dependencies": "Forbid modules to have too many dependencies (import or require statements).\n\nThis is a useful rule because a module with too many dependencies is a code smell,\nand usually indicates the module is doing too much and/or should be broken up into\nsmaller modules.\n\nGiven {\"max\": 2}\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhether to ignore type imports when counting dependencies.\n\ntype: integer\n\ndefault: 10\n\nMaximum number of dependencies allowed in a module.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "named": "Verifies that all named imports are part of the set of named exports in\nthe referenced module.\n\nFor export, verifies that all named exports exist in the referenced\nmodule.\n\nNote: for packages, the plugin will find exported names from\njsnext:main (deprecated) or module, if present in package.json.\nRedux's npm module includes this key, and thereby is lintable, for\nexample.\n\nA module path that is ignored or not unambiguously an ES module will not\nbe reported when imported. Note that type imports and exports, as used\nby Flow, are always ignored.\n\nImporting or exporting names that do not exist in the referenced module\ncan lead to runtime errors and confusion. It may suggest that certain\nfunctionality is available when it is not, making the code harder to\nmaintain and understand. This rule helps ensure that your code\naccurately reflects the available exports, improving reliability.\n\nGiven\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "namespace": "Enforces names exist at the time they are dereferenced, when imported as\na full namespace (i.e. import  as foo from './foo'; foo.bar(); will\nreport if bar is not exported by ./foo.). Will report at the import\ndeclaration if there are no exported names found. Also, will report for\ncomputed references (i.e. foo[\"bar\"]()). Reports on assignment to a\nmember of an imported namespace.\n\nDereferencing a name that does not exist can lead to runtime errors and\nunexpected behavior in your code. It makes the code less reliable and\nharder to maintain, as it may not be clear which names are valid. This\nrule helps ensure that all referenced names are defined, improving\nthe clarity and robustness of your code.\n\nGiven\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhether to allow computed references to an imported namespace.\n\nTo enable** this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-absolute-path": "This rule forbids the import of modules using absolute paths.\n\nNode.js allows the import of modules using an absolute path such as /home/xyz/file.js.\nThat is a bad practice as it ties the code using it to your computer,\nand therefore makes it unusable in packages distributed on npm for instance.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nExamples of incorrect code for the { amd: true } option:\n\nExamples of correct code for the { amd: true } option:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nIf set to true, dependency paths for AMD-style define and require calls will be resolved:\n\ntype: boolean\n\ndefault: true\n\nIf set to true, dependency paths for CommonJS-style require calls will be resolved:\n\ntype: boolean\n\ndefault: true\n\nIf set to true, dependency paths for ES module import statements will be resolved:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-amd": "Forbids the use of AMD require and define calls.\n\nAMD (Asynchronous Module Definition) is an older module format\nthat is less common in modern JavaScript development, especially\nwith the widespread use of ES modules and CommonJS in Node.js.\nAMD introduces unnecessary complexity and is often considered outdated.\nThis rule enforces the use of more modern module systems to improve\nmaintainability and consistency across the codebase.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-anonymous-default-export": "Reports if a module's default export is unnamed.\nThis includes several types of unnamed data types;\nliterals, object expressions, arrays, anonymous functions, arrow functions,\nand anonymous class declarations.\n\nEnsuring that default exports are named helps improve the grepability of\nthe codebase by encouraging the re-use of the same identifier for\nthe module's default export at its declaration site and at its import sites.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nBy default, all types of anonymous default exports are forbidden,\nbut any types can be selectively allowed by toggling them on in the options.\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nAllow anonymous class as default export.\n\ntype: boolean\n\ndefault: false\n\nAllow anonymous function as default export.\n\ntype: boolean\n\ndefault: false\n\nAllow anonymous array as default export.\n\ntype: boolean\n\ndefault: false\n\nAllow anonymous arrow function as default export.\n\ntype: boolean\n\ndefault: true\n\nAllow anonymous call expression as default export.\n\ntype: boolean\n\ndefault: false\n\nAllow anonymous literal as default export.\n\ntype: boolean\n\ndefault: false\n\nAllow anonymous new expression as default export.\n\ntype: boolean\n\ndefault: false\n\nAllow anonymous object as default export.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-commonjs": "Forbids the use of CommonJS require calls. Also forbids module.exports and exports..\n\nESM modules or Typescript uses import and export syntax instead of CommonJS syntax.\nThis rule enforces the use of more modern module systems to improve maintainability and consistency across the codebase.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: true\n\nWhen set to true, allows conditional require() calls (e.g., inside if statements or try-catch blocks).\nThis is useful for places where you need to conditionally load via commonjs requires if ESM imports are not supported.\n\ntype: boolean\n\ndefault: false\n\nIf allowPrimitiveModules option is set to true, the following is valid:\n\nbut this is still reported:\n\ntype: boolean\n\ndefault: false\n\nIf set to true, require calls are valid:\n\nbut module.exports is reported as usual.\n\nTo enable** this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-cycle": "Ensures that there is no resolvable path back to this module via its dependencies.\n\nThis includes cycles of depth 1 (imported module imports me) to \"∞\" (or Infinity),\nif the maxDepth option is not set.\n\nDependency cycles lead to confusing architectures where bugs become hard to find.\nIt is common to import an undefined value that is caused by a cyclic dependency.\n\nExamples of incorrect code for this rule:\n\nIn this example, dep-a.js and dep-b.js import each other, creating a circular\ndependency, which is problematic.\n\nExamples of correct code for this rule:\n\nIn this corrected version, dep-b.js no longer imports dep-a.js, breaking the cycle.\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nAllow cyclic dependency if there is at least one dynamic import in the chain\n\ntype: boolean\n\ndefault: false\n\nIgnore external modules\n\ntype: boolean\n\ndefault: true\n\nIgnore type-only imports\n\ntype: integer\n\ndefault: 4294967295\n\nMaximum dependency depth to traverse\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-default-export": "Forbids a module from having default exports. This helps your editor\nprovide better auto-import functionality, as named exports offer more\nexplicit and predictable imports compared to default exports.\n\nDefault exports can lead to confusion, as the name of the imported value\ncan vary based on how it's imported. This can make refactoring and\nauto-imports less reliable.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-duplicates": "Reports if a resolved path is imported more than once in the same module.\nThis helps avoid unnecessary duplicate imports and keeps the code clean.\n\nImporting the same module multiple times can lead to redundancy and\nunnecessary complexity. It also affects maintainability, as it might\nconfuse developers and result in inconsistent usage of imports across the code.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhen set to true, prefer inline type imports instead of separate type import\nstatements for TypeScript code.\n\nExamples of correct code with this option set to true:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-dynamic-require": "Forbids imports that use an expression for the module argument. This includes\ndynamically resolved paths in require or import statements.\n\nUsing expressions that are resolved at runtime in import statements makes it\ndifficult to determine where the module is being imported from. This can complicate\ncode navigation and hinder static analysis tools, which rely on predictable module paths\nfor linting, bundling, and other optimizations.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhen true, also check import() expressions for dynamic module specifiers.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-empty-named-blocks": "Enforces that named import blocks are not empty.\n\nEmpty named imports serve no practical purpose and often\nresult from accidental deletions or tool-generated code.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-mutable-exports": "Forbids the use of mutable exports with var or let.\n\nIn general, we should always export constants\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nNote that exported function/class declaration identifiers may be reassigned,\nbut are not flagged by this rule at this time. They may be in the future.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-named-as-default-member": "Reports the use of an exported name (named export) as a property on the\ndefault export. This occurs when trying to access a named export through\nthe default export, which is incorrect.\n\nAccessing a named export via the default export is incorrect and will not\nwork as expected. Named exports should be imported directly, while default\nexports are accessed without properties. This mistake can lead to runtime\nerrors or undefined behavior.\n\nGiven\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-named-as-default": "Reports use of an exported name as the locally imported name of a default export.\nThis happens when an imported default export is assigned a name that conflicts\nwith a named export from the same module.\n\nUsing a named export's identifier for a default export can cause confusion\nand errors in understanding which value is being imported. It also reduces\ncode clarity, making it harder for other developers to understand the intended\nimports.\n\nGiven\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-named-default": "Reports use of a default export as a locally named import.\n\nRationale: the syntax exists to import default exports expressively, let's use it.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-named-export": "Prohibit named exports.\n\nNamed exports require strict identifier matching and can lead to fragile imports,\nwhile default exports enforce a single, consistent module entry point.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-namespace": "Enforce a convention of not using namespaced (a.k.a. \"wildcard\" \\) imports.\n\nNamespaced imports, while sometimes used, are generally considered less ideal in modern JavaScript development for several reasons:\n\n1. Specificity and Namespace Pollution:\n\n- Specificity: Namespaced imports import the entire module, bringing in everything, even if you only need a few specific functions or classes. This can lead to potential naming conflicts if different modules have the same names for different functions.\n- Pollution: Importing an entire namespace pollutes your current scope with potentially unnecessary functions and variables. It increases the chance of accidental use of an unintended function or variable, leading to harder-to-debug errors.\n\n2. Maintainability:\n\n- Clarity: Namespaced imports can make it harder to understand which specific functions or classes are being used in your code. This is especially true in larger projects with numerous imports.\n- Refactoring: If a function or class name changes within the imported module, you might need to update several parts of your code if you are using namespaced imports. This becomes even more challenging when dealing with multiple namespaces.\n\n3. Modern Practice:\n\n- Explicit Imports: Modern JavaScript practices encourage explicit imports for specific components. This enhances code readability and maintainability.\n- Tree-Shaking: Tools like Webpack and Rollup use tree-shaking to remove unused code from your bundles. Namespaced imports can prevent efficient tree-shaking, leading to larger bundle sizes.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: []\n\nAn array of glob strings for modules that should be ignored by the rule.\nFor example, [\".json\"] will ignore all JSON imports.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-self-import": "Forbids a module from importing itself. This can sometimes happen accidentally,\nespecially during refactoring.\n\nImporting a module into itself creates a circular dependency, which can cause\nruntime issues, including infinite loops, unresolved imports, or undefined values.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-unassigned-import": "This rule aims to remove modules with side-effects by reporting when a module is imported but not assigned.\n\nWith both CommonJS' require and the ES modules' import syntax,\nit is possible to import a module but not to use its result.\nThis can be done explicitly by not assigning the module to a variable.\nDoing so can mean either of the following things:\n\n- The module is imported but not used\n- The module has side-effects. Having side-effects,\n  makes it hard to know whether the module is actually used or can be removed.\n  It can also make it harder to test or mock parts of your application.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: []\n\nA list of glob patterns to allow unassigned imports for specific modules.\nFor example:\n{ \"allow\": [\".css\"] } will allow unassigned imports for any module ending with .css.\n\nTo enable** this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-webpack-loader-syntax": "Forbids using Webpack loader syntax directly in import or require statements.\n\nThis loader syntax is non-standard, so it couples the code to Webpack. The recommended way to\nspecify Webpack loader configuration is in a Webpack configuration file.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-default-export": "In exporting files, this rule checks if there is default export or not.\n\nThis rule exists to standardize module exports by preferring default exports\nwhen a module only has one export, enhancing readability, maintainability.\n\nExamples of incorrect code for the { target: \"single\" } option:\n\nExamples of correct code for the { target: \"single\" } option:\n\nExamples of incorrect code for the { target: \"any\" } option:\n\nExamples of correct code for the { target: \"any\" } option:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: \"single\" | \"any\"\n\ndefault: \"single\"\n\nConfiguration option to specify the target type for preferring default exports.\n\n- \"single\": Prefer default export when there is only one export in the module.\n- \"any\": Prefer default export in any module that has exports.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "unambiguous": "Warn if a module could be mistakenly parsed as a script and not pure ESM module\n\nFor ESM-only environments helps to determine files that not pure ESM modules\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>"
  },
  "jest": {
    "consistent-test-it": "Jest allows you to choose how you want to define your tests, using the it or\nthe test keywords, with multiple permutations for each:\n\n- it: it, xit, fit, it.only, it.skip.\n- test: test, xtest, test.only, test.skip.\n\nIt's a good practice to be consistent in your test suite, so that all tests are written in the same way.\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: \"it\" | \"test\"\n\ndefault: \"test\"\n\nDecides whether to use test or it.\n\ntype: \"it\" | \"test\"\n\ndefault: \"it\"\n\nDecides whether to use test or it within a describe scope.\nIf only fn is provided, this will default to the value of fn.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "expect-expect": "This rule triggers when there is no call made to expect in a test, ensure that there is at least one expect call made in a test.\n\nPeople may forget to add assertions.\n\nExamples of incorrect code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: []\n\nAn array of function names that should also be treated as test blocks.\n\ntype: string[]\n\ndefault: [\"expect\"]\n\nA list of function names that should be treated as assertion functions.\n\nNOTE: The default value is [\"expect\"] for Jest and\n[\"expect\", \"expectTypeOf\", \"assert\", \"assertType\"] for Vitest.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "max-expects": "This rule enforces a maximum number of expect() calls in a single test.\n\nTests with many different assertions are likely mixing multiple objectives.\nIt is generally better to have a single objective per test to ensure that when a test fails,\nthe problem is easy to identify.\n\nExamples of incorrect code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: integer\n\ndefault: 5\n\nMaximum number of expect() assertion calls allowed within a single test.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "max-nested-describe": "This rule enforces a maximum depth to nested describe() calls.\n\nNesting describe() blocks too deeply can make the test suite hard to read and understand.\n\nThe following patterns are considered warnings (with the default option of\n{ \"max\": 5 } ):\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: integer\n\ndefault: 5\n\nMaximum allowed depth of nested describe calls.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-alias-methods": "This rule ensures that only the canonical name as used in the Jest documentation is used in the code.\n\nThese aliases are going to be removed in the next major version of Jest - see jestjs/jest#13164 for more.\nThis rule will make it easier to search for all occurrences of the method within code, and it ensures consistency among the method names used.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nExamples of incorrect code for this rule with vitest:\n\nExamples of correct code for this rule with vitest:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-commented-out-tests": "This rule raises a warning about commented out tests. It's similar to the\nno-disabled-tests rule.\n\nYou may forget to uncomment some tests. This rule raises a warning about commented-out tests.\n\nIt is generally better to skip a test if it's flaky, or remove it if it's no longer needed.\n\nExamples of incorrect code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-conditional-expect": "This rule prevents the use of expect in conditional blocks, such as ifs & catch(s).\nThis includes using expect in callbacks to functions named catch, which are assumed to be promises.\n\nJest only considers a test to have failed if it throws an error, meaning if calls to\nassertion functions like expect occur in conditional code such as a catch statement,\ntests can end up passing but not actually test anything. Additionally, conditionals\ntend to make tests more brittle and complex, as they increase the amount of mental\nthinking needed to understand what is actually being tested.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-conditional-in-test": "Disallow conditional statements in tests.\n\nConditional statements in tests can make the test harder to read and understand. It is better to have a single test case per test function.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-confusing-set-timeout": "Disallow confusing usages of jest.setTimeout\n\n- being called anywhere other than in global scope\n- being called multiple times\n- being called after other Jest functions like hooks, describe, test, or it\n\nAll of these are invalid case:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-deprecated-functions": "Over the years Jest has accrued some debt in the form of functions that have\neither been renamed for clarity, or replaced with more powerful APIs.\n\nThis rule can also autofix a number of these deprecations for you.\n\nThis function was renamed to resetModules in Jest 15 and removed in Jest 27.\n\nThis function was replaced with expect.extend in Jest 17 and removed in Jest 27.\n\nThese functions were replaced in Jest 21 and removed in Jest 26.\n\nOriginally, the requireActual and requireMock functions were placed\nonto the require function.\n\nThese functions were later moved onto the jest object in order to be easier\nfor type checkers to handle, and their use via require deprecated. Finally,\nthe release of Jest 26 saw them removed from the require function altogether.\n\nThis function was renamed to advanceTimersByTime in Jest 22 and removed in Jest 27.\n\nThis function was renamed to createMockFromModule in Jest 26, and is scheduled for removal in Jest 30.\n\nWhile typically these deprecated functions are kept in the codebase for a number\nof majors, eventually they are removed completely.\n\nExamples of incorrect code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: object\n\nJest configuration options.\n\ntype: string\n\ndefault: \"29\"\n\nThe version of Jest being used.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-disabled-tests": "This rule raises a warning about disabled tests.\n\nJest has a feature that allows you to temporarily mark tests as disabled. This\nfeature is often helpful while debugging or to create placeholders for future\ntests. Before committing changes we may want to check that all tests are\nrunning.\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-done-callback": "This rule checks the function parameter of hooks & tests for use of the done argument, suggesting you return a promise instead.\n\nWhen calling asynchronous code in hooks and tests, jest needs to know when the asynchronous work is complete to progress the current run.\nOriginally the most common pattern to achieve this was to use callbacks:\n\nThis can be very error-prone however, as it requires careful understanding of how assertions work in tests or otherwise tests won't behave as expected.\n\nExamples of incorrect code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-duplicate-hooks": "Disallows duplicate hooks in describe blocks.\n\nHaving duplicate hooks in a describe block can lead to confusion and unexpected behavior.\nWhen multiple hooks of the same type exist, they all execute in order, which can make it\ndifficult to understand the test setup flow and may result in redundant or conflicting\noperations. This makes tests harder to maintain and debug.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-export": "Prevents using exports if a file has one or more tests in it.\n\nThis rule aims to eliminate duplicate runs of tests by exporting things from test files.\nIf you import from a test file, then all the tests in that file will be run in each imported instance.\nso bottom line, don't export from a test, but instead move helper functions into a separate file when they need to be shared across tests.\n\nExamples of incorrect code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-focused-tests": "This rule reminds you to remove .only from your tests by raising a warning\nwhenever you are using the exclusivity feature.\n\nJest has a feature that allows you to focus tests by appending .only or\nprepending f to a test-suite or a test-case. This feature is really helpful to\ndebug a failing test, so you don’t have to execute all of your tests. After you\nhave fixed your test and before committing the changes you have to remove\n.only to ensure all tests are executed on your build system.\n\nExamples of incorrect code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-hooks": "Disallows Jest setup and teardown hooks, such as beforeAll.\n\nJest provides global functions for setup and teardown tasks, which are\ncalled before/after each test case and each test suite. The use of these\nhooks promotes shared state between tests.\n\nThis rule reports for the following function calls:\n\n- beforeAll\n- beforeEach\n- afterAll\n- afterEach\n\nExamples of incorrect code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: []\n\nAn array of hook function names that are permitted for use.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-identical-title": "This rule looks at the title of every test and test suite.\nIt will report when two test suites or two test cases at the same level of a test suite have the same title.\n\nHaving identical titles for two different tests or test suites may create confusion.\nFor example, when a test with the same title as another test in the same test suite fails, it is harder to know which one failed and thus harder to fix.\n\nExamples of incorrect code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-interpolation-in-snapshots": "Prevents the use of string interpolations in snapshots.\n\nInterpolation prevents snapshots from being updated. Instead, properties should\nbe overloaded with a matcher by using\nproperty matchers.\n\nExamples of incorrect code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-jasmine-globals": "This rule reports on any usage of Jasmine globals, which is not ported to\nJest, and suggests alternatives from Jest's own API.\n\nWhen migrating from Jasmine to Jest, relying on Jasmine-specific globals\ncreates compatibility issues and prevents taking advantage of Jest's\nimproved testing features and better error reporting.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-large-snapshots": "Disallow large snapshots.\n\nWhen using Jest's snapshot capability one should be mindful of the size of\ncreated snapshots. As a general best practice snapshots should be limited in\nsize in order to be more manageable and reviewable. A stored snapshot is only as\ngood as its review and as such keeping it short, sweet, and readable is\nimportant to allow for thorough reviews.\n\nExamples of incorrect code for this rule:\n\nExamples of incorrect code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: Record<string, array>\n\ndefault: {}\n\nA map of snapshot file paths to arrays of snapshot names that are allowed to exceed the size limit.\nSnapshot names can be specified as regular expressions.\n\ntype: integer\n\ndefault: 50\n\nMaximum number of lines allowed for inline snapshots.\n\ntype: integer\n\ndefault: 50\n\nMaximum number of lines allowed for external snapshot files.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-mocks-import": "This rule reports imports from a path containing a mocks component.\n\nManually importing mocks from a mocks directory can lead to unexpected behavior\nand breaks Jest's automatic mocking system. Jest is designed to automatically resolve\nand use mocks from mocks directories when jest.mock() is called. Directly\nimporting from these directories bypasses Jest's module resolution system and can cause\ninconsistencies between test and production environments.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-restricted-jest-methods": "Restrict the use of specific jest and vi methods.\n\nCertain Jest or Vitest methods may be deprecated, discouraged in specific\ncontexts, or incompatible with your testing environment. Restricting\nthem helps maintain consistent and reliable test practices.\n\nBy default, no methods are restricted by this rule.\nYou must configure the rule for it to disable anything.\n\nExamples of incorrect code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: Record<string, string>\n\ndefault: {}\n\nA mapping of restricted Jest method names to custom messages - or\nnull, for a generic message.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-restricted-matchers": "Ban specific matchers & modifiers from being used, and can suggest alternatives.\n\nSome matchers or modifiers might be discouraged in your codebase for various reasons:\nthey might be deprecated, cause confusion, have performance implications, or there\nmight be better alternatives available. This rule allows you to enforce consistent\ntesting patterns by restricting certain Jest matchers and providing guidance on\npreferred alternatives.\n\nBans are expressed in the form of a map, with the value being either a string message to be shown,\nor null if only the default rule message should be used. Bans are checked against the start of\nthe expect chain - this means that to ban a specific matcher entirely you must specify all\nsix permutations, but allows you to ban modifiers as well. By default, this map is empty, meaning\nno matchers or modifiers are banned.\n\nExample configuration:\n\nExamples of incorrect code for this rule with the above configuration:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: Record<string, string>\n\ndefault: {}\n\nA map of restricted matchers/modifiers to custom messages.\nThe key is the matcher/modifier name (e.g., \"toBeFalsy\", \"resolves\", \"not.toHaveBeenCalledWith\").\nThe value is an optional custom message to display when the matcher/modifier is used.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-standalone-expect": "Prevents expect statements outside of a test or it block. An expect\nwithin a helper function (but outside of a test or it block) will not\ntrigger this rule.\n\nStatements like expect.hasAssertions() will NOT trigger this rule since these\ncalls will execute if they are not in a test block.\n\nexpect statements outside of test blocks will not be executed by the Jest\ntest runner, which means they won't actually test anything. This can lead to\nfalse confidence in test coverage and may hide bugs that would otherwise be\ncaught by proper testing.\n\nExamples of incorrect code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: []\n\nAn array of function names that should also be treated as test blocks.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-test-prefixes": "Require using .only and .skip over f and x.\n\nJest allows you to choose how you want to define focused and skipped tests,\nwith multiple permutations for each:\n\n- only & skip: it.only, test.only, describe.only, it.skip, test.skip, describe.skip.\n- 'f' & 'x': fit, fdescribe, xit, xtest, xdescribe.\n\nThis rule enforces usages from the only & skip list.\n\nExamples of incorrect code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-test-return-statement": "Disallow explicitly returning from tests.\n\nTests in Jest should be void and not return values.\nIf you are returning Promises then you should update the test to use\nasync/await.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-untyped-mock-factory": "This rule triggers a warning if mock() or doMock() is used without a generic\ntype parameter or return type.\n\nBy default, jest.mock and jest.doMock allow any type to be returned by a\nmock factory. A generic type parameter can be used to enforce that the factory\nreturns an object with the same shape as the original module, or some other\nstrict type. Requiring a type makes it easier to use TypeScript to catch changes\nneeded in test mocks when the source module changes.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "padding-around-test-blocks": "This rule enforces a line of padding before and after 1 or more test/it statements\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-called-with": "Suggest using toBeCalledWith() or toHaveBeenCalledWith()\n\nWhen testing function calls, it's often more valuable to assert both\nthat a function was called AND what arguments it was called with.\nUsing toBeCalled() or toHaveBeenCalled() only verifies the function\nwas invoked, but doesn't validate the arguments, potentially missing\nbugs where functions are called with incorrect parameters.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-comparison-matcher": "This rule checks for comparisons in tests that could be replaced with one of the\nfollowing built-in comparison matchers:\n\n- toBeGreaterThan\n- toBeGreaterThanOrEqual\n- toBeLessThan\n- toBeLessThanOrEqual\n\nUsing generic matchers like toBe(true) with comparison expressions\nmakes tests less readable and provides less helpful error messages when\nthey fail. Jest's specific comparison matchers offer clearer intent and\nbetter error output that shows the actual values being compared.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-each": "This rule enforces using each rather than manual loops.\n\nManual loops for tests can be less readable and more error-prone. Using\neach provides a clearer and more concise way to run parameterized tests,\nimproving readability and maintainability.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-equality-matcher": "Jest has built-in matchers for expecting equality, which allow for more readable\ntests and error messages if an expectation fails.\n\nTesting equality expressions with generic matchers like toBe(true)\nmakes tests harder to read and understand. When tests fail, the error\nmessages are less helpful because they don't show what the actual values\nwere. Using specific equality matchers provides clearer test intent and\nbetter debugging information.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-expect-resolves": "Prefer await expect(...).resolves over expect(await ...) when testing\npromises.\n\nWhen working with promises, there are two primary ways you can test the\nresolved value:\n\n1. use the resolve modifier on expect\n   (await expect(...).resolves.<matcher> style)\n2. await the promise and assert against its result\n   (expect(await ...).<matcher> style)\n\nWhile the second style is arguably less dependent on jest, if the\npromise rejects it will be treated as a general error, resulting in less\npredictable behaviour and output from jest.\n\nAdditionally, favoring the first style ensures consistency with its\nrejects counterpart, as there is no way of \"awaiting\" a rejection.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-hooks-in-order": "Ensures that hooks are in the order that they are called in.\n\nWhile hooks can be setup in any order, they're always called by jest in this\nspecific order:\n\n1. beforeAll\n2. beforeEach\n3. afterEach\n4. afterAll\n\nThis rule aims to make that more obvious by enforcing grouped hooks be setup in\nthat order within tests.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-hooks-on-top": "While hooks can be setup anywhere in a test file, they are always called in a\nspecific order, which means it can be confusing if they're intermixed with test\ncases.\n\nWhen hooks are mixed with test cases, it becomes harder to understand\nthe test setup and execution order. This can lead to confusion about\nwhich hooks apply to which tests and when they run. Grouping hooks at\nthe top of each describe block makes the test structure clearer and\nmore maintainable.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-jest-mocked": "When working with mocks of functions using Jest, it's recommended to use the\njest.mocked() helper function to properly type the mocked functions. This rule\nenforces the use of jest.mocked() for better type safety and readability.\n\nRestricted types:\n\n- jest.Mock\n- jest.MockedFunction\n- jest.MockedClass\n- jest.MockedObject\n\nUsing type assertions like fn as jest.Mock is a less safe approach\nthan using jest.mocked(). The jest.mocked() helper provides better\ntype safety by preserving the original function signature while adding\nmock capabilities. It also makes the code more readable and explicit\nabout mocking intentions.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-lowercase-title": "Enforce it, test, describe, and bench to have descriptions that begin with a\nlowercase letter. This provides more readable test failures. This rule is not\nenabled by default.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: []\n\nThis array option allows specifying prefixes, which contain capitals that titles\ncan start with. This can be useful when writing tests for API endpoints, where\nyou'd like to prefix with the HTTP method.\nBy default, nothing is allowed (the equivalent of { \"allowedPrefixes\": [] }).\n\nExample of correct code for the { \"allowedPrefixes\": [\"GET\"] } option:\n\ntype: string[]\n\ndefault: []\n\nThis array option controls which Jest or Vitest functions are checked by this rule. There\nare four possible values:\n\n- \"describe\"\n- \"test\"\n- \"it\"\n- \"bench\"\n\nBy default, none of these options are enabled (the equivalent of\n{ \"ignore\": [] }).\n\nExample of correct code for the { \"ignore\": [\"describe\"] } option:\n\nExample of correct code for the { \"ignore\": [\"test\"] } option:\n\nExample of correct code for the { \"ignore\": [\"it\"] } option:\n\ntype: boolean\n\ndefault: false\n\nThis option can be set to allow only the top-level describe blocks to have a\ntitle starting with an upper-case letter.\n\nExample of correct code for the { \"ignoreTopLevelDescribe\": true } option:\n\ntype: boolean\n\ndefault: true\n\nThis option can be set to only validate that the first character of a test name is lowercased.\n\nExample of correct code for the { \"lowercaseFirstCharacterOnly\": true } option:\n\nExample of incorrect code for the { \"lowercaseFirstCharacterOnly\": true } option:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-mock-promise-shorthand": "When working with mocks of functions that return promises, Jest provides some\nAPI sugar functions to reduce the amount of boilerplate you have to write.\nThese methods should be preferred when possible.\n\nUsing generic mock functions like mockImplementation(() => Promise.resolve())\nor mockReturnValue(Promise.reject()) is more verbose and less readable than\nJest's specialized promise shorthands. The shorthand methods like\nmockResolvedValue() and mockRejectedValue() are more expressive and\nmake the test intent clearer.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-spy-on": "When mocking a function by overwriting a property you have to manually restore\nthe original implementation when cleaning up. When using jest.spyOn() Jest\nkeeps track of changes, and they can be restored with jest.restoreAllMocks(),\nmockFn.mockRestore() or by setting restoreMocks to true in the Jest\nconfig.\n\nNote: The mock created by jest.spyOn() still behaves the same as the original\nfunction. The original function can be overwritten with\nmockFn.mockImplementation() or by some of the\nother mock functions.\n\nDirectly overwriting properties with mock functions can lead to cleanup issues\nand test isolation problems. When you manually assign a mock to a property,\nyou're responsible for restoring the original implementation, which is easy to\nforget and can cause tests to interfere with each other. Using jest.spyOn()\nprovides automatic cleanup capabilities and makes your tests more reliable.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-strict-equal": "This rule triggers a warning if toEqual() is used to assert equality.\n\nThe toEqual() matcher performs a deep equality check but ignores\nundefined values in objects and arrays. This can lead to false\npositives where tests pass when they should fail. toStrictEqual()\nprovides more accurate comparison by checking for undefined values.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-to-be": "Recommends using toBe matcher for primitive literals and specific\nmatchers for null, undefined, and NaN.\n\nWhen asserting against primitive literals such as numbers and strings,\nthe equality matchers all operate the same, but read slightly\ndifferently in code.\n\nThis rule recommends using the toBe matcher in these situations, as\nit forms the most grammatically natural sentence. For null,\nundefined, and NaN this rule recommends using their specific toBe\nmatchers, as they give better error messages as well.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-to-contain": "In order to have a better failure message, toContain() should be used upon\nasserting expectations on an array containing an object.\n\nThis rule triggers a warning if toBe(), toEqual() or toStrictEqual() is\nused to assert object inclusion in an array\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-to-have-been-called-times": "In order to have a better failure message, toHaveBeenCalledTimes should be used\ninstead of directly checking the length of mock.calls.\n\nThis rule triggers a warning if toHaveLength is used to assert the number of times a mock is called.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-to-have-been-called": "Suggests using toHaveBeenCalled() or not.toHaveBeenCalled() over toHaveBeenCalledTimes(0) or toBeCalledTimes(0).\n\ntoHaveBeenCalled() is more explicit and readable than toHaveBeenCalledTimes(0).\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-to-have-length": "In order to have a better failure message, toHaveLength() should be used upon\nasserting expectations on objects length property.\n\nThis rule triggers a warning if toBe(), toEqual() or toStrictEqual() is\nused to assert objects length property.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-todo": "When test cases are empty then it is better to mark them as test.todo as it\nwill be highlighted in the summary output.\n\nThis rule triggers a warning if empty test cases are used without 'test.todo'.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "require-hook": "This rule flags any expression that is either at the toplevel of a test file or\ndirectly within the body of a describe, except for the following:\n\n- import statements\n- const variables\n- let declarations, and initializations to null or undefined\n- Classes\n- Types\n- Calls to the standard Jest globals\n\nHaving setup and teardown code outside of hooks can lead to unpredictable test\nbehavior. Code that runs at the top level executes when the test file is loaded,\nnot when tests run, which can cause issues with test isolation and make tests\ndependent on execution order. Using proper hooks like beforeEach, beforeAll,\nafterEach, and afterAll ensures that setup and teardown code runs at the\ncorrect time and maintains test isolation.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: []\n\nAn array of function names that are allowed to be called outside of hooks.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "require-to-throw-message": "This rule triggers a warning if toThrow() or toThrowError() is used without an error message.\n\nUsing toThrow() or toThrowError() without specifying an expected error message\nmakes tests less specific and harder to debug. When a test only checks that an\nerror was thrown but not what kind of error, it can pass even when the wrong\nerror is thrown, potentially hiding bugs. Providing an expected error message\nor error type makes tests more precise and helps catch regressions more effectively.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "require-top-level-describe": "Requires test cases and hooks to be inside a top-level describe block.\n\nHaving tests and hooks organized within describe blocks provides better\nstructure and grouping for test suites. It makes test output more readable\nand helps with test organization, especially in larger codebases.\n\nThis rule triggers a warning if a test case (test and it) or a hook\n(beforeAll, beforeEach, afterEach, afterAll) is not located in a\ntop-level describe block.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: integer\n\ndefault: 18446744073709551615\n\nThe maximum number of top-level describe blocks allowed in a test file.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "valid-describe-callback": "This rule validates that the second parameter of a describe() function is a\ncallback function. This callback function:\n\n- should not be\n  async\n- should not contain any parameters\n- should not contain any return statements\n\nUsing an improper describe() callback function can lead to unexpected test\nerrors.\n\nExamples of incorrect code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "valid-expect": "Checks that expect() is called correctly.\n\nexpect() is a function that is used to assert values in tests.\nIt should be called with a single argument, which is the value to be tested.\nIf you call expect() with no arguments, or with more than one argument, it will not work as expected.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule is compatible with eslint-plugin-vitest,\nto use it, add the following configuration to your .oxlintrc.json:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhen true, async assertions must be awaited in all contexts (not just return statements).\n\ntype: string[]\n\ndefault: [\"toResolve\", \"toReject\"]\n\nList of matchers that are considered async and therefore require awaiting (e.g. toResolve, toReject).\n\ntype: integer\n\ndefault: 1\n\nMaximum number of arguments expect should be called with.\n\ntype: integer\n\ndefault: 1\n\nMinimum number of arguments expect should be called with.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "valid-title": "Checks that the titles of Jest and Vitest blocks are valid.\n\nTitles must be:\n\n- not empty,\n- strings,\n- not prefixed with their block name,\n- have no leading or trailing spaces.\n\nTitles that are not valid can be misleading and make it harder to understand the purpose of the test.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>"
  },
  "jsdoc": {
    "check-access": "Checks that @access tags use one of the following values:\n\n- \"package\", \"private\", \"protected\", \"public\"\n\nAlso reports:\n\n- Mixing of @access with @public, @private, @protected, or @package on the same doc block.\n- Use of multiple instances of @access (or the @public, etc) on the same doc block.\n\nIt is important to have a consistent way of specifying access levels in JSDoc\ncomments. Using invalid or multiple access level tags creates confusion about\nthe intended visibility of documented elements and can lead to inconsistencies\nin API documentation generation. Mixing different access tags or using invalid\nvalues makes the documentation unclear and potentially misleading.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "check-property-names": "Ensures that property names in JSDoc are not duplicated on the same block and that nested properties have defined roots.\n\n@property tags with the same name can be confusing and may indicate a mistake.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "check-tag-names": "Reports invalid block tag names.\nAdditionally checks for tag names that are redundant when using a type checker such as TypeScript.\n\nUsing invalid tags can lead to confusion and make the documentation harder to read.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nConfiguration for allowed tags is done via settings.jsdoc.tagNamePreference.\nThere is no CLI-only parameter for this rule.\n\nYou can add custom tags by adding a key-value pair where both match the name of the tag you want to add, like so:\n\n::: code-group\n\n:::\n\nExamples of correct code for this rule with the above configuration, adding the customTagName tag:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: []\n\nAdditional tag names to allow.\n\ntype: boolean\n\ndefault: false\n\nWhether to allow JSX-related tags:\n\n- jsx\n- jsxFrag\n- jsxImportSource\n- jsxRuntime\n\ntype: boolean\n\ndefault: false\n\nIf typed is true, disallow tags that are unnecessary/duplicative of TypeScript functionality.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "empty-tags": "Expects the following tags to be empty of any content:\n\n- @abstract\n- @async\n- @generator\n- @global\n- @hideconstructor\n- @ignore\n- @inner\n- @instance\n- @override\n- @readonly\n- @inheritDoc\n- @internal\n- @overload\n- @package\n- @private\n- @protected\n- @public\n- @static\n\nThe void tags should be empty.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: []\n\nAdditional tags to check for their descriptions.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "implements-on-classes": "Reports an issue with any non-constructor function using @implements.\n\nConstructor functions should be\nwhether marked with @class, @constructs, or being a class constructor.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-defaults": "This rule reports defaults being used on the relevant portion of @param or @default.\nIt also optionally reports the presence of the square-bracketed optional arguments at all.\n\nThe rule is intended to prevent the indication of defaults on tags\nwhere this would be redundant with ES2015 default parameters.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nIf true, report the presence of optional param names (square brackets) on @param tags.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "require-param-description": "Requires that each @param tag has a description value.\n\nThe description of a param should be documented.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "require-param-name": "Requires that all @param tags have names.\n\nThe name of a param should be documented.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "require-param-type": "Requires that each @param tag has a type value (within curly brackets).\n\nThe type of a parameter should be documented.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "require-param": "Requires that all function parameters are documented with JSDoc @param tags.\n\nThe rule is aimed at enforcing code quality and maintainability by requiring\nthat all function parameters are documented.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhether to check constructor methods.\n\ntype: boolean\n\ndefault: true\n\nWhether to check destructured parameters.\n\ntype: boolean\n\ndefault: true\n\nWhether to check destructured parameters when you have code like\nfunction doSomething({ a, b }) { ... }. Because there is no named\nparameter in this example, when this option is true you must\nhave a @param tag that corresponds to {a, b}.\n\ntype: boolean\n\ndefault: true\n\nWhether to check getter methods.\n\ntype: boolean\n\ndefault: false\n\nWhether to check rest properties.\n\ntype: boolean\n\ndefault: true\n\nWhether to check setter methods.\n\ntype: string\n\ndefault: \"^(?:[oO]bject|[aA]rray|PlainObject|Generic(?:Object|Array))$\"\n\nRegex pattern to match types that exempt parameters from checking.\n\ntype: string[]\n\ndefault: [\"inheritdoc\"]\n\nList of JSDoc tags that exempt functions from @param checking.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "require-property-description": "Requires that all @property tags have descriptions.\n\nThe description of a property should be documented.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "require-property-name": "Requires that all @property tags have names.\n\nThe name of a property type should be documented.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "require-property-type": "Requires that each @property tag has a type value (within curly brackets).\n\nThe type of a property should be documented.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "require-property": "Requires that all @typedef and @namespace tags have @property tags\nwhen their type is a plain object, Object, or PlainObject.\n\nNote: this rule can be configured via jsdoc settings option.\n\nObject type should have properties defined.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "require-returns-description": "Requires that the @returns tag has a description value.\nThe error will not be reported if the return value is void or undefined or if it is Promise<void> or Promise<undefined>.\n\nA @returns tag should have a description value.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "require-returns-type": "Requires that @returns tag has a type value (in curly brackets).\n\nA @returns tag should have a type value.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "require-returns": "Requires that return statements are documented.\nWill also report if multiple @returns tags are present.\n\nThe rule is intended to prevent the omission of @returns tag when necessary.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhether to check constructor methods.\n\ntype: boolean\n\ndefault: true\n\nWhether to check getter methods.\n\ntype: string[]\n\ndefault: [\"inheritdoc\"]\n\nTags that exempt functions from requiring @returns.\n\ntype: boolean\n\ndefault: false\n\nWhether to require a @returns tag even if the function doesn't return a value.\n\ntype: boolean\n\ndefault: false\n\nWhether to require a @returns tag for async functions.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "require-yields": "Requires that yields are documented.\nWill also report if multiple @yields tags are present.\n\nThe rule is intended to prevent the omission of @yields tags when they are necessary.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: [\"inheritdoc\"]\n\nFunctions with these tags will be exempted from the lint rule.\n\ntype: boolean\n\ndefault: false\n\nWhen true, all generator functions must have a @yields tag, even if they don't yield a value or have an empty body.\n\ntype: boolean\n\ndefault: false\n\nWhen true, require @yields when a @generator tag is present.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>"
  },
  "jsx_a11y": {
    "alt-text": "Enforce that all elements that require alternative text have meaningful\ninformation to relay back to the end user.\n\nAlternative text is a critical component of accessibility for screen\nreader users, enabling them to understand the content and function of\nan element. Missing or inadequate alt text makes content inaccessible\nto users who rely on assistive technologies.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: []\n\nCustom components to check for alt text on area elements.\n\ntype: string[]\n\ndefault: []\n\nCustom components to check for alt text on img elements.\n\ntype: string[]\n\ndefault: []\n\nCustom components to check for alt text on input[type=\"image\"] elements.\n\ntype: string[]\n\ndefault: []\n\nCustom components to check for alt text on object elements.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "anchor-ambiguous-text": "Inspects anchor link text for the use of ambiguous words.\n\nThis rule checks the text from the anchor element aria-label if available.\nIn absence of an anchor aria-label it combines the following text of it's children:\n\n- aria-label if available\n- if the child is an image, the alt text\n- the text content of the HTML element\n\nScreen readers users rely on link text for context, ambiguous words such as \"click here\" do\nnot provide enough context.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: [\"click here\", \"here\", \"link\", \"a link\", \"learn more\"]\n\nList of ambiguous words or phrases that should be flagged in anchor text.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "anchor-has-content": "Enforce that anchors have content and that the content is accessible to screen readers.\nAccessible means that it is not hidden using the aria-hidden prop.\n\nAlternatively, you may use the title prop or the aria-label prop.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "anchor-is-valid": "The HTML <a> element, with a valid href attribute, is formally defined as representing a hyperlink.\nThat is, a link between one HTML document and another, or between one location inside an HTML document and another location inside the same document.\n\nWhile before it was possible to attach logic to an anchor element, with the advent of JSX libraries,\nit's now easier to attach logic to any HTML element, anchors included.\n\nThis rule is designed to prevent users to attach logic at the click of anchors, and also makes\nsure that the href provided to the anchor element is valid. If the anchor has logic attached to it,\nthe rules suggests to turn it to a button, because that's likely what the user wants.\n\nAnchor <a></a> elements should be used for navigation, while <button></button> should be\nused for user interaction.\n\nConsider the following:\n\nAll these anchor implementations indicate that the element is only used to execute JavaScript code. All the above should be replaced with:\n\nThere are many reasons why an anchor should not have logic and have a correct href attribute:\n\n- it can disrupt the correct flow of the user navigation e.g. a user that wants to open the link\n  in another tab, but the default \"click\" behaviour is prevented\n- it can source of invalid links, and crawlers can't navigate the website, risking to penalise SEO ranking\n\nExamples of valid code for this rule:\n\nExamples of invalid code for this rule:\n\n- WCAG 2.1.1\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: []\n\nList of strings that are valid href values.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "aria-activedescendant-has-tabindex": "Enforce elements with aria-activedescendant are tabbable.\n\nElements with aria-activedescendant must be tabbable for users to\nnavigate to them using keyboard input. Without proper tabindex, screen\nreader users cannot access the element through keyboard navigation,\nmaking the functionality inaccessible.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "aria-props": "Enforces that elements do not use invalid ARIA attributes.\n\nUsing invalid ARIA attributes can mislead screen readers and other assistive technologies.\nIt may cause the accessibility features of the website to fail, making it difficult\nfor users with disabilities to use the site effectively.\n\nThis rule includes fixes for some common typos.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "aria-proptypes": "Enforces that elements do not use invalid ARIA state and property values.\n\nUsing invalid ARIA state and property values can mislead screen readers and other assistive technologies.\nIt may cause the accessibility features of the website to fail, making it difficult for users with disabilities to use the site effectively.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "aria-role": "Elements with ARIA roles must use a valid, non-abstract ARIA role. A\nreference to role definitions can be found at\nWAI-ARIA site.\n\nThe intent of this Success Criterion is to ensure that Assistive\nTechnologies (AT) can gather information about, activate (or set) and\nkeep up to date on the status of user interface controls in the\ncontent(such as screen readers, screen magnifiers, and speech\nrecognition software, used by people with disabilities).\n\nWhen standard controls from accessible technologies are used, this\nprocess is straightforward. If the user interface elements are used\naccording to specification the conditions of this provision will be met.\n\nIf custom controls are created, however, or interface elements are\nprogrammed (in code or script) to have a different role and/or function\nthan usual, then additional measures need to be taken to ensure that the\ncontrols provide important information to assistive technologies and\nallow themselves to be controlled by assistive technologies. A\nparticularly important state of a user interface control is whether or\nnot it has focus. The focus state of a control can be programmatically\ndetermined, and notifications about change of focus are sent to user\nagents and assistive technology. Other examples of user interface\ncontrol state are whether or not a checkbox or radio button has been\nselected, or whether or not a collapsible tree or list node is expanded\nor collapsed.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: []\n\nCustom roles that should be allowed in addition to the ARIA spec.\n\ntype: boolean\n\ndefault: false\n\nDetermines if developer-created components are checked.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "aria-unsupported-elements": "Enforces that reserved DOM elements do not contain ARIA roles, states,\nor properties.\n\nCertain reserved DOM elements do not support ARIA roles, states and\nproperties. This is often because they are not visible, for example\nmeta, html, script, style. Adding ARIA attributes to these\nelements is meaningless and can create confusion for screen readers.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "autocomplete-valid": "Enforces that an element's autocomplete attribute must be a valid value.\n\nIncorrectly using the autocomplete attribute may decrease the accessibility of the website for users.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: [\"input\"]\n\nList of custom component names that should be treated as input elements.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "click-events-have-key-events": "Enforce onClick is accompanied by at least one of the following: onKeyUp, onKeyDown, onKeyPress.\n\nCoding for the keyboard is important for users with physical disabilities who cannot use a mouse, AT compatibility, and screenreader users.\nThis does not apply for interactive or hidden elements.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "heading-has-content": "Enforce that heading elements (h1, h2, etc.) have content and\nthat the content is accessible to screen readers.\nAccessible means that it is not hidden using the aria-hidden prop.\n\nScreen readers alert users to the presence of a heading tag.\nIf the heading is empty or the text cannot be accessed,\nthis could either confuse users or even prevent them\nfrom accessing information on the page's structure.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: null\n\nAdditional custom component names to treat as heading elements.\nThese will be validated in addition to the standard h1-h6 elements.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "html-has-lang": "Ensures that every HTML document has a lang attribute\n\nIf the language of a webpage is not specified,\nthe screen reader assumes the default language set by the user.\nLanguage settings become an issue for users who speak multiple languages\nand access website in more than one language.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "iframe-has-title": "Enforce iframe elements have a title attribute.\n\nScreen reader users rely on a iframe title to describe the contents of\nthe iframe. Navigating through iframe and iframe elements quickly\nbecomes difficult and confusing for users of this technology if the\nmarkup does not contain a title attribute.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "img-redundant-alt": "Enforce that img alt attributes do not contain redundant words like\n\"image\", \"picture\", or \"photo\".\n\nScreen readers already announce img elements as an image, so there is\nno need to use words such as \"image\", \"photo\", or \"picture\" in the alt\ntext. This creates redundant information for users of assistive\ntechnologies and makes the alt text less concise and useful.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: [\"img\"]\n\nJSX element types to validate (component names) where the rule applies.\nFor example, [\"img\", \"Image\"].\n\ntype: string[]\n\ndefault: [\"image\", \"photo\", \"picture\"]\n\nWords considered redundant in alt text that should trigger a warning.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "label-has-associated-control": "Enforce that a label tag has a text label and an associated control.\n\nA form label that either isn't properly associated with a form control (such as an <input>), or doesn't contain accessible text, hinders accessibility for users using assistive technologies such as screen readers. The user may not have enough information to understand the purpose of the form control.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: \"htmlFor\" | \"nesting\" | \"both\" | \"either\"\n\ndefault: \"either\"\n\nThe type of association required between the label and the control.\n\ntype: string[]\n\ndefault: []\n\nCustom JSX components to be treated as form controls.\n\ntype: integer\n\ndefault: 2\n\nMaximum depth to search for a nested control.\n\ntype: string[]\n\ndefault: [\"alt\", \"aria-label\", \"aria-labelledby\"]\n\nAttributes to check for accessible label text.\n\ntype: string[]\n\ndefault: [\"label\"]\n\nCustom JSX components to be treated as labels.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "lang": "The lang prop on the <html> element must be a valid IETF's BCP 47 language tag.\n\nIf the language of a webpage is not specified as valid,\nthe screen reader assumes the default language set by the user.\nLanguage settings become an issue for users who speak multiple languages\nand access website in more than one language.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\n- eslint-plugin-jsx-a11y/lang\n- IANA Language Subtag Registry\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "media-has-caption": "Checks if <audio> and <video> elements have a <track> element for captions.\nThis ensures media content is accessible to all users, including those with hearing impairments.\n\nWithout captions, audio and video content is not accessible to users who are deaf or hard of hearing.\nCaptions are also useful for users in noisy environments or where audio is not available.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: [\"audio\"]\n\nElement names to treat as <audio> elements\n\ntype: string[]\n\ndefault: [\"track\"]\n\nElement names to treat as <track> elements\n\ntype: string[]\n\ndefault: [\"video\"]\n\nElement names to treat as <video> elements\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "mouse-events-have-key-events": "Enforce onMouseOver/onMouseOut are accompanied by onFocus/onBlur.\n\nCoding for the keyboard is important for users with physical disabilities who cannot use a mouse,\nAT compatibility, and screen reader users.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: [\"onMouseOver\"]\n\nList of hover-in mouse event handlers that require corresponding keyboard event handlers.\n\ntype: string[]\n\ndefault: [\"onMouseOut\"]\n\nList of hover-out mouse event handlers that require corresponding keyboard event handlers.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-access-key": "Enforces that the accessKey prop is not used on any element to avoid complications with keyboard commands used by a screenreader.\n\nAccess keys are HTML attributes that allow web developers to assign keyboard shortcuts to elements.\nInconsistencies between keyboard shortcuts and keyboard commands used by screenreaders and keyboard-only users create accessibility complications so to avoid complications, access keys should not be used.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-aria-hidden-on-focusable": "Enforces that aria-hidden=\"true\" is not set on focusable elements.\n\naria-hidden=\"true\" on focusable elements can lead to confusion or unexpected behavior for screen reader users.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-autofocus": "Enforce that autoFocus prop is not used on elements.\n\nAutofocusing elements can cause usability issues for sighted and\nnon-sighted users alike. It can be disorienting when focus is shifted\nwithout user input and can interfere with assistive technologies.\nUsers should control when and where focus moves on a page.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nDetermines if developer-created components are checked.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-distracting-elements": "Enforces that no distracting elements are used.\n\nElements that can be visually distracting can cause accessibility issues\nwith visually impaired users. Such elements are most likely deprecated,\nand should be avoided. By default, <marquee> and <blink> elements\nare visually distracting and can trigger vestibular disorders.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-noninteractive-tabindex": "This rule checks that non-interactive elements don't have a tabIndex which would make them interactive via keyboard navigation.\n\nTab key navigation should be limited to elements on the page that can be interacted with.\nThus it is not necessary to add a tabindex to items in an unordered list, for example,\nto make them navigable through assistive technology.\n\nThese applications already afford page traversal mechanisms based on the HTML of the page.\nGenerally, we should try to reduce the size of the page's tab ring rather than increasing it.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: true\n\nIf true, allows tabIndex values to be expression values (e.g., variables, ternaries). If false, only string literal values are allowed.\n\ntype: string[]\n\ndefault: [\"tabpanel\"]\n\nAn array of ARIA roles that should be considered interactive.\n\ntype: string[]\n\ndefault: []\n\nAn array of custom HTML elements that should be considered interactive.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-redundant-roles": "Enforces that the explicit role property is not the same as\nimplicit/default role property on element.\n\nRedundant roles can lead to confusion and verbosity in the codebase.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-static-element-interactions": "Enforces that static HTML elements with event handlers must have appropriate ARIA roles.\n\nStatic HTML elements do not have semantic meaning in accessibility contexts.\nWhen these elements receive click or keyboard event handlers, they must declare a role\nto indicate their interactive purpose to assistive technologies.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nIf true, role attribute values that are JSX expressions (e.g., role={ROLE}) are allowed.\nIf false, only string literal role values are permitted.\n\ntype: string[]\n\ndefault: null\n\nAn array of event handler names that should trigger this rule (e.g., onClick, onKeyDown).\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-tag-over-role": "Enforces using semantic HTML tags over role attribute.\n\nUsing semantic HTML tags can improve accessibility and readability of the code.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "role-has-required-aria-props": "Enforces that elements with ARIA roles must have all required attributes\nfor that role.\n\nCertain ARIA roles require specific attributes to express necessary\nsemantics for assistive technology.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "role-supports-aria-props": "Enforce that elements with explicit or implicit roles defined contain only aria- properties supported by that role. Many ARIA attributes (states and properties) can only be used on elements with particular roles. Some elements have implicit roles, such as <a href=\"#\" />, which will resolve to role=\"link\".\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable** this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "scope": "The scope prop should be used only on <th> elements.\n\nThe scope attribute makes table navigation much easier for screen reader users, provided that it is used correctly.\nIncorrectly used, scope can make table navigation much harder and less efficient.\nA screen reader operates under the assumption that a table has a header and that this header specifies a scope. Because of the way screen readers function, having an accurate header makes viewing a table far more accessible and more efficient for people who use the device.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "tabindex-no-positive": "Enforces that positive values for the tabIndex attribute are not used\nin JSX.\n\nUsing tabIndex values greater than 0 can make navigation and\ninteraction difficult for keyboard and assistive technology users,\ndisrupting the logical order of content.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>"
  },
  "nextjs": {
    "google-font-display": "Enforce font-display behavior with Google Fonts.\n\nSpecifying display=optional minimizes the risk of invisible text or\nlayout shift. If swapping to the custom font after it has loaded is\nimportant to you, then use display=swap` instead.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "google-font-preconnect": "Enforces the presence of rel=\"preconnect\" when using Google Fonts via <link> tags.\n\nWhen using Google Fonts, it's recommended to include a preconnect resource hint to establish early connections to the required origin.\nWithout preconnect, the browser needs to perform DNS lookups, TCP handshakes, and TLS negotiations before it can download the font files,\nwhich can delay font loading and impact performance.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "inline-script-id": "Enforces that all next/script components with inline content or dangerouslySetInnerHTML must have an id prop.\n\nNext.js requires a unique id prop for inline scripts to properly deduplicate them during page renders.\nWithout an id, the same inline script might be executed multiple times, leading to unexpected behavior\nor performance issues. This is particularly important for scripts that modify global state or perform\none-time initializations.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "next-script-for-ga": "Enforces the use of the next/script component when implementing Google Analytics in Next.js applications,\ninstead of using regular <script> tags.\n\nUsing regular <script> tags for Google Analytics can lead to several issues:\n\n- Scripts may load in a blocking manner, impacting page performance\n- No built-in optimization or loading strategies\n- Lack of automatic resource handling that Next.js provides\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-assign-module-variable": "Prevents the assignment or declaration of variables named module in Next.js applications.\n\nThe variable name module is reserved in Next.js for internal use and module system\nfunctionality. Declaring your own module variable can conflict with Next.js's internal\nmodule system, lead to unexpected behavior in your application, and cause issues with code\nsplitting and hot module replacement.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-async-client-component": "Prevents the use of async functions for client components in Next.js applications.\nThis rule checks for any async function that:\n\n- Is marked with \"use client\" directive\n- Has a name starting with an uppercase letter (indicating it's a component)\n- Is either exported as default or assigned to a variable\n\nUsing async functions for client components can cause hydration mismatches between server and client,\ncan break component rendering lifecycle, and can lead to unexpected behavior with React's concurrent features.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-before-interactive-script-outside-document": "Prevents the usage of next/script's beforeInteractive strategy outside of pages/document.js.\nThis rule ensures that scripts with the beforeInteractive loading strategy are only used in the\ndocument component where they are most effective.\n\nThe beforeInteractive strategy is specifically designed to load scripts before any page hydration\noccurs, which is only guaranteed to work correctly when placed in pages/document.js. Using it elsewhere:\n\n- May not achieve the intended early loading behavior\n- Can lead to inconsistent script loading timing\n- Might cause hydration mismatches or other runtime issues\n- Could impact the application's performance optimization\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-css-tags": "Prevents manual inclusion of stylesheets using <link> tags in Next.js applications.\nThis rule checks for <link> tags with rel=\"stylesheet\" that reference local CSS files.\n\nNext.js handles CSS imports automatically through its built-in CSS support.\nManual stylesheet inclusion bypasses Next.js's built-in CSS optimization,\nprevents proper code splitting and optimization of styles, and may cause\nFlash of Unstyled Content (FOUC). This also breaks automatic CSS hot reloading\nduring development.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-document-import-in-page": "Prevent importing next/document outside of pages/document.js.\n\nImporting next/document outside of pages/document.js can cause\nunexpected issues in your Next.js application.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-duplicate-head": "Prevent duplicate usage of <Head> in pages/document.js.\n\nThis can cause unexpected behavior in your application.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-head-element": "Prevents the usage of the native <head> element inside a Next.js application.\n\nA <head> element can cause unexpected behavior in a Next.js application.\nUse Next.js' built-in next/head component instead.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-head-import-in-document": "Prevents the usage of next/head inside a Next.js document.\n\nImporting next/head inside pages/document.js can cause\nunexpected issues in your Next.js application.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-html-link-for-pages": "Prevents the usage of <a> elements to navigate between Next.js pages.\n\nUsing <a> elements for internal navigation in Next.js applications can cause:\n\n- Full page reloads instead of client-side navigation\n- Loss of application state\n- Slower navigation performance\n- Broken prefetching capabilities\n\nNext.js provides the <Link /> component from next/link for client-side navigation\nbetween pages, which provides better performance and user experience.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nExternal links are allowed:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-img-element": "Prevent the usage of <img> element due to slower\nLCP and higher bandwidth.\n\n<img> elements are not optimized for performance and can result in\nslower LCP and higher bandwidth. Using <Image />\nfrom next/image will automatically optimize images and serve them as\nstatic assets.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-page-custom-font": "Prevent page-only custom fonts.\n\n- The custom font you're adding was added to a page - this only adds the font to the specific page and not the entire application.\n- The custom font you're adding was added to a separate component within pages/document.js - this disables automatic font optimization.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-script-component-in-head": "Prevent usage of next/script in next/head component.\n\nThe next/script component should not be used in a next/head component.\nInstead move the <Script /> component outside of <Head> instead.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-styled-jsx-in-document": "Prevent usage of styled-jsx in pages/document.js.\n\nCustom CSS like styled-jsx is not allowed in a Custom Document.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-sync-scripts": "This rule prevents the use of synchronous <script> tags in Next.js applications.\nIt requires that any <script> tag with a src attribute must also have either\nthe async or defer attribute.\n\nSynchronous scripts can block the page rendering and negatively impact performance.\nIn Next.js applications, it's recommended to use async or defer attributes\nto load scripts asynchronously, which improves page load times and user experience.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-title-in-document-head": "Prevent usage of <title> with Head component from next/document.\n\nA <title> element should only be used for any <head> code that is common for all pages.\nTitle tags should be defined at the page-level using next/head instead.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-typos": "Detects common typos in Next.js data fetching function names.\n\nNext.js will not call incorrectly named data fetching functions, causing pages to render without expected data.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-unwanted-polyfillio": "Prevent use of unsafe polyfill.io domains and duplicate polyfills.\n\nSecurity Risk:\nThe domains cdn.polyfill.io and polyfill.io were compromised in a supply chain attack in 2024,\nwhere the domain was acquired by a malicious actor and began injecting harmful code into websites.\nOver 380,000+ websites were affected. These domains should not be used under any circumstances.\n\nPerformance Issue:\nFor safe alternatives like cdnjs.cloudflare.com/polyfill/, including polyfills already shipped\nwith Next.js unnecessarily increases page weight which can affect loading performance.\n\nExamples of incorrect code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>"
  },
  "node": {
    "global-require": "Require require() calls to be placed at top-level module scope\n\nIn Node.js, module dependencies are included using the require() function, such as:\n\nWhile require() may be called anywhere in code, some style guides prescribe that it should be called only in the top level of a module to make it easier to identify dependencies.\nFor instance, it's arguably harder to identify dependencies when they are deeply nested inside of functions and other statements:\n\nSince require() does a synchronous load, it can cause performance problems when used in other locations.\nFurther, ES6 modules mandate that import and export statements can only occur in the top level of the module's body.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-exports-assign": "Disallows assignment to exports.\n\nDirectly using exports = {} can lead to confusion and potential bugs\nbecause it reassigns the exports object, which may break module\nexports. It is more predictable and clearer to use module.exports\ndirectly or in conjunction with exports.\n\nThis rule is aimed at disallowing exports = {}, but allows\nmodule.exports = exports = {} to avoid conflict with n/exports-style\nrule's allowBatchAssign option.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-new-require": "Warn about calling new on require.\n\nThe require function is used to include modules and might return a constructor. As this\nis not always the case this can be confusing.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-process-env": "Disallows use of process.env.\n\nDirectly reading process.env can lead to implicit runtime configuration,\nmake code harder to test, and bypass configuration validation.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: []\n\nVariable names which are allowed to be accessed on process.env.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>"
  },
  "oxc": {
    "approx-constant": "Disallows the use of approximate constants, instead preferring the use\nof the constants in the Math object.\n\nApproximate constants are not as accurate as the constants in the Math object.\nUsing the Math constants improves code readability and accuracy.\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/GlobalObjects/Math\nfor more information.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>",
    "bad-array-method-on-arguments": "This rule applies when an array method is called on the arguments object itself.\n\nThe arguments object\nis not an array, but an array-like object. It should be converted to a real array before calling an array method.\nOtherwise, a TypeError exception will be thrown because of the non-existent method.\n\nNote that you probably don't need this rule if you are using exclusively\nTypeScript, as it will catch these errors when typechecking.\n\narguments usage is usually discouraged in modern JavaScript, and you should prefer using\nrest parameters instead, e.g. function sum(...args).\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "bad-bitwise-operator": "This rule applies when bitwise operators are used where logical operators are expected.\n\nBitwise operators have different results from logical operators and a TypeError exception may be thrown because short-circuit evaluation is not applied.\n(In short-circuit evaluation, right operand evaluation is skipped according to left operand value, e.g. x is false in x && y.)\n\nIt is obvious that logical operators are expected in the following code patterns:\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "bad-char-at-comparison": "This rule warns when the return value of the charAt method is used to compare a string of length greater than 1.\n\nThe charAt method returns a string of length 1. If the return value is compared with a string of length greater than 1, the comparison will always be false.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "bad-comparison-sequence": "This rule applies when the comparison operator is applied two or more times in a row.\n\nBecause comparison operator is a binary operator, it is impossible to compare three or more operands at once.\nIf comparison operator is used to compare three or more operands, only the first two operands are compared and the rest is compared with its result of boolean type.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "bad-min-max-func": "Checks whether the clamp function Math.min(Math.max(x, y), z) always evaluate to a\nconstant result because the arguments are in the wrong order.\n\nThe Math.min(Math.max(x, y), z) function is used to clamp a value between two other values.\nIf the arguments are in the wrong order, the function will always evaluate to a constant result.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "bad-object-literal-comparison": "Checks for comparisons between object and array literals.\n\nComparing a variable to an object or array literal will always return false as object and array literals are never equal to each other.\n\nIf you want to check if an object or array is empty, use Object.entries() or Object.keys() and their lengths.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "bad-replace-all-arg": "This rule warns when the replaceAll method is called with a regular expression that does not have the global flag (g).\n\nThe replaceAll method replaces all occurrences of a string with another string. If the global flag (g) is not used in the regular expression, only the first occurrence of the string will be replaced.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "branches-sharing-code": "Checks if the if and else blocks contain shared code that can be moved out of the blocks.\n\nDuplicate code is less maintainable. Extracting common code from branches makes the code more DRY (Don't Repeat Yourself)\nand easier to maintain.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "const-comparisons": "Checks for redundant or logically impossible comparisons. This includes:\n\n- Ineffective double comparisons against constants.\n- Impossible comparisons involving constants.\n- Redundant comparisons where both operands are the same (e.g., a < a).\n\nSuch comparisons can lead to confusing or incorrect logic in the program. In many cases:\n\n- Only one of the comparisons has any effect on the result, suggesting that the programmer might have made a mistake, such as flipping one of the comparison operators or using the wrong variable.\n- Comparisons like a < a or a >= a are always false or true respectively, making the logic redundant and potentially misleading.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "double-comparisons": "This rule checks for double comparisons in logical expressions.\n\nRedundant comparisons can be confusing and make code harder to understand.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "erasing-op": "Checks for erasing operations, e.g., x \\ 0`.\n\nBased on https://rust-lang.github.io/rust-clippy/master/#/erasingop\n\nThe whole expression can be replaced by zero. This is most likely not the intended outcome and should probably be corrected.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable** this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>",
    "misrefactored-assign-op": "https://rust-lang.github.io/rust-clippy/master/#/misrefactoredassignop\n\nChecks for a op= a op b or a op= b op a patterns.\n\nMost likely these are bugs where one meant to write a op= b.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "missing-throw": "Checks whether the throw keyword is missing in front of a new expression.\n\nThe throw keyword is required in front of a new expression to throw an error. Omitting it is usually a mistake.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-accumulating-spread": "Prevents using object or array spreads on accumulators in Array.prototype.reduce() and in loops.\n\nObject and array spreads create a new object or array on each iteration.\nIn the worst case, they also cause O(n) copies (both memory and time complexity).\nWhen used on an accumulator, this can lead to O(n^2) memory complexity and\nO(n^2) time complexity.\n\nFor a more in-depth explanation, see this blog post\nby Prateek Surana.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-async-await": "Disallows the use of async/await.\n\nThis rule should generally not be used in modern JavaScript/TypeScript\ncodebases without good reason.\n\nThis rule is useful for environments that don't support async/await syntax,\nor when you want to enforce the use of promises or other asynchronous\npatterns instead. It can also be used to maintain consistency in codebases\nthat use alternative async patterns.\n\nExamples of incorrect code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-async-endpoint-handlers": "Disallows the use of async functions as Express endpoint handlers.\n\nBefore v5, Express will not automatically handle Promise rejections from\nhandler functions with your application's error handler. You must\ninstead explicitly pass the rejected promise to next().\n\nIf this is not done, your server will crash with an unhandled promise\nrejection.\n\nSee Express' Error Handling\nGuide for more\ninformation.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: []\n\nAn array of names that are allowed to be async.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-barrel-file": "Disallow the use of barrel files where the file contains export  statements,\nand the total number of modules exceed a threshold.\n\nThe default threshold is 100.\n\nBarrel files that re-export many modules can significantly slow down\napplications and bundlers. When a barrel file exports a large number of\nmodules, importing from it forces the runtime or bundler to process all\nthe exported modules, even if only a few are actually used. This leads\nto slower startup times and larger bundle sizes.\n\nReferences:\n\n- <https://github.com/thepassle/eslint-plugin-barrel-files>\n- <https://marvinh.dev/blog/speeding-up-javascript-ecosystem-part-7>\n\nInvalid:\n\nValid:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: integer\n\ndefault: 100\n\nThe maximum number of modules that can be re-exported via export \nbefore the rule is triggered.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-const-enum": "Disallow TypeScript const enum\n\nConst enums are enums that should be inlined at use sites.\nConst enums are not supported by bundlers and are incompatible with the isolatedModules mode.\nTheir use can lead to import nonexistent values (because const enums are erased).\n\nExamples of incorrect code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-map-spread": "Disallow the use of object or array spreads in\nArray.prototype.map\nand\nArray.prototype.flatMap\nto add properties/elements to array items.\n\nThis rule only seeks to report cases where the spread operator is used\nto merge objects or arrays, not where it is used to copy them.\n\nSpreading is commonly used to add properties to objects in an array or\nto combine several objects together. Unfortunately, spreads incur a\nre-allocation for a new object, plus O(n) memory copies.\n\nUnless you expect objects in the mapped array to be mutated later, it is\nbetter to use Object.assign.\n\nThere are valid use cases for spreading objects in map calls,\nspecifically when you want consumers of returned arrays to be able to\nmutate them without affecting the original data. This rule makes a\nbest-effort attempt to avoid reporting on these cases.\n\nSpreads on class instance properties are completely ignored:\n\nSpreads on arrays that are re-read after the map call are also ignored\nby default. Configure this behavior with the ignoreRereads option.\n\nIn the case of array spreads,\nArray.prototype.concat\nor\nArray.prototype.push\nshould be used wherever possible. These have slignly different semantics\nthan array spreads, since spreading works on iterables while concat\nand push work only on arrays.\n\nThis rule can automatically fix violations caused by object spreads, but\ndoes not fix arrays. Object spreads will get replaced with\nObject.assign. Array fixing may be added in the future.\n\nObject expressions with a single element (the spread) are not fixed.\n\nA fix is available (using --fix) for objects with \"normal\" elements before the\nspread. Since Object.apply mutates the first argument, and a new\nobject will be created with those elements, the spread identifier will\nnot be mutated. In effect, the spread semantics are preserved\n\nA suggestion (using --fix-suggestions) is provided when a spread is\nthe first property in an object. This fix mutates the spread identifier,\nmeaning it could have unintended side effects.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\n- ECMA262 - Object spread evaluation semantics\n- JSPerf - concat vs array spread performance\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: true\n\nIgnore maps on arrays passed as parameters to a function.\n\nThis option is enabled by default to better avoid false positives. It\ncomes at the cost of potentially missing spreads that are inefficient.\nWe recommend turning this off in your .oxlintrc.json files.\n\nExamples of incorrect code for this rule when ignoreArgs is true:\n\nExamples of correct code for this rule when ignoreArgs is true:\n\ntype: boolean\n\ndefault: true\n\nIgnore mapped arrays that are re-read after the map call.\n\nRe-used arrays may rely on shallow copying behavior to avoid mutations.\nIn these cases, Object.assign is not really more performant than spreads.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-optional-chaining": "Disallow optional chaining.\n\nYou may want to use this rule if you need to maintain compatibility with older environments.\nHowever, optional chaining has been supported in all major browsers since 2020 and is\ngenerally safe to use today.\n\nIn some cases, transpiling optional chaining can result in verbose helper code\nthat impacts bundle size and performance. This rule is useful when you need to\navoid the overhead of transpiled optional chaining. This is only relevant if you\nare polyfilling to support browsers from pre-2020.\n\nIn most codebases at this point, you should not use this rule.\n\nExamples of incorrect code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string\n\ndefault: \"\"\n\nA custom help message to display when optional chaining is found.\nFor example, \"Our output target is ES2016, and optional chaining results in verbose\nhelpers and should be avoided.\"\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-rest-spread-properties": "Disallow Object Rest/Spread Properties.\n\nObject rest/spread properties are a relatively new JavaScript feature that may\nnot be supported in all target environments. If you need to support older\nbrowsers or JavaScript engines that don't support these features, using them\ncan cause runtime errors. This rule helps maintain compatibility with older\nenvironments by preventing the use of these modern syntax features.\n\nExamples of incorrect code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string\n\ndefault: \"\"\n\nA message to display when object rest properties are found.\n\ntype: string\n\ndefault: \"\"\n\nA message to display when object spread properties are found.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-this-in-exported-function": "Disallows the use of this in exported functions.\n\nIn most bundlers, the value of this is not preserved for exported functions.\nWhen a function is exported and imported in another module, this typically\nbecomes undefined instead of the module namespace object. This can lead to\nunexpected runtime errors or incorrect behavior.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "number-arg-out-of-range": "Checks whether the radix or precision arguments of number-related functions exceeds the limit.\n\nThe radix argument of Number.prototype.toString should be between 2 and 36.\nThe precision argument of Number.prototype.toFixed and Number.prototype.toExponential should be between 0 and 20.\nThe precision argument of Number.prototype.toPrecision should be between 1 and 21.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "only-used-in-recursion": "Checks for arguments that are only used in recursion with no side-effects.\n\nInspired by https://rust-lang.github.io/rust-clippy/master/#/onlyusedinrecursion\n\nSupplying an argument that is only used in recursive calls is likely a mistake.\n\nIt increase cognitive complexity and may impact performance.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>",
    "uninvoked-array-callback": "This rule applies when an Array function has a callback argument used for an array with empty slots.\n\nWhen the Array constructor is called with a single number argument, an array with the specified number of empty slots (not actual undefined values) is constructed.\nIf a callback function is passed to the function of this array, the callback function is never invoked because the array has no actual elements.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>"
  },
  "promise": {
    "always-return": "Require returning inside each then() to create readable and reusable Promise chains.\nWe also allow someone to throw inside a then() which is essentially the same as return Promise.reject().\n\nBroken Promise Chain.\nInside the first then() callback, a function is called but not returned.\nThis causes the next then() in the chain to execute immediately without waiting for the called function to complete.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: [\"globalThis\"]\n\nYou can pass an { ignoreAssignmentVariable: [] } as an option to this rule\nwith a list of variable names so that the last then() callback in a promise\nchain does not warn if it does an assignment to a global variable. Default is\n[\"globalThis\"].\n\ntype: boolean\n\ndefault: false\n\nYou can pass an { ignoreLastCallback: true } as an option to this rule so that\nthe last then() callback in a promise chain does not warn if it does not have\na return. Default is false.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "avoid-new": "Disallow creating promises with new Promise().\n\nMany cases that use new Promise() could be refactored to use an\nasync function. async is considered more idiomatic in modern JavaScript.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "catch-or-return": "Ensure that each time a then() is applied to a promise, a catch()\nmust be applied as well. Exceptions are made for promises returned from\na function.\n\nNot catching errors in a promise can cause hard to debug problems or\nmissing handling of error conditions. In the worst case, unhandled\npromise rejections can cause your application to crash.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhether to allow finally() as a termination method.\n\ntype: boolean\n\ndefault: false\n\nWhether to allow then() with two arguments as a termination method.\n\ntype: string[]\n\ndefault: [\"catch\"]\n\nList of allowed termination methods (e.g., catch, done).\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-callback-in-promise": "Disallows calling a callback function (cb()) inside a Promise.prototype.then()\nor Promise.prototype.catch().\n\nDirectly invoking a callback inside a then() or catch() method can lead to\nunexpected behavior, such as the callback being called multiple times. Additionally,\nmixing the callback and promise paradigms in this way can make the code confusing\nand harder to maintain.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: [\"callback\", \"cb\", \"done\", \"next\"]\n\nList of callback function names to check for within Promise then and catch methods.\n\ntype: string[]\n\ndefault: []\n\nList of callback function names to allow within Promise then and catch methods.\n\ntype: boolean\n\ndefault: false\n\nBoolean as to whether callbacks in timeout functions like setTimeout will err.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-multiple-resolved": "This rule warns of paths that resolve multiple times in executor functions that Promise constructors.\n\nMultiple resolve/reject calls:\n\n- Violate the Promise/A+ specification\n- Have no effect on the Promise's behavior\n- Make the code's intent unclear\n- May indicate logical errors in the implementation\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-nesting": "Disallow nested then() or catch() statements.\n\nNesting promises makes code harder to read and understand.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis example is not a rule violation as unnesting here would\nresult in a being undefined in the expression getC(a, b).\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-new-statics": "Disallows calling new on static Promise methods.\n\nCalling a static Promise method with new is invalid and will result\nin a TypeError at runtime.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-promise-in-callback": "Disallows the use of Promises within error-first callback functions.\n\nMixing Promises and callbacks can lead to unclear and inconsistent code.\nPromises and callbacks are different patterns for handling asynchronous code.\nMixing them makes the logic flow harder to follow and complicates error handling,\nas callbacks rely on an error-first pattern, while Promises use catch.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-return-in-finally": "Disallow return statements in a finally() callback of a promise.\n\nDisallow return statements inside a callback passed to finally(), since nothing would\nconsume what's returned.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-return-wrap": "Prevents unnecessary wrapping of return values in promises with either Promise.resolve\nor Promise.reject.\n\nThis rule enforces the following stances:\n\n1. When a promise is to be resolved, instead of returning Promise.resolve(value) it is\n   better to return the raw value with return value instead.\n\n2. When a promise is to be rejected, instead of returning Promise.reject(error), instead\n   the raw error value should be thrown as in throw error.\n\nThere is an option to turn off the enforcing of 2, see the options section below.\n\nIt is unnecessary to use Promise.resolve and Promise.reject for converting raw values\nto promises in the return statements of then and catch callbacks. Using these\noperations to convert raw values to promises is unnecessary as simply returning the raw\nvalue for the success case and throwing the raw error value in the failure case have the\nsame effect. This is why some take the opinion that returning values such as\nPromise.resolve(1) or Promise.reject(err) is syntactic noise.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nallowReject allows returning Promise.reject inside a promise handler.\n\nWith allowReject set to true the following are examples of correct code:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "param-names": "Enforce standard parameter names for Promise constructors.\n\nEnsures that new Promise() is instantiated with the parameter names resolve, reject to\navoid confusion with order such as reject, resolve. The Promise constructor uses the\nRevealingConstructor pattern. Using the same parameter names as the language specification\nmakes code more uniform and easier to understand.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string\n\nRegex pattern used to validate the reject parameter name. If provided, this pattern\nis used instead of the default ^?reject$ check.\n\ntype: string\n\nRegex pattern used to validate the resolve parameter name. If provided, this pattern\nis used instead of the default ^?resolve$ check.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-await-to-callbacks": "The rule encourages the use of async/await for handling asynchronous code\ninstead of traditional callback functions. async/await, introduced in ES2017,\nprovides a clearer and more concise syntax for writing asynchronous code,\nmaking it easier to read and maintain.\n\nUsing callbacks can lead to complex, nested structures known as \"callback hell,\"\nwhich make code difficult to read and maintain. Additionally, error handling can\nbecome cumbersome with callbacks, whereas async/await allows for more straightforward\ntry/catch blocks for managing errors.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-await-to-then": "Prefer await to then()/catch()/finally() for reading Promise values\n\nAsync/await syntax can be seen as more readable.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nExamples of incorrect code with { strict: true }:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nIf true, enforces the rule even after an await or yield expression.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-catch": "Prefer catch to then(a, b) and then(null, b). This rule disallows the passing of an\nargument into the second parameter of then calls for handling promise errors.\n\nA then call with two arguments can make it more difficult to recognize that a catch error\nhandler is present. Another issue with using the second argument in then calls is that\nthe ordering of promise error handling is less obvious.\n\nFor example on first glance it may appear that prom.then(fn1, fn2) is equivalent to\nprom.then(fn1).catch(fn2). However they aren't equivalent. In fact\nprom.catch(fn2).then(fn1) is the equivalent. This kind of confusion is a good reason for\npreferring explicit catch calls over passing an argument to the second parameter of\nthen calls.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "spec-only": "Disallow use of non-standard Promise static methods.\n\nNon-standard Promises may cost more maintenance work.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: null\n\nList of Promise static methods that are allowed to be used.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "valid-params": "Enforces the proper number of arguments are passed to Promise functions.\n\nThis rule is generally unnecessary if using TypeScript.\n\nCalling a Promise function with the incorrect number of arguments can lead to unexpected\nbehavior or hard to spot bugs.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>"
  },
  "react": {
    "button-has-type": "Enforces explicit type attribute for all the button HTML elements.\n\nThe default value of type attribute for button HTML element is\n\"submit\" which is often not the desired behavior and may lead to\nunexpected page reloads.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: true\n\nIf true, allow type=\"button\".\n\ntype: boolean\n\ndefault: true\n\nIf true, allow type=\"reset\".\n\ntype: boolean\n\ndefault: true\n\nIf true, allow type=\"submit\".\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "checked-requires-onchange-or-readonly": "This rule enforces onChange or readonly attribute for checked property of input elements.\nIt also warns when checked and defaultChecked properties are used together.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nIgnore the restriction that checked and defaultChecked should not be used together.\n\ntype: boolean\n\ndefault: false\n\nIgnore the requirement to provide either onChange or readOnly when the checked prop is present.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "exhaustive-deps": "Verifies the list of dependencies for Hooks like useEffect and similar.\n\nReact Hooks like useEffect and similar require a list of dependencies to be passed as an argument. This list is used to determine when the effect should be re-run. If the list is missing or incomplete, the effect may run more often than necessary, or not at all.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string\n\ndefault: null\n\nOptionally provide a regex of additional hooks to check.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "forbid-dom-props": "This rule prevents passing of props to elements. This rule only applies to DOM Nodes (e.g. <div />) and not Components (e.g. <Component />). The list of forbidden props can be customized with the forbid option.\n\nThis rule checks all JSX elements and verifies that no forbidden props are used on DOM Nodes. This rule is off by default.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nAn array of strings, with the names of props that are forbidden. The default value of this option [].\nEach array element can either be a string with the property name or object specifying the property name, an optional custom message, and a DOM nodes disallowed list (e.g. <div />)\n\n{\"propName\": \"someProp\", \"disallowedFor\": [\"DOMNode\", \"AnotherDOMNode\"], \"message\": \"Avoid using someProp\" }\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "forbid-elements": "Allows you to configure a list of forbidden elements and to specify their desired replacements.\n\nYou may want to forbid usage of certain elements in favor of others, (e.g. forbid all <div /> and use <Box /> instead)\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "forward-ref-uses-ref": "Requires that components wrapped with forwardRef must have a ref parameter.\nOmitting the ref argument is usually a bug,\nand components not using ref don't need to be wrapped by forwardRef.\n\nOmitting the ref argument makes the forwardRef wrapper unnecessary,\nand can lead to confusion.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "iframe-missing-sandbox": "Enforce sandbox attribute on iframe elements\n\nThe sandbox attribute enables an extra set of restrictions for the\ncontent in the iframe. Using sandbox attribute is considered a good\nsecurity practice. To learn more about sandboxing, see MDN's\ndocumentation on the sandbox\nattribute.\n\nThis rule checks all React <iframe> elements and verifies that there\nis sandbox attribute and that it's value is valid. In addition to that\nit also reports cases where attribute contains allow-scripts and\nallow-same-origin at the same time as this combination allows the\nembedded document to remove the sandbox attribute and bypass the\nrestrictions.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "jsx-boolean-value": "Enforce a consistent boolean attribute style in your code.\n\nIn JSX, you can set a boolean attribute to true or omit it. This rule will enforce a consistent style for boolean attributes.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nIf true, treats prop={false} as equivalent to the prop being undefined\n\ntype: \"always\" | \"never\"\n\ndefault: \"never\"\n\nEnforce boolean attributes to always or never have a value.\n\ntype: string[]\n\ndefault: []\n\nList of attribute names to exclude from the rule.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "jsx-curly-brace-presence": "Disallow unnecessary JSX expressions when literals alone are\nsufficient or enforce JSX expressions on literals in JSX children or\nattributes.\n\nThis rule allows you to enforce curly braces or disallow unnecessary\ncurly braces in JSX props and/or children.\n\nFor situations where JSX expressions are unnecessary, please refer to\nthe React doc\nand this page about JSX\ngotchas.\n\nUsing different styles for your JSX code can make it harder to read and\nless consistent.\n\nCode consistency improves readability. By enforcing or disallowing\ncurly braces in JSX props and/or children, this rule helps maintain\nconsistent patterns across your application.\n\nBy default, this rule will check for and warn about unnecessary curly\nbraces in both JSX props and children. For the sake of backwards\ncompatibility, prop values that are JSX elements are not considered by\ndefault.\n\nYou can pass in options to enforce the presence of curly braces on JSX\nprops, children, JSX prop values that are JSX elements, or any\ncombination of the three. The same options are available for not\nallowing unnecessary curly braces as well as ignoring the check.\n\nNote: it is highly recommended that you configure this rule with\nan object, and that you set \"propElementValues\" to \"always\". The ability\nto omit curly braces around prop values that are JSX elements is\nobscure, and intentionally undocumented, and should not be relied upon.\n\nor alternatively\n\nIf passed in the option to fix, this is how a style violation will get fixed\n\n- always: wrap a JSX attribute in curly braces/JSX expression and/or a JSX child the same way but also with double quotes\n- never: get rid of curly braces from a JSX attribute and/or a JSX child\n\n- All fixing operations use double quotes.\n\nExamples of incorrect code for this rule, when configured with { props: \"always\", children: \"always\" }:\n\nThey can be fixed to:\n\nExamples of incorrect code for this rule, when configured with { props: \"never\", children: \"never\" }:\n\nThey can be fixed to:\n\nExamples of incorrect code for this rule, when configured with { props: \"always\", children: \"always\", \"propElementValues\": \"always\" }:\n\nThey can be fixed to:\n\nExamples of incorrect code for this rule, when configured with { props: \"never\", children: \"never\", \"propElementValues\": \"never\" }:\n\nThey can be fixed to:\n\nExamples of incorrect code for this rule, when configured with \"always\":\n\nThey can be fixed to:\n\nExamples of incorrect code for this rule, when configured with \"never\":\n\nIt can fixed to:\n\nThe fix also deals with template literals, strings with quotes, and\nstrings with escapes characters.\n\n- If the rule is set to get rid of unnecessary curly braces and the\n  template literal inside a JSX expression has no expression, it will\n  throw a warning and be fixed with double quotes. For example:\n\nwill be warned and fixed to:\n\n- If the rule is set to enforce curly braces and the strings have\n  quotes, it will be fixed with double quotes for JSX children and the\n  normal way for JSX attributes. Also, double quotes will be escaped in\n  the fix.\n\nFor example:\n\nwill warned and fixed to:\n\n- If the rule is set to get rid of unnecessary curly braces(JSX\n  expression) and there are characters that need to be escaped in its JSX\n  form, such as quote characters, forbidden JSX text\n  characters, escaped characters and\n  anything that looks like HTML entity names, the code will not be warned\n  because the fix may make the code less readable.\n\nExamples of correct code for this rule, even when configured with \"never\":\n\nYou should turn this rule off if you are not concerned about maintaining\nconsistency regarding the use of curly braces in JSX props and/or\nchildren as well as the use of unnecessary JSX expressions.\n\nThis rule accepts a configuration object with the following properties:\n\ntype: \"always\" | \"never\" | \"ignore\"\n\ndefault: \"never\"\n\nWhether to enforce or disallow curly braces for child content of a JSX element.\n\n- never will disallow unnecessary curly braces, e.g. this will be preferred: <Foo>I love oxlint</Foo>\n- always will force the usage of curly braces like this, in all cases: <Foo>{'I love oxlint'}</Foo>\n- ignore will allow either style for child content.\n\ntype: \"always\" | \"never\" | \"ignore\"\n\ndefault: \"ignore\"\n\nWhen set to ignore or never, this JSX code is allowed (or enforced):\n<App prop=<div /> />;\n\nWhen set to always, the curly braces are required for prop values that are\nJSX elements: <App prop={<div />} />;\n\nNote: it is highly recommended that you set propElementValues to always.\nThe ability to omit curly braces around prop values that are JSX elements is obscure, and\nintentionally undocumented, and should not be relied upon.\n\ntype: \"always\" | \"never\" | \"ignore\"\n\ndefault: \"never\"\n\nWhether to enforce or disallow curly braces for props on JSX elements.\n\n- never will disallow unnecessary curly braces, e.g. this will be preferred: <Foo foo=\"bar\" />\n- always will force the usage of curly braces like this, in all cases: <Foo foo={'bar'} />\n- ignore will allow either style for prop values.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "jsx-filename-extension": "Enforces consistent use of the .jsx file extension.\n\nSome bundlers or parsers need to know by the file extension that it contains JSX\nin order to properly handle the files.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: \"always\" | \"as-needed\"\n\ndefault: \"always\"\n\nWhen to allow a JSX filename extension. By default all files may have a JSX extension.\nSet this to as-needed to only allow JSX file extensions in files that contain JSX syntax.\n\ntype: string[]\n\ndefault: [\"jsx\"]\n\nThe set of allowed file extensions.\nCan include or exclude the leading dot (e.g., \"jsx\" and \".jsx\" are both valid).\n\ntype: boolean\n\ndefault: false\n\nIf enabled, files that do not contain code (i.e. are empty, contain only whitespaces or comments) will not be rejected.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "jsx-fragments": "Enforces the shorthand or standard form for React Fragments.\n\nMakes code using fragments more consistent one way or the other.\n\nThis rule accepts one of the following string values:\n\nThis is the default mode. It will enforce the shorthand syntax for React fragments, with one exception.\nKeys or attributes are not supported by the shorthand syntax, so the rule will not warn on standard-form fragments that use those.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis mode enforces the standard form for React fragments.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "jsx-handler-names": "Ensures that any component or prop methods used to handle events are correctly prefixed.\n\nInconsistent naming of event handlers and props can reduce code readability and maintainability.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhether to check for inline functions in JSX attributes.\n\ntype: boolean\n\ndefault: false\n\nWhether to check for local variables in JSX attributes.\n\ntype: string\n\ndefault: \"handle\"\n\nEvent handler prefixes to check against.\n\ntype: string\n\ndefault: \"on\"\n\nEvent handler prop prefixes to check against.\n\ntype: string\n\nCompiled regex for event handler prop prefixes.\n\ntype: string\n\nCompiled regex for event handler prefixes.\n\ntype: string[]\n\ndefault: []\n\nComponent names to ignore when checking for event handler prefixes.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "jsx-key": "Enforce key prop for elements in array\n\nReact requires a key prop for elements in an array to help identify which items have changed, are added, or are removed.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: true\n\nWhen true, check fragment shorthand <> for keys\n\ntype: boolean\n\ndefault: true\n\nWhen true, require key prop to be placed before any spread props\n\ntype: boolean\n\ndefault: true\n\nWhen true, warn on duplicate key values\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "jsx-max-depth": "Enforces a maximum depth for nested JSX elements and fragments.\n\nExcessively nested JSX makes components harder to read and maintain.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: integer\n\ndefault: 2\n\nThe maximum allowed depth of nested JSX elements and fragments.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "jsx-no-comment-textnodes": "This rule prevents comment strings (e.g. beginning with // or /) from being accidentally injected as a text node in JSX statements.\n\nIn JSX, any text node that is not wrapped in curly braces is considered a literal string to be rendered. This can lead to unexpected behavior when the text contains a comment.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable** this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "jsx-no-duplicate-props": "This rule prevents duplicate props in JSX elements.\n\nHaving duplicate props in a JSX element is most likely a mistake.\nCreating JSX elements with duplicate props can cause unexpected behavior in your application.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule does not support the ignoreCase option. Props with different cases are\nconsidered distinct and will not be flagged as duplicates (e.g., <App foo Foo />\nis allowed). This is intentional, as props are case-sensitive in JSX.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "jsx-no-script-url": "Disallow usage of javascript: URLs.\n\nURLs starting with javascript: are a dangerous attack surface because it’s easy to accidentally\ninclude unsanitized output in a tag like <a href> and create a security hole.\n\nStarting in React 16.9, any URLs starting with javascript: log a warning.\n\nIn React 19, javascript: URLs are\ndisallowed entirely.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: Record<string, array>\n\ndefault: {}\n\nAdditional components to check.\n\ntype: boolean\n\ndefault: false\n\nWhether to include components from settings.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "jsx-no-target-blank": "This rule aims to prevent user generated link hrefs and form actions from creating security vulnerabilities by\nrequiring rel='noreferrer' for external link hrefs and form actions, and optionally any dynamically generated\nlink hrefs and form actions.\n\nWhen creating a JSX element that has an a tag, it is often desired to have the link open in a new tab using the\ntarget='blank' attribute. Using this attribute unaccompanied by rel='noreferrer', however, is a severe security\nvulnerability (see [noreferrer docs] and [noopener docs] for more details).\nThis rules requires that you accompany target='blank' attributes with rel='noreferrer'.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\n[noreferrer docs]: https://html.spec.whatwg.org/multipage/links.html#link-type-noreferrer\n[noopener docs]: https://html.spec.whatwg.org/multipage/links.html#link-type-noopener\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhether to allow referrers.\n\ntype: \"always\" | \"never\"\n\ndefault: \"always\"\n\nWhether to enforce dynamic links or enforce static links.\n\ntype: boolean\n\ndefault: false\n\nWhether to check form elements.\n\ntype: boolean\n\ndefault: true\n\nWhether to check link elements.\n\ntype: boolean\n\ndefault: false\n\nWhether to warn when spread attributes are used.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "jsx-no-undef": "Disallow undeclared variables in JSX\n\nIt is most likely a potential ReferenceError caused by a misspelling of a variable or parameter name.\n\nExamples of incorrect code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "jsx-no-useless-fragment": "Disallow unnecessary fragments.\n\nFragments are a useful tool when you need to group multiple children without adding a\nnode to the DOM tree. However, sometimes you might end up with a fragment with a single\nchild. When this child is an element, string, or expression, it's not necessary to\nuse a fragment.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nAllow fragments with a single expression child.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "jsx-pascal-case": "Enforce PascalCase for user-defined JSX components\n\nIt enforces coding style that user-defined JSX components are defined and referenced in PascalCase. Note that since React's JSX uses the upper vs. lower case convention\nto distinguish between local component classes and HTML tags this rule will not warn on components that start with a lower case letter.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nExamples of correct code for the \"allowAllCaps\" option:\n\nExamples of correct code for the \"allowNamespace\" option:\n\nExamples of correct code for the \"allowLeadingUnderscore\" option:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhether to allow all-caps component names.\n\ntype: boolean\n\ndefault: false\n\nWhether to allow leading underscores in component names.\n\ntype: boolean\n\ndefault: false\n\nWhether to allow namespaced component names.\n\ntype: string[]\n\ndefault: []\n\nList of component names to ignore.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "jsx-props-no-spread-multi": "Enforces that any unique expression is only spread once.\n\nGenerally spreading the same expression twice is an indicator of a mistake since any attribute between the spreads may be overridden when the intent was not to.\nEven when that is not the case this will lead to unnecessary computations being performed.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "jsx-props-no-spreading": "Disallow JSX prop spreading\n\nEnforces that there is no spreading for any JSX attribute. This enhances readability of code by being more explicit about what props are received by the component.\nIt is also good for maintainability by avoiding passing unintentional extra props and allowing react to emit warnings when invalid HTML props are passed to HTML elements.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: \"ignore\" | \"enforce\"\n\ndefault: \"enforce\"\n\ncustom set to ignore will ignore all custom jsx tags like App, MyCustomComponent etc. Default is set to enforce.\n\ntype: string[]\n\ndefault: []\n\nExceptions flip the enforcement behavior for specific components.\nFor example:\n\n- If html is set to ignore, an exception for div will enforce the rule on <div> elements.\n- If custom is set to enforce, an exception for Foo will ignore the rule on <Foo> components.\n\nThis allows you to override the general setting for individual components.\n\ntype: \"ignore\" | \"enforce\"\n\ndefault: \"enforce\"\n\nexplicitSpread set to ignore will ignore spread operators that are explicitly listing all object properties within that spread. Default is set to enforce.\n\ntype: \"ignore\" | \"enforce\"\n\ndefault: \"enforce\"\n\nhtml set to ignore will ignore all html jsx tags like div, img etc. Default is set to enforce.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-array-index-key": "Warn if an element uses an Array index in its key.\n\nIt's a bad idea to use the array index since it doesn't uniquely identify your elements.\nIn cases where the array is sorted or an element is added to the beginning of the array,\nthe index will be changed even though the element representing that index may be the same.\nThis results in unnecessary renders.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-children-prop": "Checks that children are not passed using a prop.\n\nChildren should always be actual children, not passed in as a prop.\nWhen using JSX, the children should be nested between the opening and closing tags.\nWhen not using JSX, the children should be passed as additional arguments to React.createElement.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-danger-with-children": "Disallows when a DOM element is using both children and dangerouslySetInnerHTML properties.\n\nReact will throw a warning if this rule is ignored and both children and dangerouslySetInnerHTML are used.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-danger": "This rule prevents the use of dangerouslySetInnerHTML prop.\n\ndangerouslySetInnerHTML is a way to inject HTML into your React\ncomponent. This is dangerous because it can easily lead to XSS\nvulnerabilities.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-did-mount-set-state": "Disallows using setState in the componentDidMount lifecycle method.\n\nUpdating the state after a component mount will trigger a second render() call and can lead to property/layout thrashing.\nThis can cause performance issues and unexpected behavior.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThe rule accepts a string value \"disallow-in-func\":\n\nWhen set, also disallows setState calls in nested functions within componentDidMount.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-direct-mutation-state": "The restriction coder cannot directly change the value of this.state\n\ncalling setState() afterwards may replace the mutation you made\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-find-dom-node": "This rule disallows the use of findDOMNode.\n\nfindDOMNode is an escape hatch used to access the underlying DOM node.\nIn most cases, use of this escape hatch is discouraged because it pierces the component abstraction.\nIt has been deprecated in StrictMode.\n\nExamples of incorrect code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-is-mounted": "This rule prevents using isMounted in classes.\n\nisMounted is an anti-pattern, is not available when using classes,\nand it is on its way to being officially deprecated.\n\nExamples of incorrect code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-namespace": "Enforce that namespaces are not used in React elements.\n\nNamespaces in React elements, such as svg:circle, are not supported by React.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-redundant-should-component-update": "Disallow usage of shouldComponentUpdate when extending React.PureComponent.\n\nReact.PureComponent automatically implements shouldComponentUpdate with a shallow prop and state comparison.\nDefining shouldComponentUpdate in a class that extends React.PureComponent is redundant and defeats the purpose\nof using React.PureComponent. If you need custom comparison logic, extend React.Component instead.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-render-return-value": "This rule will warn you if you try to use the ReactDOM.render() return value.\n\nUsing the return value from ReactDOM.render() is a legacy feature and should not be used.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-set-state": "Disallow the usage of this.setState in React components.\n\nWhen using an architecture that separates your application state from your UI components\n(e.g. Flux), it may be desirable to forbid the use of local component state. This rule is\nespecially helpful in read-only applications (that don't use forms), since local component\nstate should rarely be necessary in such cases.\n\nExamples of incorrect code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-string-refs": "This rule prevents using string literals in ref attributes.\n\nUsing string literals in ref attributes is deprecated in React.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nDisallow template literals in addition to string literals.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-this-in-sfc": "Prevents using this in stateless functional components.\n\nIn React, stateless functional components (SFCs) receive props and context as function parameters,\nnot through this. Using this in an SFC typically indicates a mistake when converting from\nclass components or unfamiliarity with the two component styles.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-unescaped-entities": "This rule prevents characters that you may have meant as JSX escape characters from being accidentally injected as a text node in JSX statements.\n\nJSX escape characters are used to inject characters into JSX statements that would otherwise be interpreted as code.\n\nIncorrect\n\nCorrect\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-unknown-property": "Disallow usage of unknown DOM properties.\n\nYou can use unknown property name that has no effect.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: []\n\nList of properties to ignore.\n\ntype: boolean\n\ndefault: false\n\nRequire data- attributes to be lowercase, e.g. data-foobar instead of data-fooBar.\n\nTo enable** this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-unsafe": "This rule identifies and restricts the use of unsafe React lifecycle methods.\n\nCertain lifecycle methods (componentWillMount, componentWillReceiveProps, and componentWillUpdate)\nare considered unsafe and have been deprecated since React 16.9. They are frequently misused and cause\nproblems in async rendering. Using their UNSAFE prefixed versions or the deprecated names themselves\nshould be avoided.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhether to check for the non-prefixed lifecycle methods.\nIf true, this means componentWillMount, componentWillReceiveProps,\nand componentWillUpdate will also be flagged, rather than just the\nUNSAFE\\ versions. It is recommended to set this to true to fully\navoid unsafe lifecycle methods.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-will-update-set-state": "Disallows using setState in the componentWillUpdate lifecycle method.\n\nUpdating the state during the component update step can lead to indeterminate component state and is not allowed.\nThis can cause unexpected behavior and bugs in your React application.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "only-export-components": "Ensures that modules only export React components (and related HMR-safe items) so\nthat Fast Refresh (a.k.a. hot reloading) can safely preserve component state.\nConcretely, it validates the shape of your module’s exports and common entrypoints\n(e.g. createRoot(...).render(<App />)) to match what integrations like\nreact-refresh expect. The rule name is react-refresh/only-export-components.\n\nFast Refresh can only reliably retain state if a module exports components and\navoids patterns that confuse the refresh runtime. Problematic patterns (like\nexport , anonymous default functions, exporting arrays of JSX, or mixing\nnon-component exports in unsupported ways) can cause:\n\n- Components to remount and lose state on edit\n- Missed updates (no refresh) or overly broad reloads\n- Fragile HMR behavior that differs between bundlers\n\nBy enforcing predictable exports, edits stay fast and stateful during development.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: null\n\nAllow exporting primitive constants (string/number/boolean/template literal)\nalongside component exports without triggering a violation. Recommended when your\nbundler’s Fast Refresh integration supports this (enabled by the plugin’s vite\npreset).\n\ntype: string[]\n\ndefault: null\n\nTreat specific named exports as HMR-safe (useful for frameworks that hot-replace\ncertain exports). For example, in Remix:\n{ \"allowExportNames\": [\"meta\", \"links\", \"headers\", \"loader\", \"action\"] }\n\ntype: boolean\n\ndefault: null\n\nCheck .js files that contain JSX (in addition to .tsx/.jsx). To reduce\nfalse positives, only files that import React are checked when this is enabled.\n\ntype: string[]\n\ndefault: null\n\nIf you export components wrapped in custom higher-order components, list their\nidentifiers here to avoid false positives.\n\nTo enable** this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-es6-class": "React offers you two ways to create traditional components: using the ES5\ncreate-react-class module or the new ES2015 class system.\n\nThis rule enforces a consistent React class style.\n\nExamples of incorrect code for this rule:\n\nThis rule accepts one of the following string values:\n\nAlways prefer ES6 class-style components\n\nDo not allow ES6 class-style\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "react-in-jsx-scope": "Enforces that React is imported and in-scope when using JSX syntax.\n\nNote that this rule is not necessary on React 17+ if you are using\nthe new JSX Transform, and you can disable this rule and skip importing\nReact in files with JSX syntax.\n\nIf your tsconfig.json has jsx set to react-jsx or react-jsxdev, you are using the new JSX Transform.\nFor JavaScript projects using Babel, you are using the new JSX Transform if your React preset configuration\n(in .babelrc or babel.config.js) has runtime: \"automatic\".\n\nFor more information, see\nthe React blog post on JSX Transform.\n\nWhen using JSX, <a /> expands to React.createElement(\"a\"). Therefore\nthe React variable must be in scope.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "require-render-return": "Enforce ES5 or ES2015 class for returning value in render function\n\nWhen writing the render method in a component it is easy to forget to return the JSX content. This rule will warn if the return statement is missing.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "rules-of-hooks": "Enforces the Rules of Hooks, ensuring that React Hooks are only called\nin valid contexts and in the correct order.\n\nReact Hooks must follow specific rules to ensure they work correctly:\n\n1. Only call Hooks at the top level (never inside loops, conditions,\n   or nested functions)\n2. Only call Hooks from React function components or custom Hooks\n3. Hooks must be called in the same order every time a component renders\n\nBreaking these rules can lead to bugs where state gets corrupted or\ncomponent behavior becomes unpredictable.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "self-closing-comp": "Detects components without children which can be self-closed to avoid\nunnecessary extra closing tags.\n\nComponents without children don't need explicit closing tags. Using\nself-closing syntax makes code more concise and reduces visual clutter.\nIt also follows common React and JSX conventions for empty elements.\n\nA self-closing component which contains whitespace is allowed except\nwhen it also contains a newline.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: true\n\nWhether to enforce self-closing for custom components.\n\ntype: boolean\n\ndefault: true\n\nWhether to enforce self-closing for native HTML elements.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "state-in-constructor": "Enforces the state initialization style to be either in a constructor or with a class property.\n\nInconsistent state initialization styles can make the codebase harder to maintain and understand.\nThis rule enforces a consistent pattern across React class components.\n\nThis rule has two modes: \"always\" and \"never\".\n\nWill enforce the state initialization style to be in a constructor. This is the default mode.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nWill enforce the state initialization style to be with a class property.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts one of the following string values:\n\nEnforce state initialization in the constructor.\n\nEnforce state initialization with a class property.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "style-prop-object": "Require that the value of the prop style be an object or a variable that is an object.\n\nThe style prop expects an object mapping from style properties to values when using JSX.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: []\n\nList of component names on which to allow style prop values of any type.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "void-dom-elements-no-children": "Disallow void DOM elements (e.g. <img />, <br />) from receiving children.\n\nThere are some HTML elements that are only self-closing (e.g. img, br, hr). These are collectively known as void DOM elements.\nThis rule checks that children are not passed to void DOM elements.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>"
  },
  "react_perf": {
    "jsx-no-jsx-as-prop": "Prevent JSX elements that are local to the current method from being\nused as values of JSX props.\n\nUsing locally defined JSX elements as values for props can lead to\nunintentional re-renders and performance issues. Every time the parent\nrenders, a new instance of the JSX element is created, causing unnecessary\nre-renders of child components. This also leads to harder-to-maintain code\nas the component's props are not passed consistently.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "jsx-no-new-array-as-prop": "Prevent Arrays that are local to the current method from being used\nas values of JSX props.\n\nUsing locally defined Arrays as values for props can lead to unintentional\nre-renders and performance issues. Every time the parent component renders,\na new instance of the Array is created, causing unnecessary re-renders of\nchild components. This also leads to harder-to-maintain code as the\ncomponent's props are not passed consistently.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "jsx-no-new-function-as-prop": "Prevent Functions that are local to the current method from being used\nas values of JSX props.\n\nUsing locally defined Functions as values for props can lead to unintentional\nre-renders and performance issues. Every time the parent component renders,\na new instance of the Function is created, causing unnecessary re-renders\nof child components. This also leads to harder-to-maintain code as the\ncomponent's props are not passed consistently.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "jsx-no-new-object-as-prop": "Prevent Objects that are local to the current method from being used\nas values of JSX props.\n\nUsing locally defined Objects as values for props can lead to unintentional\nre-renders and performance issues. Every time the parent component renders,\na new instance of the Object is created, causing unnecessary re-renders of\nchild components. This also leads to harder-to-maintain code as the\ncomponent's props are not passed consistently.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>"
  },
  "typescript": {
    "adjacent-overload-signatures": "Require that function overload signatures be consecutive.\n\nFunction overload signatures represent multiple ways\na function can be called, potentially with different return types.\nIt's typical for an interface or type alias describing a function to place all overload signatures next to each other.\nIf Signatures placed elsewhere in the type are easier to be missed by future developers reading the code.\n\nExamples of incorrect code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "array-type": "Require consistently using either T[] or Array<T> for arrays.\n\nUsing the Array type directly is not idiomatic. Instead, use the array type T[] or Array<T>.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: \"array\" | \"array-simple\" | \"generic\"\n\ndefault: \"array\"\n\nThe array type expected for mutable cases.\n\ntype: \"array\" | \"array-simple\" | \"generic\"\n\ndefault: null\n\nThe array type expected for readonly cases. If omitted, the value for default will be used.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "await-thenable": "This rule disallows awaiting a value that is not a Thenable.\n\nWhile it is valid JavaScript to await a non-Promise-like value (it will resolve immediately), this practice can be confusing for readers who are not aware of this behavior. It can also be a sign of a programmer error, such as forgetting to add parentheses to call a function that returns a Promise.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "ban-ts-comment": "This rule lets you set which directive comments you want to allow in your codebase.\n\nUsing TypeScript directives to suppress TypeScript compiler errors\nreduces the effectiveness of TypeScript overall.\n\nExamples of incorrect code for this rule:\n\nThis rule allows you to specify how different TypeScript directive comments\nshould be handled.\n\nFor each directive (@ts-expect-error, @ts-ignore, @ts-nocheck, @ts-check), you can choose one of the following options:\n\n- true: Disallow the directive entirely, preventing its use in the entire codebase.\n- false: Allow the directive without any restrictions.\n- \"allow-with-description\": Allow the directive only if it is followed by a description explaining its use. The description must meet the minimum length specified by minimumDescriptionLength.\n- { \"descriptionFormat\": \"<regex>\" }: Allow the directive only if the description matches the specified regex pattern.\n\nFor example:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: integer\n\ndefault: 3\n\nMinimum description length required when using directives with allow-with-description.\n\nHow to handle the @ts-check directive.\n\nHow to handle the @ts-expect-error directive.\n\nHow to handle the @ts-ignore directive.\n\nHow to handle the @ts-nocheck directive.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "ban-tslint-comment": "This rule disallows tslint:<rule-flag> comments\n\nUseful when migrating from TSLint to ESLint. Once TSLint has been\nremoved, this rule helps locate TSLint annotations\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "ban-types": "This rule bans specific types and can suggest alternatives. Note that it does not ban the corresponding runtime objects from being used.\n\nSome built-in types have aliases, while some types are considered dangerous or harmful. It's often a good idea to ban certain types to help with consistency and safety.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "consistent-generic-constructors": "When constructing a generic class, you can specify the type arguments on either the left-hand side (as a type annotation) or the right-hand side (as part of the constructor call).\n\nThis rule enforces consistency in the way generic constructors are used.\n\nInconsistent usage of generic constructors can make the code harder to read and maintain.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: \"constructor\" | \"type-annotation\"\n\ndefault: \"constructor\"\n\nSpecifies where the generic type should be specified.\n\nPossible values:\n\n- \"constructor\" (default): Type arguments that only appear on the type annotation are disallowed.\n- \"type-annotation\": Type arguments that only appear on the constructor are disallowed.\n\nType arguments that only appear on the type annotation are disallowed.\n\nType arguments that only appear on the constructor are disallowed.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "consistent-indexed-object-style": "Choose between requiring either Record type or indexed signature types.\n\nThese two types are equivalent, this rule enforces consistency in picking one style over the other:\n\nInconsistent style for indexed object types can harm readability in a project.\n\nExamples of incorrect code for this rule with\nconsistent-indexed-object-style: [\"error\", \"record\"] (default):\n\nExamples of correct code for this rule with\nconsistent-indexed-object-style: [\"error\", \"record\"] (default):\n\nExamples of incorrect code for this rule with\nconsistent-indexed-object-style: [\"error\", \"index-signature\"]:\n\nExamples of correct code for this rule with\nconsistent-indexed-object-style: [\"error\", \"index-signature\"]:\n\nThis rule accepts one of the following string values:\n\nWhen set to record, enforces the use of a Record for indexed object types, e.g. Record<string, unknown>.\n\nWhen set to index-signature, enforces the use of indexed signature types, e.g. { [key: string]: unknown }.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "consistent-type-definitions": "Enforce type definitions to consistently use either interface or type.\n\nTypeScript provides two common ways to define an object type: interface and type.\nThe two are generally very similar, and can often be used interchangeably.\nUsing the same type declaration style consistently helps with code readability.\n\nBy default this rule enforces the use of interface for defining object types.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts one of the following string values:\n\nPrefer interface over type for object type definitions:\n\nPrefer type over interface for object type definitions:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "consistent-type-imports": "Enforce consistent usage of type imports.\n\nInconsistent usage of type imports can make the code harder to read and understand.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nExamples of incorrect code:\n\nExamples of correct code:\n\nExamples of incorrect code:\n\nExamples of correct code:\n\nWhen fixing type imports, this option will use inline type modifiers:\n\nWhen set to false, allows import() type annotations:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: true\n\nDisallow using import() in type annotations, like type T = import('foo')\n\ntype: \"separate-type-imports\" | \"inline-type-imports\"\n\ndefault: \"separate-type-imports\"\n\nControl how type imports are added when auto-fixing.\n\nWill add the type keyword after the import keyword import type { A } from '...'\n\nWill inline the type keyword import { type A } from '...' (only available in TypeScript 4.5+)\n\ntype: \"type-imports\" | \"no-type-imports\"\n\ndefault: \"type-imports\"\n\nControl whether to enforce type imports or value imports.\n\nWill enforce that you always use import type Foo from '...' except referenced by metadata of decorators.\n\nWill enforce that you always use import Foo from '...'\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "explicit-function-return-type": "This rule enforces that functions have an explicit return type annotation.\n\nExplicit return types make it clearer what type is returned by a function. Making the\ntype returned by a function obvious allows the reader to infer what the function does\nand how it can be used from a quick glance.\n\nAnother benefit of explicit return types is the potential for a speed up of type\nchecking in large codebases with many large functions.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhether to allow concise arrow functions that start with the void keyword.\n\ntype: boolean\n\ndefault: true\n\nWhether to allow arrow functions that use as const assertion on their return value.\n\ntype: boolean\n\ndefault: false\n\nWhether to allow expressions as function return types. When true, allows functions that immediately return an expression without a return type annotation.\n\ntype: boolean\n\ndefault: false\n\nWhether to allow functions that do not have generic type parameters.\n\ntype: boolean\n\ndefault: true\n\nWhether to allow higher-order functions (functions that return another function) without return type annotations.\n\ntype: boolean\n\ndefault: false\n\nWhether to allow immediately invoked function expressions (IIFEs) without return type annotations.\n\ntype: boolean\n\ndefault: true\n\nWhether to allow typed function expressions. When true, allows function expressions that are assigned to a typed variable or parameter.\n\ntype: string[]\n\ndefault: []\n\nArray of function names that are exempt from requiring return type annotations.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "explicit-module-boundary-types": "Require explicit return and argument types on exported functions' and classes' public class methods.\n\nExplicit types for function return values and arguments makes it clear\nto any calling code what is the module boundary's input and output.\nAdding explicit type annotations for those types can help improve code\nreadability. It can also improve TypeScript type checking performance on\nlarger codebases.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhether to ignore arguments that are explicitly typed as any.\n\ntype: boolean\n\ndefault: true\n\nWhether to ignore return type annotations on body-less arrow functions\nthat return an as const type assertion. You must still type the\nparameters of the function.\n\ntype: boolean\n\ndefault: true\n\nWhether to ignore return type annotations on functions immediately\nreturning another function expression. You must still type the\nparameters of the function.\n\ntype: boolean\n\ndefault: false\n\nWhether to ignore return type annotations on functions with overload\nsignatures.\n\ntype: boolean\n\ndefault: true\n\nWhether to ignore type annotations on the variable of a function\nexpression.\n\ntype: string[]\n\ndefault: []\n\nAn array of function/method names that will not have their arguments or\nreturn values checked.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-array-delete": "This rule disallows using the delete operator on array values.\n\nWhen using the delete operator on an array, the element is not actually removed, but instead the array slot is turned into undefined. This is usually not the intended behavior. Instead, you should use methods like Array.prototype.splice() to properly remove elements from an array.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "no-base-to-string": "This rule requires toString() and toLocaleString() calls to only be called on objects which provide useful information when stringified.\n\nJavaScript's toString() method returns '[object Object]' on plain objects, which is not useful information. This rule prevents toString() and toLocaleString() from being called on objects that return less useful strings.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhether to also check values of type unknown.\nWhen true, calling toString on unknown values will be flagged.\nDefault is false.\n\ntype: string[]\n\ndefault: [\"Error\", \"RegExp\", \"URL\", \"URLSearchParams\"]\n\nA list of type names to ignore when checking for unsafe toString usage.\nThese types are considered safe to call toString on even if they don't\nprovide a custom implementation.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "no-confusing-non-null-assertion": "Disallow non-null assertion in locations that may be confusing.\n\nUsing a non-null assertion (!) next to an assign or equals check (= or == or ===) creates code that is confusing as it looks similar to a not equals check (!= !==).\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-confusing-void-expression": "This rule forbids using void expressions in confusing locations such as arrow function returns.\n\nThe void operator is useful when you want to execute an expression while evaluating to undefined. However, it can be confusing when used in places where the return value is meaningful, particularly in arrow functions and conditional expressions.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhether to ignore arrow function shorthand that returns void.\nWhen true, allows expressions like () => someVoidFunction().\n\ntype: boolean\n\ndefault: false\n\nWhether to ignore expressions using the void operator.\nWhen true, allows void someExpression.\n\ntype: boolean\n\ndefault: false\n\nWhether to ignore calling functions that are declared to return void.\nWhen true, allows expressions like x = voidReturningFunction().\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "no-deprecated": "Disallow using code marked as @deprecated.\n\nThe JSDoc @deprecated tag can be used to document some piece of code\nbeing deprecated. It's best to avoid using code marked as deprecated.\nThis rule reports on any references to code marked as @deprecated.\n\nTypeScript recognizes the @deprecated tag, allowing editors to visually\nindicate deprecated code — usually with a strikethrough. However, TypeScript\ndoesn't report type errors for deprecated code on its own.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: array\n\ndefault: []\n\nAn array of type or value specifiers that are allowed to be used even if deprecated.\nUse this to allow specific deprecated APIs that you intentionally want to continue using.\n\ntype: string\n\nType or value specifier for matching specific declarations\n\nSupports four types of specifiers:\n\n1. String specifier (deprecated): Universal match by name\n\n2. File specifier: Match types/values declared in local files\n\n3. Lib specifier: Match TypeScript built-in lib types\n\n4. Package specifier: Match types/values from npm packages\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "no-duplicate-enum-values": "Disallow duplicate enum member values.\n\nAlthough TypeScript supports duplicate enum member values, people\nusually expect members to have unique values within the same enum.\nDuplicate values can lead to bugs that are hard to track down.\n\nThis rule disallows defining an enum with multiple members initialized\nto the same value. Members without initializers will not be checked.\n\nExample of incorrect code:\n\nExample of correct code:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-duplicate-type-constituents": "This rule disallows duplicate constituents of union or intersection types.\n\nDuplicate constituents in union and intersection types serve no purpose and can make code harder to read. They are likely a mistake.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhether to ignore duplicate types in intersection types.\nWhen true, allows type T = A & A.\n\ntype: boolean\n\ndefault: false\n\nWhether to ignore duplicate types in union types.\nWhen true, allows type T = A | A.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "no-dynamic-delete": "Disallow using the delete operator on computed key expressions.\n\nDeleting dynamically computed keys can be dangerous and in some cases not well optimized.\nUsing the delete operator on keys that aren't runtime constants could be a sign that you're using the wrong data structures.\nConsider using a Map or Set if you’re using an object as a key-value collection.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-empty-interface": "Disallow the declaration of empty interfaces.\n\nAn empty interface in TypeScript does very little: any non-nullable value is assignable to {}.\nUsing an empty interface is often a sign of programmer error, such as misunderstanding the concept of {} or forgetting to fill in fields.\nThis rule aims to ensure that only meaningful interfaces are declared in the code.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhen set to true, allows empty interfaces that extend a single interface.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-empty-object-type": "To avoid confusion around the {} type allowing any non-nullish value, this rule bans usage of the {} type. That includes interfaces and object type aliases with no fields.\n\nThe {}, or \"empty object\" type in TypeScript is a common source of confusion for developers unfamiliar with TypeScript's structural typing. {} represents any non-nullish value, including literals like 0 and \"\".\nOften, developers writing {} actually mean either:\n\n- object: representing any object value\n- unknown: representing any value at all, including null and undefined\n  In other words, the \"empty object\" type {} really means \"any value that is defined\". That includes arrays, class instances, functions, and primitives such as string and symbol.\n\nNote that this rule does not report on:\n\n- {} as a type constituent in an intersection type (e.g. types like TypeScript's built-in type NonNullable<T> = T & {}), as this can be useful in type system operations.\n- Interfaces that extend from multiple other interfaces.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: \"never\" | \"always\" | \"with-single-extends\"\n\ndefault: \"never\"\n\nWhether to allow empty interfaces.\n\nAllowed values are:\n\n- 'always': to always allow interfaces with no fields\n- 'never' (default): to never allow interfaces with no fields\n- 'with-single-extends': to allow empty interfaces that extend from a single base interface\n\nExamples of correct code for this rule with { allowInterfaces: 'with-single-extends' }:\n\ntype: \"never\" | \"always\"\n\ndefault: \"never\"\n\nWhether to allow empty object type literals.\n\nAllowed values are:\n\n- 'always': to always allow object type literals with no fields\n- 'never' (default): to never allow object type literals with no fields\n\ntype: string\n\nA stringified regular expression to allow interfaces and object type aliases with the configured name.\n\nThis can be useful if your existing code style includes a pattern of declaring empty types with {} instead of object.\n\nExample of incorrect code for this rule with { allowWithName: 'Props$' }:\n\nExample of correct code for this rule with { allowWithName: 'Props$' }`:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-explicit-any": "Disallows explicit use of the any type.\n\nThe any type in TypeScript is a dangerous \"escape hatch\" from the type system. Using\nany disables many type checking rules and is generally best used only as a last resort or\nwhen prototyping code. This rule reports on explicit uses of the any keyword as a type\nannotation.\n\n> TypeScript's --noImplicitAny compiler option prevents an implied any, but doesn't\n> prevent any from being explicitly used the way this rule does.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhether to enable auto-fixing in which the any type is converted to the unknown type.\n\ntype: boolean\n\ndefault: false\n\nWhether to ignore rest parameter arrays.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-extra-non-null-assertion": "Disallow extra non-null assertions.\n\nThe ! non-null assertion operator in TypeScript is used to assert that a value's type\ndoes not include null or undefined. Using the operator any more than once on a single value\ndoes nothing.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-extraneous-class": "This rule reports when a class has no non-static members, such as for a\nclass used exclusively as a static namespace. This rule also reports\nclasses that have only a constructor and no fields. Those classes can\ngenerally be replaced with a standalone function.\n\nUsers who come from a OOP paradigm may wrap their utility functions in\nan extra class, instead of putting them at the top level of an\nECMAScript module. Doing so is generally unnecessary in JavaScript and\nTypeScript projects.\n\n- Wrapper classes add extra cognitive complexity to code without adding\n  any structural improvements\n  - Whatever would be put on them, such as utility functions, are already\n    organized by virtue of being in a module.\n  - As an alternative, you can import  as ... the module to get all of them\n    in a single object.\n- IDEs can't provide as good suggestions for static class or namespace\n  imported properties when you start typing property names\n- It's more difficult to statically analyze code for unused variables,\n  etc. when they're all on the class (see: Finding dead code (and dead\n  types) in TypeScript).\n\nThis rule also reports classes that have only a constructor and no\nfields. Those classes can generally be replaced with a standalone\nfunction.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nAllow classes that only have a constructor.\n\ntype: boolean\n\ndefault: false\n\nAllow empty classes.\n\ntype: boolean\n\ndefault: false\n\nAllow classes with only static members.\n\ntype: boolean\n\ndefault: false\n\nAllow classes with decorators.\n\nTo enable** this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-floating-promises": "This rule disallows \"floating\" Promises in TypeScript code, which is a Promise that is created without any code to handle its resolution or rejection.\n\nThis rule will report Promise-valued statements that are not treated in one of the following ways:\n\n- Calling its .then() with two arguments\n- Calling its .catch() with one argument\n- awaiting it\n- returning it\n- voiding it\n\nThis rule also reports when an Array containing Promises is created and not properly handled. The main way to resolve this is by using one of the Promise concurrency methods to create a single Promise, then handling that according to the procedure above. These methods include:\n\n- Promise.all()\n- Promise.allSettled()\n- Promise.any()\n- Promise.race()\n\nFloating Promises can cause several issues, such as improperly sequenced operations, ignored Promise rejections, and more.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: array\n\ndefault: []\n\nAllows specific calls to be ignored, specified as type or value specifiers.\n\ntype: string\n\nType or value specifier for matching specific declarations\n\nSupports four types of specifiers:\n\n1. String specifier (deprecated): Universal match by name\n\n2. File specifier: Match types/values declared in local files\n\n3. Lib specifier: Match TypeScript built-in lib types\n\n4. Package specifier: Match types/values from npm packages\n\ntype: array\n\ndefault: []\n\nAllows specific Promise types to be ignored, specified as type or value specifiers.\n\ntype: string\n\nType or value specifier for matching specific declarations\n\nSupports four types of specifiers:\n\n1. String specifier (deprecated): Universal match by name\n\n2. File specifier: Match types/values declared in local files\n\n3. Lib specifier: Match TypeScript built-in lib types\n\n4. Package specifier: Match types/values from npm packages\n\ntype: boolean\n\ndefault: false\n\nCheck for thenable objects that are not necessarily Promises.\n\ntype: boolean\n\ndefault: false\n\nIgnore immediately invoked function expressions (IIFEs).\n\ntype: boolean\n\ndefault: true\n\nIgnore Promises that are void expressions.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "no-for-in-array": "This rule disallows iterating over an array with a for-in loop.\n\nA for-in loop iterates over the enumerable properties of an object, which includes the array indices, but also includes any enumerable properties added to the array prototype or the array instance. This is almost never what you want when iterating over an array.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "no-implied-eval": "This rule disallows the use of eval-like methods.\n\nIt's considered a good practice to avoid using eval() in JavaScript. There are security and performance implications involved with doing so, which is why many linters recommend disallowing eval(). However, there are some other ways to pass a string and have it interpreted as JavaScript code that have similar concerns.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "no-import-type-side-effects": "Enforce the use of top-level import type qualifier when an import only\nhas specifiers with inline type qualifiers.\n\nThe --verbatimModuleSyntax compiler option causes TypeScript to do\nsimple and predictable transpilation on import declarations. Namely, it\ncompletely removes import declarations with a top-level type qualifier,\nand it removes any import specifiers with an inline type qualifier.\n\nThe latter behavior does have one potentially surprising effect in that\nin certain cases TS can leave behind a \"side effect\" import at runtime:\n\nis transpiled to\n\nFor the rare case of needing to import for side effects, this may be\ndesirable - but for most cases you will not want to leave behind an\nunnecessary side effect import.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-inferrable-types": "Disallow explicit type declarations for variables or parameters initialized to a number, string, or boolean\n\nExplicitly typing variables or parameters that are initialized to a literal value is unnecessary because TypeScript can infer the type from the value.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhen set to true, ignores type annotations on function parameters.\n\ntype: boolean\n\ndefault: false\n\nWhen set to true, ignores type annotations on class properties.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-meaningless-void-operator": "This rule disallows the void operator when its argument is already of type void or undefined.\n\nThe void operator is useful when you want to execute an expression and force it to evaluate to undefined. However, using void on expressions that are already of type void or undefined is meaningless and adds unnecessary complexity to the code.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhether to check void applied to expressions of type never.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "no-misused-new": "Enforces valid definition of new and constructor. This rule prevents classes from defining\na method named new and interfaces from defining a method named constructor.\n\nJavaScript classes may define a constructor method that runs\nwhen a class instance is newly created.\n\nTypeScript allows interfaces that describe a static class object to\ndefine a new() method (though this is rarely used in real world code).\nDevelopers new to JavaScript classes and/or TypeScript interfaces may\nsometimes confuse when to use constructor or new.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-misused-promises": "This rule forbids providing Promises to logical locations such as if statements in places where the TypeScript\ncompiler allows them but they are not handled properly. These situations can often arise due to a missing\nawait keyword or just a misunderstanding of the way async functions are handled/awaited.\n\nMisused promises can cause crashes or other unexpected behavior, unless there are possibly some global unhandled promise handlers registered.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: true\n\nWhether to check if Promises are used in conditionals.\nWhen true, disallows using Promises in conditions where a boolean is expected.\n\ntype: boolean\n\ndefault: true\n\nWhether to check if Promises are used in spread syntax.\nWhen true, disallows spreading Promise values.\n\ntype: object | boolean\n\ntype: boolean\n\ndefault: true\n\nWhether to check Promise-returning functions passed as arguments to void-returning functions.\n\ntype: boolean\n\ndefault: true\n\nWhether to check Promise-returning functions in JSX attributes expecting void.\n\ntype: boolean\n\ndefault: true\n\nWhether to check Promise-returning methods that override void-returning inherited methods.\n\ntype: boolean\n\ndefault: true\n\nWhether to check Promise-returning functions assigned to object properties expecting void.\n\ntype: boolean\n\ndefault: true\n\nWhether to check Promise values returned from void-returning functions.\n\ntype: boolean\n\ndefault: true\n\nWhether to check Promise-returning functions assigned to variables typed as void-returning.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "no-misused-spread": "This rule disallows spreading syntax in places where it doesn't make sense or could cause runtime errors.\n\nThe spread operator can be misused in ways that might not be immediately obvious but can cause runtime errors or unexpected behavior. This rule helps catch common misuses.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: array\n\ndefault: []\n\nAn array of type or value specifiers that are allowed to be spread\neven if they would normally be flagged as misused.\n\ntype: string\n\nType or value specifier for matching specific declarations\n\nSupports four types of specifiers:\n\n1. String specifier (deprecated): Universal match by name\n\n2. File specifier: Match types/values declared in local files\n\n3. Lib specifier: Match TypeScript built-in lib types\n\n4. Package specifier: Match types/values from npm packages\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "no-mixed-enums": "This rule disallows enums from having both string and numeric members.\n\nTypeScript enums can have string, numeric, or computed members. Having mixed string and numeric members in the same enum can lead to confusion and unexpected runtime behavior due to how TypeScript compiles enums.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "no-namespace": "Disallow TypeScript namespaces.\n\nTypeScript historically allowed a form of code organization called \"custom modules\" (module Example {}),\nlater renamed to \"namespaces\" (namespace Example). Namespaces are an outdated way to organize TypeScript code.\nES2015 module syntax is now preferred (import/export).\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhether to allow declare with custom TypeScript namespaces.\n\nExamples of incorrect code for this rule when { \"allowDeclarations\": true }\n\nExamples of correct code for this rule when { \"allowDeclarations\": true }\n\nExamples of incorrect code for this rule when { \"allowDeclarations\": false }\n\nExamples of correct code for this rule when { \"allowDeclarations\": false }\n\ntype: boolean\n\ndefault: true\n\nExamples of incorrect code for this rule when { \"allowDefinitionFiles\": true }\n\nExamples of correct code for this rule when { \"allowDefinitionFiles\": true }\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-non-null-asserted-nullish-coalescing": "Disallow non-null assertions in the left operand of a nullish coalescing operator.\n\nThe ?? nullish coalescing runtime operator allows providing a default value when dealing\nwith null or undefined. Using a ! non-null assertion type operator in the left operand of\na nullish coalescing operator is redundant, and likely a sign of programmer error or\nconfusion over the two operators.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-non-null-asserted-optional-chain": "Disallow non-null assertions after an optional chain expression.\n\nBy design, optional chain expressions (?.) provide undefined as the expression's value, if the object being\naccessed is null or undefined, instead of throwing an error. Using a non-null assertion (!) to assert the\nresult of an optional chain expression is contradictory and likely wrong, as it indicates the code is both expecting\nthe value to be potentially null or undefined and non-null at the same time.\n\nIn most cases, either:\n\n1. The object is not nullable and did not need the ?. for its property lookup\n2. The non-null assertion is incorrect and introduces a type safety hole.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-non-null-assertion": "Disallow non-null assertions using the ! postfix operator.\n\nTypeScript's ! non-null assertion operator asserts to the type system that an expression is non-nullable, as in not null or undefined. Using assertions to tell the type system new information is often a sign that code is not fully type-safe. It's generally better to structure program logic so that TypeScript understands when values may be nullable.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-redundant-type-constituents": "This rule disallows type constituents of unions and intersections that are redundant.\n\nSome constituents of union and intersection types can be redundant due to TypeScript's type system rules. These redundant constituents don't add any value and can make types harder to read and understand.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "no-require-imports": "Forbids the use of CommonJS require calls.\n\nrequire imports, while functional in Node.js and older JavaScript environments, are generally\nconsidered less desirable than ES modules (import) for several key reasons in modern JavaScript development:\n\n1. Static vs. Dynamic: require is a runtime function. It executes when the code runs, which means errors related to missing modules or incorrect paths are only discovered during runtime. ES modules (import) are static imports. Their resolution and potential errors are checked during the compilation or bundling process, making them easier to catch during development.\n\n2. Code Organization and Readability: require statements are scattered throughout the code, potentially making it harder to quickly identify the dependencies of a given module. import statements are typically grouped at the top of a file, improving code organization and readability.\n\n3. Tree Shaking and Optimization: Modern bundlers like Webpack and Rollup use tree-shaking to remove unused code from the final bundle. Tree-shaking works significantly better with ES modules because their dependencies are declared statically and explicitly. require makes it harder for bundlers to accurately identify and remove unused code, resulting in larger bundle sizes and slower load times.\n\n4. Cyclic Dependencies: Handling cyclic dependencies (where module A imports B, and B imports A) is significantly more challenging with require. ES modules, through their declarative nature and the use of dynamic imports (import()), provide better mechanisms to handle cyclic imports and manage asynchronous loading.\n\n5. Maintainability and Refactoring: Changing module names or paths is simpler with ES modules because the changes are declared directly and the compiler or bundler catches any errors. With require, you might have to track down all instances of a specific require statement for a particular module, making refactoring more error-prone.\n\n6. Modern JavaScript Standards: import is the standard way to import modules in modern JavaScript, aligned with current best practices and language specifications. Using require necessitates additional build steps or tools to translate it to a format that the browser or modern JavaScript environments can understand.\n\n7. Error Handling: ES modules provide a more structured way to handle errors during module loading using try...catch blocks with dynamic imports, enhancing error management. require errors can be less predictable.\n\nIn summary, while require works, the benefits of ES modules in terms of static analysis, better bundling, improved code organization, and easier maintainability make it the preferred method for importing modules in modern JavaScript projects.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: []\n\nThese strings will be compiled into regular expressions with the u flag and be used to test against the imported path.\nA common use case is to allow importing package.json. This is because package.json commonly lives outside of the TS root directory,\nso statically importing it would lead to root directory conflicts, especially with resolveJsonModule enabled.\nYou can also use it to allow importing any JSON if your environment doesn't support JSON modules, or use it for other cases where import statements cannot work.\n\nWith { allow: ['/package\\\\.json$'] }:\n\nExamples of correct code for this rule:\n\ntype: boolean\n\ndefault: false\n\nWhen set to true, import ... = require(...) declarations won't be reported.\nThis is useful if you use certain module options that require strict CommonJS interop semantics.\n\nWhen set to true:\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-restricted-types": "Disallow certain types from being used.\n\nSome built-in types have aliases, while some types are considered dangerous or harmful.\nIt's often a good idea to ban certain types to help with consistency and safety.\n\nGiven { \"types\": { \"Foo\": { \"message\": \"Use Bar instead\", \"fixWith\": \"Bar\" } } }:\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nOther examples of configuration option setups for this rule:\n\n- Banning the Foo type with just a message, no fixes or suggestions:\n  { \"types\": { \"Foo\": \"Use OtherType instead.\" } }\n\n- Banning Bar type with suggestion:\n  { \"types\": { \"Bar\": { \"message\": \"Avoid using Bar.\", \"suggest\": \"BazQux\" } } }\n\n- Banning Object type with a generic message:\n  { \"types\": { \"Object\": true } }\n\nThis rule accepts a configuration object with the following properties:\n\ntype: object\n\ndefault: {}\n\nA mapping of type names to ban configurations.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-this-alias": "Disallow aliasing this\n\nAssigning a variable to this instead of properly using arrow lambdas may be a symptom of pre-ES2015 practices or not managing scope well.\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: true\n\nWhether to allow destructuring of this to local variables.\n\ntype: string[]\n\ndefault: []\n\nAn array of variable names that are allowed to alias this.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-unnecessary-boolean-literal-compare": "This rule disallows unnecessary equality comparisons with boolean literals.\n\nComparing boolean values to boolean literals is unnecessary when the comparison can be eliminated. These comparisons make code more verbose without adding value.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: true\n\nWhether to allow comparing nullable boolean expressions to false.\nWhen false, x === false where x is boolean | null will be flagged.\n\ntype: boolean\n\ndefault: true\n\nWhether to allow comparing nullable boolean expressions to true.\nWhen false, x === true where x is boolean | null will be flagged.\n\ntype: boolean\n\ndefault: false\n\nWhether to allow this rule to run without strictNullChecks enabled.\nThis is not recommended as the rule may produce incorrect results.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "no-unnecessary-parameter-property-assignment": "Prevents unnecessary assignment of parameter properties.\n\nConstructor parameters marked with one of the visibility modifiers\npublic, private, protected, or readonly are automatically initialized.\nProviding an explicit assignment is unnecessary and can be removed.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-unnecessary-template-expression": "Disallows unnecessary template expressions (interpolations) that can be simplified.\n\nTemplate literals with substitution expressions that are unnecessary add complexity\nwithout providing any benefit. Static string literal expressions or expressions that\nare already strings can be simplified.\n\nNote: This rule does not flag template literals without substitution expressions.\nFor example, ` hello  is allowed even though it could be written as 'hello'`.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "no-unnecessary-type-arguments": "This rule disallows type arguments that are identical to the default type parameter.\n\nExplicit type arguments that are the same as their default values are unnecessary and add visual noise to the code. TypeScript will infer these types automatically.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "no-unnecessary-type-assertion": "This rule disallows type assertions that do not change the type of an expression.\n\nType assertions that don't actually change the type of an expression are unnecessary and can be safely removed. They add visual noise without providing any benefit and may indicate confusion about TypeScript's type system.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhether to check literal const assertions like 'foo' as const.\nWhen false (default), const assertions on literal types are not flagged.\nWhen true, these will be reported as unnecessary since the type is already a literal.\n\ntype: string[]\n\ndefault: []\n\nA list of type names to ignore when checking for unnecessary assertions.\nType assertions to these types will not be flagged even if they appear unnecessary.\nExample: [\"Foo\", \"Bar\"] to allow x as Foo or x as Bar.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "no-unnecessary-type-constraint": "Disallow unnecessary constraints on generic types.\n\nGeneric type parameters (<T>) in TypeScript may be \"constrained\" with an extends\nkeyword. When no extends is provided, type parameters default a constraint to unknown.\nIt is therefore redundant to extend from any or unknown.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-unsafe-argument": "This rule disallows calling a function with an argument which is typed as any.\n\nThe any type in TypeScript is a dangerous \"escape hatch\" from the type system. Using any disables most type checking rules and is generally unsafe. When you pass a value typed as any to a function, you lose type safety for that function call.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "no-unsafe-assignment": "This rule disallows assigning a value with type any to variables and properties.\n\nThe any type in TypeScript disables type checking and can lead to runtime errors. When you assign an any value to a typed variable, you're essentially bypassing TypeScript's type safety without any guarantees about the actual value.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "no-unsafe-call": "This rule disallows calling a value with type any.\n\nThe any type in TypeScript disables type checking. When you call a value typed as any, TypeScript cannot verify that it's actually a function, what parameters it expects, or what it returns. This can lead to runtime errors.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "no-unsafe-declaration-merging": "Disallow unsafe declaration merging.\n\nDeclaration merging between classes and interfaces is unsafe.\nThe TypeScript compiler doesn't check whether properties are initialized, which can lead to TypeScript not detecting code that will cause runtime errors.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-unsafe-enum-comparison": "This rule disallows comparing an enum value with a non-enum value.\n\nEnum values should only be compared with other values of the same enum type or their underlying literal values in a type-safe manner. Comparing enums with unrelated values can lead to unexpected behavior and defeats the purpose of using enums for type safety.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "no-unsafe-function-type": "Disallow using the unsafe built-in Function type.\n\nTypeScript's built-in Function type allows being called with any number of arguments and returns type any. Function also allows classes or plain objects that happen to possess all properties of the Function class. It's generally better to specify function parameters and return types with the function type syntax.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-unsafe-member-access": "This rule disallows member access on a value with type any.\n\nThe any type in TypeScript disables type checking. When you access a member (property or method) on a value typed as any, TypeScript cannot verify that the member exists or what type it has. This can lead to runtime errors.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhether to allow ?. optional chains on any values.\nWhen true, optional chaining on any values will not be flagged.\nDefault is false.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "no-unsafe-return": "This rule disallows returning a value with type any from a function.\n\nThe any type in TypeScript disables type checking. When you return a value typed as any from a function, you're essentially passing the type-safety problem to the caller without providing any guarantees about what the function actually returns.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "no-unsafe-type-assertion": "Disallows unsafe type assertions that narrow a type.\n\nType assertions that narrow a type bypass TypeScript's type-checking and can lead to\nruntime errors. Type assertions that broaden a type are safe because TypeScript\nessentially knows less about a type. Instead of using type assertions to narrow a\ntype, it's better to rely on type guards, which help avoid potential runtime errors\ncaused by unsafe type assertions.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "no-unsafe-unary-minus": "This rule disallows using the unary minus operator on a value which is not of type 'number' | 'bigint'.\n\nThe unary minus operator should only be used on numeric values. Using it on other types can lead to unexpected behavior due to JavaScript's type coercion rules.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "no-useless-empty-export": "Disallow empty exports that don't change anything in a module file.\n\nAn empty export {} statement is sometimes useful in TypeScript code to\nturn a file that would otherwise be a script file into a module file.\nPer the TypeScript Handbook Modules page:\n\nIn TypeScript, just as in ECMAScript 2015, any file containing a\ntop-level import or export is considered a module. Conversely, a file\nwithout any top-level import or export declarations is treated as a\nscript whose contents are available in the global scope (and therefore\nto modules as well).\n\nHowever, an export {} statement does nothing if there are any other\ntop-level import or export statements in a file.\n\nThis rule reports an export {} that doesn't do anything in a file\nalready using ES modules.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-var-requires": "Disallow require statements except in import statements.\n\nNOTE: This rule is intentionally missing the allow option from the original typescript-eslint rule.\nThis rule is deprecated in the upstream plugin and the typescript/no-require-imports rule should be\nused instead.\n\nIn other words, the use of forms such as var foo = require(\"foo\") are banned. Instead use ES module imports or import foo = require(\"foo\") imports.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-wrapper-object-types": "Disallow the use of wrapper object types.\n\nWrapper object types are types that are defined in the global scope and are not primitive types. These types are not recommended to be used in TypeScript code.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "non-nullable-type-assertion-style": "This rule prefers a non-null assertion over an explicit type cast for non-nullable types.\n\nWhen you know that a value cannot be null or undefined, you can use either a non-null assertion (!) or a type assertion (as Type). The non-null assertion is more concise and clearly communicates the intent that you're asserting the value is not null/undefined.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "only-throw-error": "This rule disallows throwing non-Error values.\n\nIt's considered good practice to only throw Error objects (or subclasses of Error). This is because Error objects automatically capture a stack trace, which is useful for debugging. Additionally, some tools and environments expect thrown values to be Error objects.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: array\n\ndefault: []\n\nAn array of type or value specifiers for additional types that are allowed to be thrown.\nUse this to allow throwing custom error types.\n\ntype: string\n\nType or value specifier for matching specific declarations\n\nSupports four types of specifiers:\n\n1. String specifier (deprecated): Universal match by name\n\n2. File specifier: Match types/values declared in local files\n\n3. Lib specifier: Match TypeScript built-in lib types\n\n4. Package specifier: Match types/values from npm packages\n\ntype: boolean\n\ndefault: true\n\nWhether to allow rethrowing caught values that are not Error objects.\n\ntype: boolean\n\ndefault: true\n\nWhether to allow throwing values typed as any.\n\ntype: boolean\n\ndefault: true\n\nWhether to allow throwing values typed as unknown.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "prefer-as-const": "Enforce the use of as const over literal type.\n\nThere are two common ways to tell TypeScript that a literal value should be interpreted as\nits literal type (e.g. 2) rather than general primitive type (e.g. number);\n\nas const: telling TypeScript to infer the literal type automatically\nas with the literal type: explicitly telling the literal type to TypeScript\n\nas const is generally preferred, as it doesn't require re-typing the literal value.\nThis rule reports when an as with an explicit literal type can be replaced with an as const.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-enum-initializers": "Require each enum member value to be explicitly initialized.\n\nIn projects where the value of enum members are important, allowing implicit values for enums can cause bugs if enums are modified over time.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-for-of": "Enforces the use of for-of loop instead of a for loop with a simple iteration.\n\nUsing a for loop with a simple iteration over an array can be replaced with a more concise\nand readable for-of loop. For-of loops are easier to read and less error-prone, as they\neliminate the need for an index variable and manual array access.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-function-type": "Enforce using function types instead of interfaces with call signatures.\n\nTypeScript allows for two common ways to declare a type for a function:\n\n- Function type: () => string\n- Object type with a signature: { (): string }\n\nThe function type form is generally preferred when possible for being\nmore succinct and readable. Interfaces with only call signatures add\nunnecessary verbosity without providing additional functionality.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-includes": "Enforce using .includes() instead of .indexOf() !== -1 or /regex/.test().\n\n.includes() is more readable and expressive than checking .indexOf() !== -1.\nIt clearly communicates the intent to check for the presence of a value.\nAdditionally, for simple string searches, .includes() is often preferred over\nregex .test() for better performance and clarity.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "prefer-literal-enum-member": "Explicit enum value must only be a literal value (string, number, boolean, etc).\n\nTypeScript allows the value of an enum member to be many different kinds of valid JavaScript expressions.\nHowever, because enums create their own scope whereby each enum member becomes a variable in that scope, developers are often surprised at the resultant values.\n\nExamples of incorrect code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhen set to true, allows bitwise expressions in enum member initializers.\nThis includes bitwise NOT (~), AND (&), OR (|), XOR (^), and shift operators (<<, >>, >>>).\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-namespace-keyword": "This rule reports when the module keyword is used instead of namespace.\nThis rule does not report on the use of TypeScript module declarations to describe external APIs (declare module 'foo' {}).\n\nNamespaces are an outdated way to organize TypeScript code. ES2015 module syntax is now preferred (import/export).\nFor projects still using custom modules / namespaces, it's preferred to refer to them as namespaces.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-nullish-coalescing": "Enforce using the nullish coalescing operator (??) instead of logical OR (||)\nor conditional expressions when the left operand might be null or undefined.\n\nThe || operator returns the right-hand side when the left-hand side is any\nfalsy value (false, 0, '', null, undefined, NaN). This can lead\nto unexpected behavior when you only want to provide a default for null\nor undefined.\n\nThe nullish coalescing operator (??) only returns the right-hand side when\nthe left-hand side is null or undefined, making the intent clearer and\navoiding bugs with other falsy values.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nUnless this is set to true, the rule will error on every file whose\ntsconfig.json does not have the strictNullChecks compiler option\n(or strict) set to true.\n\nIt is not recommended to enable this config option.\n\ntype: boolean\n\ndefault: false\n\nWhether to ignore arguments to the Boolean constructor.\n\ntype: boolean\n\ndefault: true\n\nWhether to ignore cases that are located within a conditional test.\n\ntype: boolean\n\ndefault: false\n\nWhether to ignore any if statements that could be simplified by using\nthe nullish coalescing operator.\n\ntype: boolean\n\ndefault: false\n\nWhether to ignore any logical or expressions that are part of a mixed\nlogical expression (with &&).\n\ntype: boolean\n\nRepresents the different ways ignorePrimitives can be specified in JSON.\nCan be:\n\n- true - ignore all primitive types\n- An object specifying which primitives to ignore\n\ntype: boolean\n\ndefault: false\n\nWhether to ignore any ternary expressions that could be simplified by\nusing the nullish coalescing operator.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "prefer-optional-chain": "Enforce using concise optional chain expressions instead of chained logical AND\noperators, negated logical OR operators, or empty objects.\n\nNote that this rule is in the nursery category while we ensure it is working\ncorrectly in as many edge-case scenarios as possible. The logic for this is\ncomplex and the autofix may cause logic changes in some edge-cases.\n\nTypeScript 3.7 introduced optional chaining (?.) which provides a more concise\nand readable way to access properties on potentially nullish values. Using optional\nchaining instead of logical AND chains (&&) or other patterns improves code clarity.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nAllow autofixers that will change the return type of the expression.\nThis option is considered unsafe as it may break the build.\n\ntype: boolean\n\ndefault: true\n\nCheck operands that are typed as any when inspecting \"loose boolean\" operands.\n\ntype: boolean\n\ndefault: true\n\nCheck operands that are typed as bigint when inspecting \"loose boolean\" operands.\n\ntype: boolean\n\ndefault: true\n\nCheck operands that are typed as boolean when inspecting \"loose boolean\" operands.\n\ntype: boolean\n\ndefault: true\n\nCheck operands that are typed as number when inspecting \"loose boolean\" operands.\n\ntype: boolean\n\ndefault: true\n\nCheck operands that are typed as string when inspecting \"loose boolean\" operands.\n\ntype: boolean\n\ndefault: true\n\nCheck operands that are typed as unknown when inspecting \"loose boolean\" operands.\n\ntype: boolean\n\ndefault: false\n\nSkip operands that are not typed with null and/or undefined when inspecting\n\"loose boolean\" operands.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "prefer-promise-reject-errors": "This rule enforces passing an Error object to Promise.reject().\n\nIt's considered good practice to only reject promises with Error objects. This is because Error objects automatically capture a stack trace, which is useful for debugging. Additionally, some tools and environments expect rejection reasons to be Error objects.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhether to allow calling Promise.reject() with no arguments.\n\ntype: boolean\n\ndefault: false\n\nWhether to allow rejecting Promises with values typed as any.\n\ntype: boolean\n\ndefault: false\n\nWhether to allow rejecting Promises with values typed as unknown.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "prefer-reduce-type-parameter": "This rule prefers using a type parameter for the accumulator in Array.reduce instead of casting.\n\nArray.reduce can be called with a generic type parameter to specify the type of the accumulator. This is preferred over casting the result because it provides better type safety and is more explicit about the intended type.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "prefer-return-this-type": "This rule enforces using this types for return types when possible.\n\nClasses that have methods which return the instance itself should use this as the return type instead of the class name. This provides better type safety for inheritance, as the return type will be the actual subclass type rather than the base class type.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "prefer-ts-expect-error": "Enforce using @ts-expect-error over @ts-ignore.\n\nTypeScript allows you to suppress all errors on a line by placing a comment starting with @ts-ignore or @ts-expect-error immediately before the erroring line.\nThe two directives work the same, except @ts-expect-error causes a type error if placed before a line that's not erroring in the first place.\n\nThis means it's easy for @ts-ignores to be forgotten about, and remain in code even after the error they were suppressing is fixed.\nThis is dangerous, as if a new error arises on that line it'll be suppressed by the forgotten about @ts-ignore, and so be missed.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "promise-function-async": "This rule requires any function or method that returns a Promise to be marked as async.\n\nFunctions that return Promises should typically be marked as async to make their asynchronous nature clear and to enable the use of await within them. This makes the code more readable and helps prevent common mistakes with Promise handling.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: true\n\nWhether to allow functions returning any type without requiring async.\n\ntype: string[]\n\ndefault: []\n\nA list of Promise type names that are allowed without requiring async.\nExample: [\"SpecialPromise\"] to allow functions returning SpecialPromise without async.\n\ntype: boolean\n\ndefault: true\n\nWhether to check arrow functions for missing async keyword.\n\ntype: boolean\n\ndefault: true\n\nWhether to check function declarations for missing async keyword.\n\ntype: boolean\n\ndefault: true\n\nWhether to check function expressions for missing async keyword.\n\ntype: boolean\n\ndefault: true\n\nWhether to check method declarations for missing async keyword.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "related-getter-setter-pairs": "This rule enforces that getters and setters for the same property are defined together and have related types.\n\nWhen you define a getter and setter for the same property, they should typically be defined together and work with compatible types. Having mismatched types or defining them separately can lead to confusion and potential runtime errors.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "require-array-sort-compare": "This rule requires Array.sort() to be called with a comparison function.\n\nWhen Array.sort() is called without a comparison function, it converts elements to strings and sorts them lexicographically. This often leads to unexpected results, especially with numbers where [1, 10, 2].sort() returns [1, 10, 2] instead of [1, 2, 10].\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: true\n\nWhether to ignore arrays in which all elements are strings.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "require-await": "This rule disallows async functions which do not have an await expression.\n\nAsync functions that don't use await are usually a mistake. They return a Promise unnecessarily and can often be converted to regular functions. This can improve performance and make the code clearer.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "restrict-plus-operands": "This rule requires both operands of addition to be the same type and be number, string, or any.\n\nJavaScript's + operator can be used for both numeric addition and string concatenation. When the operands are of different types, JavaScript's type coercion rules can lead to unexpected results. This rule helps prevent these issues by requiring both operands to be of compatible types.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: true\n\nWhether to allow any type in plus operations.\n\ntype: boolean\n\ndefault: true\n\nWhether to allow boolean types in plus operations.\n\ntype: boolean\n\ndefault: true\n\nWhether to allow nullish types (null or undefined) in plus operations.\n\ntype: boolean\n\ndefault: true\n\nWhether to allow mixed number and string operands in plus operations.\n\ntype: boolean\n\ndefault: true\n\nWhether to allow RegExp types in plus operations.\n\ntype: boolean\n\ndefault: false\n\nWhether to skip compound assignments (e.g., a += b).\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "restrict-template-expressions": "This rule restricts the types allowed in template literal expressions.\n\nTemplate literals will call toString() on the interpolated values. Some types don't have meaningful string representations (like objects that become \"[object Object]\") or may not have a toString method at all. This rule helps ensure that only appropriate types are used in template expressions.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: array\n\ndefault: [{\"from\":\"lib\", \"name\":[\"Error\", \"URL\", \"URLSearchParams\"]}]\n\nAn array of type or value specifiers for additional types that are allowed in template expressions.\nDefaults include Error, URL, and URLSearchParams from lib.\n\ntype: string\n\nType or value specifier for matching specific declarations\n\nSupports four types of specifiers:\n\n1. String specifier (deprecated): Universal match by name\n\n2. File specifier: Match types/values declared in local files\n\n3. Lib specifier: Match TypeScript built-in lib types\n\n4. Package specifier: Match types/values from npm packages\n\ntype: boolean\n\ndefault: true\n\nWhether to allow any typed values in template expressions.\n\ntype: boolean\n\ndefault: false\n\nWhether to allow array types in template expressions.\n\ntype: boolean\n\ndefault: true\n\nWhether to allow boolean types in template expressions.\n\ntype: boolean\n\ndefault: false\n\nWhether to allow never type in template expressions.\n\ntype: boolean\n\ndefault: true\n\nWhether to allow nullish types (null or undefined) in template expressions.\n\ntype: boolean\n\ndefault: true\n\nWhether to allow number and bigint types in template expressions.\n\ntype: boolean\n\ndefault: true\n\nWhether to allow RegExp values in template expressions.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "return-await": "This rule enforces consistent returning of awaited values from async functions.\n\nThere are different patterns for returning awaited values from async functions.\nSometimes you want to await before returning (to handle errors in the current\nfunction), and sometimes you want to return the Promise directly (for better\nperformance). This rule helps enforce consistency.\n\nExamples of incorrect code for this rule (depending on configuration):\n\nExamples of correct code for this rule:\n\nThis rule accepts one of the following string values:\n\nRequire await when returning Promises inside try/catch/finally blocks.\nThis ensures proper error handling and stack traces.\n\nRequire await before returning Promises in all cases.\nExample: return await Promise.resolve() is required.\n\nRequire await only when it affects error handling correctness.\nOnly flags cases where omitting await would change error handling behavior.\n\nDisallow await before returning Promises in all cases.\nExample: return Promise.resolve() is required (no await).\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "strict-boolean-expressions": "Disallow certain types in boolean expressions.\n\nForbids usage of non-boolean types in expressions where a boolean is expected.\nboolean and never types are always allowed. Additional types which are\nconsidered safe in a boolean context can be configured via options.\n\nThe following nodes are checked:\n\n- Arguments to the !, &&, and || operators\n- The condition in a conditional expression (cond ? x : y)\n- Conditions for if, for, while, and do-while statements.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhether to allow any type in boolean contexts.\n\ntype: boolean\n\ndefault: false\n\nWhether to allow nullable boolean types (e.g., boolean | null) in boolean contexts.\n\ntype: boolean\n\ndefault: false\n\nWhether to allow nullable enum types in boolean contexts.\n\ntype: boolean\n\ndefault: false\n\nWhether to allow nullable number types (e.g., number | null) in boolean contexts.\n\ntype: boolean\n\ndefault: true\n\nWhether to allow nullable object types in boolean contexts.\n\ntype: boolean\n\ndefault: false\n\nWhether to allow nullable string types (e.g., string | null) in boolean contexts.\n\ntype: boolean\n\ndefault: true\n\nWhether to allow number types in boolean contexts (checks for non-zero numbers).\n\ntype: boolean\n\ndefault: false\n\nWhether to allow this rule to run without strictNullChecks enabled.\nThis is not recommended as the rule may produce incorrect results.\n\ntype: boolean\n\ndefault: true\n\nWhether to allow string types in boolean contexts (checks for non-empty strings).\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "switch-exhaustiveness-check": "This rule requires switch statements to be exhaustive when switching on union types.\n\nWhen switching on a union type, it's important to handle all possible cases to avoid runtime errors. TypeScript can help ensure exhaustiveness, but only if the switch statement is properly structured with a default case that TypeScript can analyze.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: true\n\nWhether to allow default cases on switches that are not exhaustive.\nWhen false, requires exhaustive switch statements without default cases.\n\ntype: boolean\n\ndefault: false\n\nWhether to consider default cases exhaustive for union types.\nWhen true, a switch statement with a default case is considered exhaustive\neven if not all union members are handled explicitly.\n\ntype: string\n\nRegular expression pattern that when matched in a default case comment,\nwill suppress the exhaustiveness check.\nExample: \"@skip-exhaustive-check\" to allow default: // @skip-exhaustive-check\n\ntype: boolean\n\ndefault: false\n\nWhether to require default cases on switches over union types that are not exhaustive.\nWhen true, switches with non-exhaustive union types must have a default case.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "triple-slash-reference": "Disallow certain triple slash directives in favor of ES module import declarations.\n\nUse of triple-slash reference type directives is generally discouraged in favor of ECMAScript Module imports.\n\nExamples of incorrect code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: \"always\" | \"never\"\n\ndefault: \"always\"\n\nWhat to enforce for /// <reference lib=\"...\" /> references.\n\nAllow triple-slash lib references.\n\nDisallow triple-slash lib references.\n\ntype: \"always\" | \"never\"\n\ndefault: \"never\"\n\nWhat to enforce for /// <reference path=\"...\" /> references.\n\nAllow triple-slash path references.\n\nDisallow triple-slash path references.\n\ntype: \"always\" | \"never\" | \"prefer-import\"\n\ndefault: \"prefer-import\"\n\nWhat to enforce for /// <reference types=\"...\" /> references.\n\nAllow triple-slash types references.\n\nDisallow triple-slash types references.\n\nPrefer ES module import declarations over triple-slash types references.\nThis option only reports when there is an existing import declaration for the same module.\n\nFor example, this would be reported as a lint violation with prefer-import:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "unbound-method": "This rule enforces unbound methods are called with their expected scope.\n\nWhen you extract a method from an object and call it separately, the this context is lost. This can lead to runtime errors or unexpected behavior, especially with methods that rely on this to access instance properties or other methods.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhether to ignore unbound methods that are static.\nWhen true, static methods can be referenced without binding.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>",
    "use-unknown-in-catch-callback-variable": "This rule enforces using unknown for catch clause variables instead of any.\n\nIn TypeScript 4.0+, catch clause variables can be typed as unknown instead of any. Using unknown is safer because it forces you to perform type checking before using the error, preventing potential runtime errors.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>\n- <a v-bind:href=\"tsgolintSource\" target=\"blank\" rel=\"noreferrer\">Rule Source (tsgolint)</a>"
  },
  "unicorn": {
    "catch-error-name": "This rule enforces consistent and descriptive naming for error variables\nin catch statements, preventing the use of vague names like badName\nor  when the error is used.\n\nUsing non-descriptive names like badName or  makes the code harder\nto read and understand, especially when debugging. It's important to use\nclear, consistent names to represent errors.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\nA list of patterns to ignore when checking catch variable names. The pattern\ncan be a string or regular expression.\n\ntype: string\n\ndefault: \"error\"\n\nThe name to use for error variables in catch blocks. You can customize it\nto something other than 'error' (e.g., 'exception').\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "consistent-assert": "Enforces consistent usage of the assert module.\n\nInconsistent usage of the assert module can lead to confusion and errors.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "consistent-date-clone": "The Date constructor can clone a Date object directly when passed as an argument,\nmaking timestamp conversion unnecessary. This rule enforces the use of the\ndirect Date cloning instead of using .getTime() for conversion.\n\nUsing .getTime() to convert a Date object to a timestamp and then back to a\nDate is redundant and unnecessary. Simply passing the Date object to the\nDate constructor is cleaner and more efficient.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "consistent-empty-array-spread": "When spreading a ternary in an array, we can use both [] and '' as fallbacks,\nbut it's better to have consistent types in both branches.\n\nHaving consistent types in both branches makes the code easier to read and understand.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "consistent-existence-index-check": "Enforce consistent style for element existence checks with indexOf(),\nlastIndexOf(), findIndex(), and findLastIndex(). This ensures\nthat comparisons are performed in a standard and clear way.\n\nThis rule is meant to enforce a specific style and improve code clarity.\nUsing inconsistent comparison styles (e.g., index < 0, index >= 0)\ncan make the intention behind the code unclear, especially in large\ncodebases.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "consistent-function-scoping": "Disallow functions that are declared in a scope which does not capture\nany variables from the outer scope.\n\nMoving function declarations to the highest possible scope improves\nreadability, directly improves performance\nand allows JavaScript engines to better optimize your performance.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule does not detect or remove extraneous code blocks inside of functions:\n\nIt also ignores functions that contain JSXElement references:\n\nImmediately invoked function expressions (IIFE) are ignored:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: true\n\nWhether to check scoping with arrow functions.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "empty-brace-spaces": "Removes the extra spaces or new line characters inside a pair of braces\nthat does not contain additional code. This ensures that braces are clean\nand do not contain unnecessary spaces or newlines.\n\nExtra spaces inside braces can negatively impact the readability of the code.\nKeeping braces clean and free of unnecessary characters improves consistency and\nmakes the code easier to understand and maintain.\n\n<!-- prettier-ignore-start -->\nExamples of incorrect code for this rule:\n\n<!-- prettier-ignore-end -->\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "error-message": "Enforces providing a message when creating built-in Error objects to\nimprove readability and debugging.\n\nThrowing an Error without a message, like throw new Error(), provides no context\non what went wrong, making debugging harder. A clear error message improves\ncode clarity and helps developers quickly identify issues.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "escape-case": "Enforces defining escape sequence values with uppercase characters rather than lowercase ones.\nThis promotes readability by making the escaped value more distinguishable from the identifier.\n\nUsing lowercase characters in escape sequences makes them less readable and harder to distinguish\nfrom surrounding code. Most style guides recommend uppercase for consistency and clarity.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "explicit-length-check": "Enforce explicitly comparing the length or size property of a value.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: \"greater-than\" | \"not-equal\"\n\ndefault: \"greater-than\"\n\nConfiguration option to specify how non-zero length checks should be enforced.\n\ngreater-than: Enforces non-zero to be checked with foo.length > 0\nnot-equal: Enforces non-zero to be checked with foo.length !== 0\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "filename-case": "Enforces a consistent case style for filenames to improve project organization and maintainability.\nBy default, kebab-case is enforced, but other styles can be configured.\n\nFiles named index.js, index.ts, etc. are exempt from this rule as they cannot reliably be\nrenamed to other casings (mainly just a problem with PascalCase).\n\nInconsistent file naming conventions make it harder to locate files, navigate projects, and enforce\nconsistency across a codebase. Standardizing naming conventions improves readability, reduces cognitive\noverhead, and aligns with best practices in large-scale development.\n\nExamples of correct filenames for each case:\n\n- some-file-name.js\n- some-file-name.test.js\n- some-file-name.test-utils.js\n\n- someFileName.js\n- someFileName.test.js\n- someFileName.testUtils.js\n\n- somefilename.js\n- somefilename.test.js\n- somefilename.testutils.js\n\n- SomeFileName.js\n- SomeFileName.Test.js\n- SomeFileName.TestUtils.js\n\nThis rule accepts a configuration object with the following properties:\n\ntype: \"kebabCase\" | \"camelCase\" | \"snakeCase\" | \"pascalCase\"\n\ndefault: \"kebabCase\"\n\nThe case style to enforce for filenames.\n\nYou can set the case option like this:\n\ntype: object\n\ndefault: {\"kebabCase\":true, \"camelCase\":false, \"snakeCase\":false, \"pascalCase\":false}\n\nThe case style(s) to allow/enforce for filenames. true means the case style is allowed, false means it is banned.\n\nYou can set the cases option like this:\n\ntype: boolean\n\ndefault: false\n\nWhether camel case is allowed, e.g. someFileName.js.\n\ntype: boolean\n\ndefault: true\n\nWhether kebab case is allowed, e.g. some-file-name.js.\n\ntype: boolean\n\ndefault: false\n\nWhether pascal case is allowed, e.g. SomeFileName.js.\n\ntype: boolean\n\ndefault: false\n\nWhether snake case is allowed, e.g. somefilename.js.\n\ntype: string\n\nA regular expression pattern for filenames to ignore.\n\nYou can set the ignore option like this:\n\ntype: boolean\n\ndefault: true\n\nWhether to treat additional, .-separated parts of a filename as\nparts of the extension rather than parts of the filename.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>",
    "new-for-builtins": "Enforces the use of new for the following builtins: Object, Array, ArrayBuffer, BigInt64Array,\nBigUint64Array, DataView, Date, Error, Float32Array, Float64Array, Function, Int8Array,\nInt16Array, Int32Array, Map, WeakMap, Set, WeakSet, Promise, RegExp, Uint8Array,\nUint16Array, Uint32Array, Uint8ClampedArray, SharedArrayBuffer, Proxy, WeakRef, FinalizationRegistry.\n\nDisallows the use of new for the following builtins: String, Number, Boolean, Symbol, BigInt.\n\nUsing new inconsistently can cause confusion. Constructors like Array and RegExp should always use new\nto ensure the expected instance type. Meanwhile, String, Number, Boolean, Symbol, and BigInt should not use new,\nas they create object wrappers instead of primitive values.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-abusive-eslint-disable": "Disallows oxlint-disable or eslint-disable comments without specifying rules.\n\nA general oxlint-disable or eslint-disable comment suppresses all lint errors, not just the intended one,\npotentially hiding useful warnings and making debugging harder.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-accessor-recursion": "Disallow recursive access to this within getters and setters\n\nThis rule prevents recursive access to this within getter and setter methods in objects and classes,\navoiding infinite recursion and stack overflow errors.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-anonymous-default-export": "Disallows anonymous functions and classes as default exports.\n\nNaming default exports improves searchability and ensures consistent\nidentifiers for a module’s default export in both declaration and import.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-array-callback-reference": "Prevents passing a function reference directly to iterator methods\n\nPassing functions to iterator methods can cause issues when the function is changed\nwithout realizing that the iterator passes 2 more parameters to it (index and array).\nThis can lead to unexpected behavior when the function signature changes.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-array-for-each": "Forbids the use of Array#forEach in favor of a for loop.\n\nBenefits of for…of statement over the forEach method can include:\n\n- Faster\n- Better readability\n- Ability to exit early with break or return\n\nAdditionally, using for…of has great benefits if you are using TypeScript, because it does not cause a function boundary to be crossed. This means that type-narrowing earlier on in the current scope will work properly while inside of the loop (without having to re-type-narrow). Furthermore, any mutated variables inside of the loop will picked up on for the purposes of determining if a variable is being used.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-array-method-this-argument": "Disallows the use of the thisArg parameter in array iteration methods such as\nmap, filter, some, every, and similar.\n\nThe thisArg parameter makes code harder to understand and reason about. Instead,\nprefer arrow functions or bind explicitly in a clearer way. Arrow functions inherit\nthis from the lexical scope, which is more intuitive and less error-prone.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-array-reduce": "Disallow Array#reduce() and Array#reduceRight().\n\nArray#reduce() and Array#reduceRight() usually result in hard-to-read and less performant code. In almost every case, it can be replaced by .map, .filter, or a for-of loop.\n\nIt's only somewhat useful in the rare case of summing up numbers, which is allowed by default.\n\nExamples of incorrect code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: true\n\nWhen set to true, allows simple operations (like summing numbers) in reduce and reduceRight calls.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-array-reverse": "Prefer using Array#toReversed() over Array#reverse().\n\nArray#reverse() modifies the original array in place, which can lead to unintended side effects—especially\nwhen the original array is used elsewhere in the code.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: true\n\nThis rule allows array.reverse() as an expression statement by default.\nSet to false to forbid Array#reverse() even if it's an expression statement.\n\nExamples of incorrect code for this rule with this option set to false:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-array-sort": "Prefer using Array#toSorted() over Array#sort().\n\nArray#sort() modifies the original array in place, which can lead to unintended side effects—especially\nwhen the original array is used elsewhere in the code.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: true\n\nWhen set to true (default), allows array.sort() as an expression statement.\nSet to false to forbid Array#sort() even if it's an expression statement.\n\nExample of incorrect code for this rule with allowExpressionStatement set to false:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-await-expression-member": "Disallows member access from await expressions.\n\nWhen accessing a member from an await expression,\nthe await expression has to be parenthesized, which is not readable.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-await-in-promise-methods": "Disallow using await in Promise method parameters\n\nUsing await on promises passed as arguments to Promise.all(),\nPromise.allSettled(), Promise.any(), or Promise.race() is likely a\nmistake.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-console-spaces": "Disallows leading/trailing space inside console.log() and similar methods.\n\nThe console.log() method and similar methods join the parameters with a space so adding a leading/trailing space to a parameter, results in two spaces being added.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-document-cookie": "Disallow direct use of\ndocument.cookie.\n\nIt's not recommended to use\ndocument.cookie\ndirectly as it's easy to get the string wrong. Instead, you should use\nthe Cookie Store\nAPI\nor a cookie library.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-empty-file": "Disallows files that do not contain any meaningful code.\n\nThis includes files that consist only of:\n\n- Whitespace\n- Comments\n- Directives (e.g., \"use strict\")\n- Empty statements (;)\n- Empty blocks ({})\n- Hashbangs (#!/usr/bin/env node)\n\nFiles with no executable or exportable content are typically unintentional\nor left over from refactoring. They clutter the codebase and may confuse\ntooling or developers by appearing to serve a purpose when they do not.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-hex-escape": "Enforces a convention of using Unicode escapes instead of hexadecimal escapes for consistency and clarity.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-immediate-mutation": "Disallows mutating a variable immediately after initialization.\n\nWhen you initialize a variable and immediately mutate it, it's cleaner to include\nthe mutation in the initialization. This makes the code more readable and reduces\nthe number of statements.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-instanceof-array": "Require Array.isArray() instead of instanceof Array.\n\nThe instanceof Array check doesn't work across realms/contexts, for example, frames/windows in browsers or the vm module in Node.js.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-instanceof-builtins": "Disallows the use of instanceof with ECMAScript built-in constructors because:\n\n- it breaks across execution contexts (iframe, Web Worker, Node VM, etc.);\n- it is often misleading (e.g. instanceof Array fails for a subclass);\n- there is always a clearer and safer alternative (Array.isArray, typeof, Buffer.isBuffer, …).\n\ninstanceof breaks across execution contexts (iframe, Web Worker, Node vm),\nand may give misleading results for subclasses or exotic objects.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: []\n\nConstructor names to exclude from checking.\n\ntype: string[]\n\ndefault: []\n\nAdditional constructor names to check beyond the default set.\nUse this to extend the rule with additional constructors.\n\ntype: \"strict\" | \"loose\"\n\ndefault: \"loose\"\n\nControls which built-in constructors are checked.\n\n- \"loose\" (default): Only checks Array, Function, Error (if useErrorIsError is true), and primitive wrappers\n- \"strict\": Additionally checks Error types, collections, typed arrays, and other built-in constructors\n\ntype: boolean\n\ndefault: false\n\nWhen true, checks instanceof Error and suggests using Error.isError() instead.\nRequires the Error.isError() function\nto be available.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-invalid-fetch-options": "Disallow invalid options in fetch() and new Request(). Specifically, this rule ensures that\na body is not provided when the method is GET or HEAD, as it will result in a TypeError.\n\nThe fetch() function throws a TypeError when the method is GET or HEAD and a body is provided.\nThis can lead to unexpected behavior and errors in your code. By disallowing such invalid options,\nthe rule ensures that requests are correctly configured and prevents unnecessary errors.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-invalid-remove-event-listener": "It warns when you use a non-function value as the second argument of removeEventListener.\n\nThe removeEventListener function must be called with a reference to the same function that was passed to addEventListener. Calling removeEventListener with an inline function or the result of an inline .bind() call is indicative of an error, and won't actually remove the listener.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-length-as-slice-end": "Disallow using length as the end argument of a slice call.\n\nPassing length as the end argument of a slice call is unnecessary and can be confusing.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-lonely-if": "Disallow if statements as the only statement in if blocks without else.\n\nIt can be confusing to have an if statement without an else clause as the only statement in an if block.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-magic-array-flat-depth": "Disallow magic numbers for Array.prototype.flat depth.\n\nMagic numbers are hard to understand and maintain. When calling Array.prototype.flat, it is usually called with 1 or infinity. If you are using a different number, it is better to add a comment explaining the depth.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-negation-in-equality-check": "Disallow negated expressions on the left of (in)equality checks.\n\nA negated expression on the left of an (in)equality check is likely a mistake from trying to negate the whole condition.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-nested-ternary": "This rule disallows deeply nested ternary expressions.\nNested ternary expressions that are only one level deep and wrapped in parentheses are allowed.\n\nNesting ternary expressions can make code more difficult to understand.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-new-array": "Disallow new Array().\n\nWhen using the Array constructor with one argument, it's not clear whether the argument is meant to be the length of the array or the only element.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-new-buffer": "Disallows the deprecated new Buffer() constructor.\n\nEnforces the use of Buffer.from and Buffer.alloc() instead of new Buffer(), which has been deprecated since Node.js 4.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-null": "Disallow the use of the null literal, to encourage using undefined instead.\n\nThere are some reasons for using undefined instead of null.\n\n- From experience, most developers use null and undefined inconsistently and interchangeably, and few know when to use which.\n- Supporting both null and undefined complicates input validation.\n- Using null makes TypeScript types more verbose: type A = {foo?: string | null} vs type A = {foo?: string}.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nWhen set to true, the rule will also check strict equality/inequality comparisons (=== and !==) against null.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-object-as-default-parameter": "Disallow the use of an object literal as a default value for a parameter.\n\nDefault parameters should not be passed to a function through an object literal. The foo = {a: false} parameter works fine if only used with one option. As soon as additional options are added, you risk replacing the whole foo = {a: false, b: true} object when passing only one option: {a: true}. For this reason, object destructuring should be used instead.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-process-exit": "Disallow process.exit().\n\nOnly use process.exit() in CLI apps. Throw an error instead.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-single-promise-in-promise-methods": "Disallow passing single-element arrays to Promise methods\n\nPassing a single-element array to Promise.all(), Promise.any(), or\nPromise.race() is likely a mistake.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-static-only-class": "Disallow classes that only have static members.\n\nA class with only static members could just be an object instead.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-thenable": "Disallow then property\n\nIf an object is defined as \"thenable\", once it's accidentally\nused in an await expression, it may cause problems:\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-this-assignment": "Disallow assigning this to a variable.\n\nAssigning this to a variable is unnecessary and confusing.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-typeof-undefined": "Disallow typeof comparisons with undefined.\n\nChecking if a value is undefined by using typeof value === 'undefined' is needlessly verbose. It's generally better to compare against undefined directly. The only time typeof is needed is when a global variable potentially does not exists, in which case, using globalThis.value === undefined may be better.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nIf set to true, also report typeof x === \"undefined\" when x may be a global\nvariable that is not declared (commonly checked via typeof foo === \"undefined\").\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-unnecessary-array-flat-depth": "Disallows passing 1 to Array.prototype.flat\n\nPassing 1 is unnecessary.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-unnecessary-array-splice-count": "Disallows passing .length or Infinity as the deleteCount or skipCount argument of Array#splice() or Array#toSpliced().\n\nWhen calling Array#splice(start, deleteCount) or Array#toSpliced(start, skipCount),\nomitting the deleteCount or skipCount argument will delete or skip all elements after start.\nUsing .length or Infinity is unnecessary and makes the code more verbose.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-unnecessary-await": "Disallow awaiting on non-promise values.\n\nThe await operator should only be used on Promise values.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-unnecessary-slice-end": "Omitting the end argument defaults it to the object's .length.\nPassing it explicitly or using Infinity is unnecessary\n\nIn JavaScript, omitting the end index already causes .slice() to run to the end of the target,\nso explicitly passing its length or Infinity is redundant.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-unreadable-array-destructuring": "Disallow unreadable array destructuring\n\nDestructuring is very useful, but it can also make some code harder to read.\nThis rule prevents ignoring consecutive values when destructuring from an array.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-unreadable-iife": "This rule disallows IIFEs with a parenthesized arrow function body.\n\nIIFEs with a parenthesized arrow function body are unreadable.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-useless-collection-argument": "Disallow useless values or fallbacks in Set, Map, WeakSet, or WeakMap\n\nIt's unnecessary to pass an empty array or string when constructing a Set, Map, WeakSet, or WeakMap, since they accept nullish values.\nIt's also unnecessary to provide a fallback for possible nullish values.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-useless-error-capture-stack-trace": "Disallows unnecessary Error.captureStackTrace(…) in error constructors.\n\nCalling Error.captureStackTrace(…) inside the constructor of a built-in Error subclass\nis unnecessary, since the Error constructor calls it automatically.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-useless-fallback-in-spread": "Disallow useless fallback when spreading in object literals.\n\nSpreading falsy values in object literals won't add any unexpected properties, so it's unnecessary to add an empty object as fallback.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-useless-length-check": "It checks for an unnecessary array length check in a logical expression.\n\nThe cases are:\n\n- array.length === 0 || array.every(Boolean) (array.every returns true if array is has elements)\n- array.length > 0 && array.some(Boolean) (array.some returns false if array is empty)\n\nAn extra unnecessary length check is done.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-useless-promise-resolve-reject": "Disallows returning values wrapped in Promise.resolve or Promise.reject in an async function or a Promise#then/catch/finally callback.\n\nWrapping a return value in Promise.resolve in an async function or a Promise#then/catch/finally callback is unnecessary as all return values in async functions and promise callback functions are already wrapped in a Promise. Similarly, returning an error wrapped in Promise.reject is equivalent to simply throwing the error. This is the same for yielding in async generators as well.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nIf set to true, allows the use of Promise.reject in async functions and promise callbacks.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-useless-spread": "Disallows using spread syntax in following, unnecessary cases:\n\n- Spread an array literal as elements of an array literal\n- Spread an array literal as arguments of a call or a new call\n- Spread an object literal as properties of an object literal\n- Use spread syntax to clone an array created inline\n\nThe following builtins accept an iterable, so it's unnecessary to\nconvert the iterable to an array:\n\n- Map constructor\n- WeakMap constructor\n- Set constructor\n- WeakSet constructor\n- TypedArray constructor\n- Array.from(…)\n- TypedArray.from(…)\n- Promise.{all,allSettled,any,race}(…)\n- Object.fromEntries(…)\n\nThe for…of loop can iterate over any iterable object not just array,\nso it's unnecessary to convert the iterable to an array.\n\nThe yield can delegate to another iterable, so it's unnecessary to\nconvert the iterable to an array.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable** this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-useless-switch-case": "Disallows useless default cases in switch statements.\n\nAn empty case before the last default case is useless.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-useless-undefined": "Do not use useless undefined.\n\nundefined is the default value for new variables, parameters, return statements, etc… so specifying it doesn't make any difference.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: true\n\nWhether to check for useless undefined in function call arguments.\n\ntype: boolean\n\ndefault: true\n\nWhether to check for useless undefined in arrow function bodies.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-zero-fractions": "Prevents the use of zero fractions.\n\nThere is no difference in JavaScript between, for example, 1, 1.0 and 1., so prefer the former for consistency and brevity.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "number-literal-case": "This rule enforces proper case for numeric literals.\n\nWhen both an identifier and a number literal are in lower case, it can be hard to differentiate between them.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "numeric-separators-style": "Enforces a convention of grouping digits using numeric separators.\n\nLong numbers can become really hard to read, so cutting it into groups of digits,\nseparated with a \\, is important to keep your code clear. This rule also enforces\na proper usage of the numeric separator, by checking if the groups of digits are\nof the correct size.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: object\n\nConfiguration for binary literals (e.g. 0b10100001 and bigint variants).\nControls how digits are grouped and when separators are applied.\n\ntype: integer\n\nThe number of digits per group when inserting numeric separators.\nFor example, a groupLength of 3 formats 1234567 as 1234567.\n\ntype: integer\n\nThe minimum number of digits required before grouping is applied.\nValues with fewer digits than this threshold will not be grouped.\n\ntype: object\n\nConfiguration for hexadecimal literals (e.g. 0xABCD, 0Xabcd, and bigint variants).\nControls how digits are grouped and when separators are applied.\n\ntype: integer\n\nThe number of digits per group when inserting numeric separators.\nFor example, a groupLength of 3 formats 1234567 as 1234567.\n\ntype: integer\n\nThe minimum number of digits required before grouping is applied.\nValues with fewer digits than this threshold will not be grouped.\n\ntype: object\n\nConfiguration for decimal numbers (integers, fraction parts, and exponents).\nControls how digits are grouped and when separators are applied.\n\ntype: integer\n\nThe number of digits per group when inserting numeric separators.\nFor example, a groupLength of 3 formats 1234567 as 1234567.\n\ntype: integer\n\nThe minimum number of digits required before grouping is applied.\nValues with fewer digits than this threshold will not be grouped.\n\ntype: object\n\nConfiguration for octal literals (e.g. 0o12345670 and bigint variants).\nControls how digits are grouped and when separators are applied.\n\ntype: integer\n\nThe number of digits per group when inserting numeric separators.\nFor example, a groupLength of 3 formats 1234567 as 1234567.\n\ntype: integer\n\nThe minimum number of digits required before grouping is applied.\nValues with fewer digits than this threshold will not be grouped.\n\ntype: boolean\n\ndefault: false\n\nOnly enforce the rule when the numeric literal already contains a separator ().\n\nWhen true, numbers without separators are left as-is; when false (default),\ngrouping will be enforced for eligible numbers even if they don't include separators yet.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-add-event-listener": "Enforces the use of .addEventListener() and .removeEventListener() over their on-function counterparts.\n\nFor example, foo.addEventListener('click', handler); is preferred over foo.onclick = handler; for HTML DOM Events.\n\nThere are numerous advantages of using addEventListener. Some of these advantages include registering unlimited event handlers and optionally having the event handler invoked only once.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-array-find": "Encourages using Array.prototype.find instead of filter(...)[0] or\nsimilar patterns when only the first matching element is needed.\n\nUsing filter(...)[0] to get the first match is less efficient and more verbose\nthan using find(...). find short-circuits when a match is found,\nwhereas filter evaluates the entire array.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-array-flat-map": "Prefers the use of .flatMap() when map().flat() are used together.\n\nIt is slightly more efficient to use .flatMap(…) instead of .map(…).flat().\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-array-flat": "Prefers Array#flat() over legacy techniques to flatten arrays.\n\nES2019 introduced a new method Array#flat() that flatten arrays.\n\nThis rule aims to standardize the use of Array#flat() over legacy techniques to flatten arrays.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-array-index-of": "Enforces using indexOf or lastIndexOf instead of findIndex or findLastIndex\nwhen the callback is a simple strict equality comparison.\n\nUsing findIndex(x => x === value) is unnecessarily verbose when indexOf(value)\naccomplishes the same thing more concisely and clearly. It also avoids the overhead\nof creating a callback function.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-array-some": "Prefers using Array#some() over Array#find(), Array#findLast() with comparing to undefined,\nor Array#findIndex(), Array#findLastIndex()\nand a non-zero length check on the result of Array#filter()\n\nUsing .some() is more idiomatic and easier to read.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-at": "Prefer .at() method for index access and String#charAt().\n\nThe .at() method is more readable and consistent for accessing elements by index,\nespecially for negative indices which access elements from the end.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nCheck all index access, not just special patterns like array.length - 1.\nWhen enabled, array[0], array[1], etc. will also be flagged.\n\ntype: string[]\n\ndefault: []\n\nList of function names to treat as \"get last element\" functions.\nThese functions will be checked for .at(-1) usage.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-bigint-literals": "Requires using BigInt literals (e.g. 123n) instead of calling the BigInt() constructor\nwith literal arguments such as numbers or numeric strings\n\nUsing BigInt(…) with literal values is unnecessarily verbose and less idiomatic than using\na BigInt literal.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-blob-reading-methods": "Recommends using Blob#text() and Blob#arrayBuffer() over FileReader#readAsText() and FileReader#readAsArrayBuffer().\n\nFileReader predates promises, and the newer Blob#arrayBuffer() and Blob#text() methods are much cleaner and easier to use.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-class-fields": "Prefers class field declarations over this assignments in constructors for static values.\n\nClass field declarations are more readable and less error-prone than assigning static\nvalues to this in the constructor. Using class fields keeps the constructor cleaner\nand makes the intent clearer.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-classlist-toggle": "Prefers the use of element.classList.toggle(className, condition) over\nconditional add/remove patterns.\n\nThe toggle() method is more concise and expressive than using conditional\nlogic to switch between add() and remove().\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-code-point": "Prefers usage of String.prototype.codePointAt over String.prototype.charCodeAt.\nPrefers usage of String.fromCodePoint over String.fromCharCode.\n\nUnicode is better supported in String#codePointAt() and String.fromCodePoint().\n\nDifference between String.fromCodePoint() and String.fromCharCode()\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-date-now": "Prefers use of Date.now() over new Date().getTime() or new Date().valueOf().\n\nUsing Date.now() is shorter and nicer than new Date().getTime(), and avoids unnecessary instantiation of Date objects.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-default-parameters": "Instead of reassigning a function parameter, default parameters should be used. The foo = foo || 123 statement evaluates to 123 when foo is falsy, possibly leading to confusing behavior, whereas default parameters only apply when passed an undefined value.\nThis rule only reports reassignments to literal values.\n\nYou should disable this rule if you want your functions to deal with null and other falsy values the same way as undefined.\nDefault parameters are exclusively applied when undefined is received..\nHowever, we recommend moving away from null.\n\nUsing default parameters makes it clear that a parameter has a default value, improving code readability and maintainability.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-dom-node-append": "Enforces the use of, for example, document.body.append(div); over document.body.appendChild(div); for DOM nodes.\n\nThere are some advantages of using Node#append(), like the ability to append multiple nodes and to append both DOMString and DOM node objects.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-dom-node-dataset": "Use .dataset on DOM elements over getAttribute(…), .setAttribute(…), .removeAttribute(…) and .hasAttribute(…).\n\nThe dataset property is a map of strings that contains all the data- attributes from the element. It is a convenient way to access all of them at once.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable** this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-dom-node-remove": "Prefers the use of child.remove() over parentNode.removeChild(child).\n\nThe DOM function Node#remove() is preferred over the indirect removal of an object with Node#removeChild().\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-dom-node-text-content": "Enforces the use of .textContent over .innerText for DOM nodes.\n\nThere are some disadvantages of using .innerText.\n\n- .innerText is much more performance-heavy as it requires layout information to return the result.\n- .innerText is defined only for HTMLElement objects, while .textContent is defined for all Node objects.\n- .innerText is not standard, for example, it is not present in Firefox.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-event-target": "Prefers EventTarget over EventEmitter.\n\nThis rule reduces the bundle size and makes your code more cross-platform friendly.\n\nSee the differences between EventEmitter and EventTarget.\n\nWhile EventEmitter is only available in Node.js, EventTarget is also available in Deno and browsers.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-global-this": "Enforces the use of globalThis instead of\nenvironment‑specific global object aliases (window, self, or global).\nUsing the standard globalThis makes your code portable across browsers, Web Workers, Node.js,\nand future JavaScript runtimes.\n\n• Portability – window is only defined in browser main threads, self is used in Web Workers,\nand global is Node‑specific. Choosing the wrong alias causes runtime crashes when the code is\nexecuted outside of its original environment.\n• Clarity – globalThis clearly communicates that you are referring to the global object itself\nrather than a particular platform.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-includes": "Prefer includes() over indexOf() when checking for existence or non-existence.\nAll built-ins have .includes() in addition to .indexOf().\n\nThe .includes() method is more readable and less error-prone than .indexOf().\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-keyboard-event-key": "Enforces the use of KeyboardEvent#key over KeyboardEvent#keyCode which is deprecated.\nThe .key property is also more semantic and readable.\n\nThe keyCode, which, and charCode properties are deprecated and should be avoided in favor of the key property.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-logical-operator-over-ternary": "This rule finds ternary expressions that can be simplified to a logical operator.\n\nUsing a logical operator is shorter and simpler than a ternary expression.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-math-min-max": "Prefers use of Math.min() and Math.max() instead of ternary\nexpressions when performing simple comparisons.\n\nUsing Math.min() and Math.max() for simple comparisons is more\nconcise, easier to understand, and less prone to errors than ternary\nexpressions. They clearly express the intent to find the minimum or\nmaximum value.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-math-trunc": "Prefers use of Math.trunc() instead of bitwise operations for clarity and more reliable results.\n\nIt prevents the use of the following bitwise operations:\n\n- x | 0 (bitwise OR with 0)\n- ~~x (two bitwise NOT)\n- x >> 0 (Signed Right Shift with 0)\n- x << 0 (Left Shift with 0)\n- x ^ 0 (bitwise XOR Shift with 0)\n\nUsing bitwise operations to truncate numbers is not clear and do not work in some cases.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-modern-dom-apis": "Enforces the use of:\n\n- childNode.replaceWith(newNode) over parentNode.replaceChild(newNode, oldNode)\n- referenceNode.before(newNode) over parentNode.insertBefore(newNode, referenceNode)\n- referenceNode.before('text') over referenceNode.insertAdjacentText('beforebegin', 'text')\n- referenceNode.before(newNode) over referenceNode.insertAdjacentElement('beforebegin', newNode)\n\nThere are some advantages of using the newer DOM APIs, like:\n\n- Traversing to the parent node is not necessary.\n- Appending multiple nodes at once.\n- Both DOMString and DOM node objects can be manipulated.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-modern-math-apis": "Checks for usage of legacy patterns for mathematical operations.\n\nModern JavaScript provides more concise and readable alternatives to legacy patterns.\n\nCurrently, the following cases are checked:\n\n- Prefer Math.log10(x) over alternatives\n- Prefer Math.hypot(…) over alternatives\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-native-coercion-functions": "Prefers built in functions, over custom ones with the same functionality.\n\nIf a function is equivalent to String, Number, BigInt, Boolean, or Symbol, you should use the built-in one directly.\nWrapping the built-in in a function is moot.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-negative-index": "Prefer negative index over .length - index when possible\n\nConciseness and readability\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-node-protocol": "Prefer using the node:protocol when importing Node.js builtin modules\n\nNode.js builtin modules should be imported using the node: protocol to avoid ambiguity with local modules.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-number-properties": "Disallows use of parseInt(), parseFloat(), isNan(), isFinite(), Nan, Infinity and -Infinity as global variables.\n\nECMAScript 2015 moved globals onto the Number constructor for consistency and to slightly improve them. This rule enforces their usage to limit the usage of globals:\n\n- Number.parseInt() over parseInt()\n- Number.parseFloat() over parseFloat()\n- Number.isNaN() over isNaN() (they have slightly different behavior)\n- Number.isFinite() over isFinite() (they have slightly different behavior)\n- Number.NaN over NaN\n- Number.POSITIVEINFINITY over Infinity\n- Number.NEGATIVEINFINITY over -Infinity\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: boolean\n\ndefault: false\n\nIf set to true, checks for usage of Infinity and -Infinity as global variables.\n\ntype: boolean\n\ndefault: true\n\nIf set to true, checks for usage of NaN as a global variable.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-object-from-entries": "Encourages using Object.fromEntries when converting an array of key-value pairs\ninto an object.\n\nManually constructing objects from key-value pairs using reduce or forEach\nis more verbose, error-prone, and harder to understand. The Object.fromEntries\nmethod is clearer, more declarative, and built for exactly this purpose.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: [\".fromPairs\", \"lodash.fromPairs\"]\n\nAdditional functions to treat as equivalents to Object.fromEntries.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-optional-catch-binding": "Prefers omitting the catch binding parameter if it is unused\n\nIt is unnecessary to bind the error to a variable if it is not used.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-prototype-methods": "This rule prefers borrowing methods from the prototype instead of the instance.\n\n“Borrowing” a method from an instance of Array or Object is less clear than getting it from the corresponding prototype.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-query-selector": "Prefer .querySelector() over .getElementById(), .querySelectorAll() over .getElementsByClassName() and .getElementsByTagName().\n\n- Using .querySelector() and .querySelectorAll() is more flexible and allows for more specific selectors.\n- It's better to use the same method to query DOM elements. This helps keep consistency and it lends itself to future improvements (e.g. more specific selectors).\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-reflect-apply": "Reflect.apply() is arguably less verbose and easier to understand.\nIn addition, when you accept arbitrary methods,\nit's not safe to assume .apply() exists or is not overridden.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-regexp-test": "Prefers RegExp#test() over String#match() and String#exec().\n\nWhen you want to know whether a pattern is found in a string, use\nRegExp#test()\ninstead of String#match()\nor RegExp#exec(),\nas it exclusively returns a boolean and therefore is more efficient.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-response-static-json": "Enforces the use of Response.json() over new Response(JSON.stringify()).\n\nResponse.json() is a more concise and semantically clear way to create JSON responses.\nIt automatically sets the correct Content-Type header (application/json) and handles\nserialization, making the code more maintainable and less error-prone.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-set-has": "Prefer Set#has() over Array#includes() when checking for existence or non-existence.\n\nSet#has() is faster than Array#includes().\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-set-size": "Prefer Set#size over Set#length when the Set is converted to an array.\n\nUsing Set#size is more readable and performant.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-spread": "Enforces the use of the spread operator (...) over outdated patterns.\n\nUsing the spread operator is more concise and readable.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-string-raw": "Prefers use of String.raw to avoid escaping \\.\n\nExcessive backslashes can make string values less readable which can be avoided by using String.raw.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-string-replace-all": "Prefers String#replaceAll() over String#replace() when using a regex with the global flag.\n\nThe String#replaceAll() method is both faster and safer as you don't have to use a regex and remember to escape it if the string is not a literal. And when used with a regex, it makes the intent clearer.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-string-slice": "Prefer String#slice() over String#substr() and String#substring().\n\nString#substr() and String#substring() are the two lesser known legacy ways to slice a string. It's better to use String#slice() as it's a more popular option with clearer behavior that has a consistent Array counterpart.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-string-starts-ends-with": "Prefer String#startsWith() and String#endsWith() over using a regex with /^foo/ or /foo$/.\n\nUsing String#startsWith() and String#endsWith() is more readable and performant as it does not need to parse a regex.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-string-trim-start-end": "String#trimLeft() and String#trimRight() are aliases of String#trimStart() and String#trimEnd(). This is to ensure consistency and use direction-independent wording.\n\nThe trimLeft and trimRight names are confusing and inconsistent with the rest of the language.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-structured-clone": "Prefer using structuredClone to create a deep clone.\n\nstructuredClone is the modern way to create a deep clone of a value.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string[]\n\ndefault: [\"cloneDeep\", \"utils.clone\"]\n\nList of functions that are allowed to be used for deep cloning instead of structuredClone.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-top-level-await": "Prefer top-level await over top-level promises and async function calls.\n\nTop-level await is more readable and can prevent unhandled rejections.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-type-error": "Enforce throwing a TypeError instead of a generic Error after a type checking if-statement.\n\nThrowing a TypeError instead of a generic Error after a type checking if-statement is more specific and helps to catch bugs.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "require-array-join-separator": "Enforce using the separator argument with Array#join()\n\nIt's better to make it clear what the separator is when calling Array#join(),\ninstead of relying on the default comma (',') separator.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "require-module-attributes": "This rule enforces non-empty attribute list in import/export statements and import() expressions.\n\nImport attributes are meant to provide metadata about how a module should be loaded\n(e.g., with { type: \"json\" }). An empty attribute object provides no information\nand should be removed.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "require-module-specifiers": "Enforce non-empty specifier list in import and export statements.\n\nEmpty import/export specifiers add no value and can be confusing.\nIf you want to import a module for side effects, use import 'module' instead.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "require-number-to-fixed-digits-argument": "Enforce using the digits argument with Number.toFixed()\n\nIt's better to make it clear what the value of the digits argument is when calling Number.toFixed(),\ninstead of relying on the default value of 0.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "require-post-message-target-origin": "Enforce using the targetOrigin argument with window.postMessage()\n\nWhen calling window.postMessage() without the targetOrigin argument,\nthe message cannot be received by any window.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "switch-case-braces": "Requires empty switch cases to omit braces, while non-empty cases must use braces.\nThis reduces visual clutter for empty cases and enforces proper scoping for non-empty ones.\n\nUsing braces unnecessarily for empty cases adds visual noise,\nwhile omitting braces in non-empty cases can lead to scoping issues.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nExample config:\n\nThis rule accepts one of the following string values:\n\nAlways require braces in case clauses (except empty cases).\n\nAllow braces only when needed for scoping (e.g., variable or function declarations).\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "text-encoding-identifier-case": "This rule enforces consistent casing for text encoding identifiers, specifically:\n\n- 'utf8' instead of 'UTF-8' or 'utf-8'\n- 'ascii' instead of 'ASCII'\n\nInconsistent casing of encoding identifiers reduces code readability and\ncan lead to subtle confusion across a codebase. Although casing is not\nstrictly enforced by ECMAScript or Node.js, using lowercase is the\nconventional and widely recognized style.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "throw-new-error": "This rule makes sure you always use new when throwing an error.\n\nIn JavaScript, omitting new (e.g., throw Error('message')) is allowed,\nbut it does not properly initialize the error object. This can lead to missing\nstack traces or incorrect prototype chains. Using new makes the intent clear,\nensures consistent behavior, and helps avoid subtle bugs.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>"
  },
  "vitest": {
    "consistent-each-for": "This rule ensure consistency on which method used to create parameterized test.\nThis configuration affects to different test function types (test, it, describe, suite).\n\nNot having a consistent way to create parametrized tests, we rely on the developer to remember that\n.for spread the values as different arguments and .each pass the array as an unique argument.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: \"for\" | \"each\"\n\ntype: \"for\" | \"each\"\n\ntype: \"for\" | \"each\"\n\ntype: \"for\" | \"each\"\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "consistent-test-filename": "This rule triggers an error when a file is considered a test file, but its name\ndoes not match an expected filename format.\n\nFiles that are tests but with an unexpected filename make it hard to distinguish between\nsource code files and test files.\n\nAn example of an incorrect file path for this rule configured as {\"allTestPattern\": \"tests\",  \"pattern\": \".\\.spec\\.ts$\"}:\n\ntests/2.ts\n\nAn example of a correct file path for this rule configured as {\"allTestPattern\": \"tests\",  \"pattern\": \".\\.spec\\.ts$\"}:\n\ntests/2.spec.ts\n\nThis rule accepts a configuration object with the following properties:\n\ntype: string\n\nRegex pattern to ensure we are linting only test filenames.\nDecides whether a file is a testing file.\n\ntype: string\n\nRequired regex to check if a test filename have a valid formart.\nPattern doesn't have a default value, you must provide one.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "consistent-vitest-vi": "This rule triggers an error when an unexpected vitest accessor is used.\n\nNot having a consistent vitest accessor can lead to confusion\nwhen vi and vitest are used interchangeably.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: \"vi\" | \"vitest\"\n\ndefault: \"vi\"\n\nDecides whether to prefer vitest function accessor\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "hoisted-apis-on-top": "Enforce hoisted APIs to be on top of the file.\n\nSome Vitest APIs are hoisted automatically during the transform process. Using this APIs\nin look like runtime code can lead to unexpected results running tests.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-conditional-tests": "The rule disallows the use of conditional statements within test cases to\nensure that tests are deterministic and clearly readable.\n\nConditional statements in test cases can make tests unpredictable and\nharder to understand. Tests should be consistent and straightforward to\nensure reliable results and maintainability.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-import-node-test": "This rule warns when node:test is imported (usually accidentally).\nWith --fix, it will replace the import with vitest.\n\nUsing node:test instead of vitest can lead to inconsistent test results\nand missing features. vitest should be used for all testing to ensure\ncompatibility and access to its full functionality.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-unneeded-async-expect-function": "Disallows unnecessary async function wrapper for expected promises.\n\nWhen the only statement inside an async wrapper is await someCall(),\nthe call should be passed directly to expect instead. This makes the\ntest code more concise and easier to read.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-called-once": "Substitute toBeCalledTimes(1) and toHaveBeenCalledTimes(1) with\ntoBeCalledOnce() and toHaveBeenCalledOnce() respectively.\n\nThe \\Times method required to read the arguments to know how many times\nis expected a spy to be called. Most of the times you expecting a method is called\nonce.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable** this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-called-times": "This rule aims to enforce the use of toBeCalledTimes(1) or toHaveBeenCalledTimes(1) over toBeCalledOnce() or toHaveBeenCalledOnce().\n\nThis rule aims to enforce the use of toBeCalledTimes(1) or toHaveBeenCalledTimes(1) over toBeCalledOnce() or toHaveBeenCalledOnce().\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-describe-function-title": "When testing a specific function, this rule aims to enforce passing a named function to describe()\ninstead of an equivalent hardcoded string.\n\nTests that are related to a specific function, if the function being tested is renamed,\nthe describe title will be not match anymore and can make confusion in the future. Using the function\nensure a consistency even if the function is renamed.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-to-be-falsy": "This rule warns when toBe(false) is used with expect or expectTypeOf.\nWith --fix, it will be replaced with toBeFalsy().\n\nUsing toBe(false) is less expressive and may not account for other falsy\nvalues like 0, null, or undefined. toBeFalsy() provides a more\ncomprehensive check for any falsy value, improving the robustness of the tests.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-to-be-object": "This rule enforces using toBeObject() to check if a value is of type Object.\n\nUsing other methods such as toBeInstanceOf(Object) or instanceof Object can\nbe less clear and potentially misleading. Enforcing the use of toBeObject()\nprovides more explicit and readable code, making your intentions clear and\nimproving the overall maintainability and readability of your tests.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-to-be-truthy": "This rule warns when toBe(true) is used with expect or expectTypeOf.\nWith --fix, it will be replaced with toBeTruthy().\n\nUsing toBe(true) is less flexible and may not account for other truthy\nvalues like non-empty strings or objects. toBeTruthy() checks for any\ntruthy value, which makes the tests more comprehensive and robust.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "require-local-test-context-for-concurrent-snapshots": "The rule is intended to ensure that concurrent snapshot tests are executed\nwithin a properly configured local test context.\n\nRunning snapshot tests concurrently without a proper context can lead to\nunreliable or inconsistent snapshots. Ensuring that concurrent tests are\ncorrectly configured with the appropriate context helps maintain accurate\nand stable snapshots, avoiding potential conflicts or failures.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "warn-todo": "This rule triggers warnings when .todo is used in describe, it, or test functions.\nIt is recommended to use this with your CI pipeline to annotate PR diffs.\n\nThe test that you push should be completed, any pending/\"TODO\" code should not be committed.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>"
  },
  "vue": {
    "define-emits-declaration": "This rule enforces defineEmits typing style which you should use type-based, strict type-literal (introduced in Vue 3.3), or runtime declaration.\nThis rule only works in setup script and lang=\"ts\".\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts one of the following string values:\n\nEnforces the use of a named TypeScript type or interface as the\nargument to defineEmits, e.g. defineEmits<MyEmits>().\n\nEnforces the use of an inline type literal as the argument to\ndefineEmits, e.g. defineEmits<{ (event: string): void }>().\n\nEnforces the use of runtime declaration, where emits are declared\nusing an array or object, e.g. defineEmits(['event1', 'event2']).\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "define-props-declaration": "This rule enforces defineProps typing style which you should use type-based or runtime declaration.\nThis rule only works in setup script and lang=\"ts\".\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts one of the following string values:\n\nEnforce type-based declaration.\n\nEnforce runtime declaration.\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "define-props-destructuring": "This rule enforces a consistent style for handling Vue 3 Composition API props,\nallowing you to choose between requiring destructuring or prohibiting it.\n\nBy default, the rule requires you to use destructuring syntax when using defineProps\ninstead of storing props in a variable and warns against combining withDefaults with destructuring.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: \"always\" | \"never\"\n\ndefault: \"always\"\n\nRequire or prohibit destructuring.\n\nRequires destructuring when using defineProps and warns against using withDefaults with destructuring\n\nRequires using a variable to store props and prohibits destructuring\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "max-props": "Enforce maximum number of props in Vue component.\n\nThis rule enforces a maximum number of props in a Vue SFC,\nin order to aid in maintainability and reduce complexity.\n\nExamples of incorrect code for this rule with the default { \"maxProps\": 1 } option:\n\nExamples of correct code for this rule with the default { \"maxProps\": 1 } option:\n\nThis rule accepts a configuration object with the following properties:\n\ntype: integer\n\ndefault: 1\n\nThe maximum number of props allowed in a Vue Single File Component (SFC).\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-arrow-functions-in-watch": "This rule disallows using arrow functions when defining a watcher.\n\nArrow functions bind this lexically, which means they don't have access to the Vue component instance.\nIn Vue watchers, you often need access to this to interact with component data, methods, or other properties.\nUsing regular functions or method shorthand ensures proper this binding.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-deprecated-destroyed-lifecycle": "Disallow using deprecated destroyed and beforeDestroy lifecycle hooks in Vue.js 3.0.0+.\n\nIn Vue.js 3.0.0+, the destroyed and beforeDestroy lifecycle hooks have been renamed\nto unmounted and beforeUnmount respectively. Using the old names is deprecated and\nmay cause confusion or compatibility issues.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-export-in-script-setup": "Disallow export in <script setup>\n\nThe previous version of <script setup> RFC used export to define variables used in templates,\nbut the new <script setup> RFC has been updated to define without using export.\nSee Vue RFCs - 0040-script-setup for more details.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-import-compiler-macros": "Disallow importing Vue compiler macros.\n\nCompiler Macros like:\n\n- defineProps\n- defineEmits\n- defineExpose\n- withDefaults\n- defineModel\n- defineOptions\n- defineSlots\n\nare globally available in Vue 3's <script setup> and do not require explicit imports.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-lifecycle-after-await": "Disallow asynchronously registered lifecycle hooks.\n\nLifecycle hooks must be registered synchronously during setup() execution.\nIf a lifecycle hook is called after an await statement, it may be registered\ntoo late and might not work as expected.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-multiple-slot-args": "Disallow passing multiple arguments to scoped slots.\n\nUsers have to use the arguments in fixed order and cannot omit the ones they don't need.\ne.g. if you have a slot that passes in 5 arguments but the user actually only need the last 2 of them,\nthey will have to declare all 5 just to use the last 2.\n\nMore information can be found in vuejs/vue#9468\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-required-prop-with-default": "Enforce props with default values to be optional.\n\nIf a prop is declared with a default value, whether it is required or not,\nwe can always skip it in actual use. In that situation, the default value would be applied.\nSo, a required prop with a default value is essentially the same as an optional prop.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "no-this-in-before-route-enter": "Disallow this usage in a beforeRouteEnter method.\n\nThis rule is only relevant when using vue-router.\n\nInside a beforeRouteEnter method, there is no access to this.\nSee the vue-router docs.\nThis behavior isn't obvious, and so this lint rule can help prevent runtime errors in some cases.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "prefer-import-from-vue": "Enforce import from 'vue' instead of import from '@vue/'.\n\nImports from the following modules are almost always wrong. You should import from vue instead.\n\n- @vue/runtime-dom\n- @vue/runtime-core\n- @vue/reactivity\n- @vue/shared\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable** this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "require-default-export": "Require components to be the default export.\n\nUsing SFCs (Single File Components) without a default export is\nnot supported in Vue 3. Components should be exported as the default export.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "require-typed-ref": "Require ref and shallowRef functions to be strongly typed.\n\nWith TypeScript it is easy to prevent usage of any by using noImplicitAny.\nUnfortunately this rule is easily bypassed with Vue ref() function.\nCalling ref() function without a generic parameter or an initial value leads to ref having Ref<any> type.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "valid-define-emits": "This rule checks whether defineEmits compiler macro is valid.\n\nThis rule reports defineEmits compiler macros in the following cases:\n\n- defineEmits is referencing locally declared variables.\n- defineEmits has both a literal type and an argument. e.g. defineEmits<(e: 'foo')=>void>(['bar'])\n- defineEmits has been called multiple times.\n- Custom events are defined in both defineEmits and export default {}.\n- Custom events are not defined in either defineEmits or export default {}.\n\nMisusing defineEmits can lead to runtime errors, unclear component contracts, and lost type safety.\nVue may still compile the code, but emitted events may break silently or be typed incorrectly.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>",
    "valid-define-props": "This rule checks whether defineProps compiler macro is valid.\n\nThis rule reports defineProps compiler macros in the following cases:\n\n- defineProps is referencing locally declared variables.\n- defineProps has both a literal type and an argument. e.g. defineProps<{ /props/ }>({ /props/ })\n- defineProps has been called multiple times.\n- Props are defined in both defineProps and export default {}.\n- Props are not defined in either defineProps or export default {}.\n\nMisusing defineProps can lead to runtime errors, and lost type safety.\nVue may still compile the code, but properties may break silently or be typed incorrectly.\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nTo enable this rule using the config file or in the CLI, you can use:\n\n::: code-group\n\n:::\n\n- <a v-bind:href=\"source\" target=\"_blank\" rel=\"noreferrer\">Rule Source</a>"
  }
}
